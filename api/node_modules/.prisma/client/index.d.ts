
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CryptoToken
 * 
 */
export type CryptoToken = $Result.DefaultSelection<Prisma.$CryptoTokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Balance
 * 
 */
export type Balance = $Result.DefaultSelection<Prisma.$BalancePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Bet
 * 
 */
export type Bet = $Result.DefaultSelection<Prisma.$BetPayload>
/**
 * Model Bonus
 * 
 */
export type Bonus = $Result.DefaultSelection<Prisma.$BonusPayload>
/**
 * Model UserBonus
 * 
 */
export type UserBonus = $Result.DefaultSelection<Prisma.$UserBonusPayload>
/**
 * Model LeaderboardEntry
 * 
 */
export type LeaderboardEntry = $Result.DefaultSelection<Prisma.$LeaderboardEntryPayload>
/**
 * Model ReferralTransaction
 * 
 */
export type ReferralTransaction = $Result.DefaultSelection<Prisma.$ReferralTransactionPayload>
/**
 * Model OneTimeToken
 * 
 */
export type OneTimeToken = $Result.DefaultSelection<Prisma.$OneTimeTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BalanceType: {
  MAIN: 'MAIN',
  BONUS: 'BONUS'
};

export type BalanceType = (typeof BalanceType)[keyof typeof BalanceType]


export const TransactionType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAW: 'WITHDRAW',
  BONUS: 'BONUS',
  REFUND: 'REFUND',
  TRANSFER: 'TRANSFER'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const GameType: {
  SLOT: 'SLOT',
  ROULETTE: 'ROULETTE',
  BLACKJACK: 'BLACKJACK',
  CRASH: 'CRASH',
  LIVE_DEALER: 'LIVE_DEALER'
};

export type GameType = (typeof GameType)[keyof typeof GameType]


export const ReferralEventType: {
  BET_COMMISSION: 'BET_COMMISSION',
  DEPOSIT_BONUS: 'DEPOSIT_BONUS'
};

export type ReferralEventType = (typeof ReferralEventType)[keyof typeof ReferralEventType]

}

export type BalanceType = $Enums.BalanceType

export const BalanceType: typeof $Enums.BalanceType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type GameType = $Enums.GameType

export const GameType: typeof $Enums.GameType

export type ReferralEventType = $Enums.ReferralEventType

export const ReferralEventType: typeof $Enums.ReferralEventType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CryptoTokens
 * const cryptoTokens = await prisma.cryptoToken.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CryptoTokens
   * const cryptoTokens = await prisma.cryptoToken.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.cryptoToken`: Exposes CRUD operations for the **CryptoToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoTokens
    * const cryptoTokens = await prisma.cryptoToken.findMany()
    * ```
    */
  get cryptoToken(): Prisma.CryptoTokenDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.balance`: Exposes CRUD operations for the **Balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balance.findMany()
    * ```
    */
  get balance(): Prisma.BalanceDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.bet`: Exposes CRUD operations for the **Bet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bets
    * const bets = await prisma.bet.findMany()
    * ```
    */
  get bet(): Prisma.BetDelegate<ExtArgs>;

  /**
   * `prisma.bonus`: Exposes CRUD operations for the **Bonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bonuses
    * const bonuses = await prisma.bonus.findMany()
    * ```
    */
  get bonus(): Prisma.BonusDelegate<ExtArgs>;

  /**
   * `prisma.userBonus`: Exposes CRUD operations for the **UserBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBonuses
    * const userBonuses = await prisma.userBonus.findMany()
    * ```
    */
  get userBonus(): Prisma.UserBonusDelegate<ExtArgs>;

  /**
   * `prisma.leaderboardEntry`: Exposes CRUD operations for the **LeaderboardEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardEntries
    * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
    * ```
    */
  get leaderboardEntry(): Prisma.LeaderboardEntryDelegate<ExtArgs>;

  /**
   * `prisma.referralTransaction`: Exposes CRUD operations for the **ReferralTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralTransactions
    * const referralTransactions = await prisma.referralTransaction.findMany()
    * ```
    */
  get referralTransaction(): Prisma.ReferralTransactionDelegate<ExtArgs>;

  /**
   * `prisma.oneTimeToken`: Exposes CRUD operations for the **OneTimeToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OneTimeTokens
    * const oneTimeTokens = await prisma.oneTimeToken.findMany()
    * ```
    */
  get oneTimeToken(): Prisma.OneTimeTokenDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CryptoToken: 'CryptoToken',
    User: 'User',
    Balance: 'Balance',
    Transaction: 'Transaction',
    Bet: 'Bet',
    Bonus: 'Bonus',
    UserBonus: 'UserBonus',
    LeaderboardEntry: 'LeaderboardEntry',
    ReferralTransaction: 'ReferralTransaction',
    OneTimeToken: 'OneTimeToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "cryptoToken" | "user" | "balance" | "transaction" | "bet" | "bonus" | "userBonus" | "leaderboardEntry" | "referralTransaction" | "oneTimeToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CryptoToken: {
        payload: Prisma.$CryptoTokenPayload<ExtArgs>
        fields: Prisma.CryptoTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          findFirst: {
            args: Prisma.CryptoTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          findMany: {
            args: Prisma.CryptoTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>[]
          }
          create: {
            args: Prisma.CryptoTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          createMany: {
            args: Prisma.CryptoTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>[]
          }
          delete: {
            args: Prisma.CryptoTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          update: {
            args: Prisma.CryptoTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          deleteMany: {
            args: Prisma.CryptoTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CryptoTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          aggregate: {
            args: Prisma.CryptoTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoToken>
          }
          groupBy: {
            args: Prisma.CryptoTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoTokenCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoTokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Balance: {
        payload: Prisma.$BalancePayload<ExtArgs>
        fields: Prisma.BalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findFirst: {
            args: Prisma.BalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findMany: {
            args: Prisma.BalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          create: {
            args: Prisma.BalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          createMany: {
            args: Prisma.BalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          delete: {
            args: Prisma.BalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          update: {
            args: Prisma.BalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          deleteMany: {
            args: Prisma.BalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          aggregate: {
            args: Prisma.BalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalance>
          }
          groupBy: {
            args: Prisma.BalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Bet: {
        payload: Prisma.$BetPayload<ExtArgs>
        fields: Prisma.BetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          findFirst: {
            args: Prisma.BetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          findMany: {
            args: Prisma.BetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>[]
          }
          create: {
            args: Prisma.BetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          createMany: {
            args: Prisma.BetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>[]
          }
          delete: {
            args: Prisma.BetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          update: {
            args: Prisma.BetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          deleteMany: {
            args: Prisma.BetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          aggregate: {
            args: Prisma.BetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBet>
          }
          groupBy: {
            args: Prisma.BetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetCountArgs<ExtArgs>
            result: $Utils.Optional<BetCountAggregateOutputType> | number
          }
        }
      }
      Bonus: {
        payload: Prisma.$BonusPayload<ExtArgs>
        fields: Prisma.BonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          findFirst: {
            args: Prisma.BonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          findMany: {
            args: Prisma.BonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          create: {
            args: Prisma.BonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          createMany: {
            args: Prisma.BonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          delete: {
            args: Prisma.BonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          update: {
            args: Prisma.BonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          deleteMany: {
            args: Prisma.BonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          aggregate: {
            args: Prisma.BonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBonus>
          }
          groupBy: {
            args: Prisma.BonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BonusCountArgs<ExtArgs>
            result: $Utils.Optional<BonusCountAggregateOutputType> | number
          }
        }
      }
      UserBonus: {
        payload: Prisma.$UserBonusPayload<ExtArgs>
        fields: Prisma.UserBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          findFirst: {
            args: Prisma.UserBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          findMany: {
            args: Prisma.UserBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>[]
          }
          create: {
            args: Prisma.UserBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          createMany: {
            args: Prisma.UserBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>[]
          }
          delete: {
            args: Prisma.UserBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          update: {
            args: Prisma.UserBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          deleteMany: {
            args: Prisma.UserBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          aggregate: {
            args: Prisma.UserBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBonus>
          }
          groupBy: {
            args: Prisma.UserBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBonusCountArgs<ExtArgs>
            result: $Utils.Optional<UserBonusCountAggregateOutputType> | number
          }
        }
      }
      LeaderboardEntry: {
        payload: Prisma.$LeaderboardEntryPayload<ExtArgs>
        fields: Prisma.LeaderboardEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findMany: {
            args: Prisma.LeaderboardEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          create: {
            args: Prisma.LeaderboardEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          createMany: {
            args: Prisma.LeaderboardEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          delete: {
            args: Prisma.LeaderboardEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          update: {
            args: Prisma.LeaderboardEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboardEntry>
          }
          groupBy: {
            args: Prisma.LeaderboardEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardEntryCountAggregateOutputType> | number
          }
        }
      }
      ReferralTransaction: {
        payload: Prisma.$ReferralTransactionPayload<ExtArgs>
        fields: Prisma.ReferralTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          findFirst: {
            args: Prisma.ReferralTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          findMany: {
            args: Prisma.ReferralTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>[]
          }
          create: {
            args: Prisma.ReferralTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          createMany: {
            args: Prisma.ReferralTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>[]
          }
          delete: {
            args: Prisma.ReferralTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          update: {
            args: Prisma.ReferralTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          deleteMany: {
            args: Prisma.ReferralTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          aggregate: {
            args: Prisma.ReferralTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralTransaction>
          }
          groupBy: {
            args: Prisma.ReferralTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralTransactionCountAggregateOutputType> | number
          }
        }
      }
      OneTimeToken: {
        payload: Prisma.$OneTimeTokenPayload<ExtArgs>
        fields: Prisma.OneTimeTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OneTimeTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OneTimeTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          findFirst: {
            args: Prisma.OneTimeTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OneTimeTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          findMany: {
            args: Prisma.OneTimeTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>[]
          }
          create: {
            args: Prisma.OneTimeTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          createMany: {
            args: Prisma.OneTimeTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OneTimeTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>[]
          }
          delete: {
            args: Prisma.OneTimeTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          update: {
            args: Prisma.OneTimeTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          deleteMany: {
            args: Prisma.OneTimeTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OneTimeTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OneTimeTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          aggregate: {
            args: Prisma.OneTimeTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOneTimeToken>
          }
          groupBy: {
            args: Prisma.OneTimeTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<OneTimeTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OneTimeTokenCountArgs<ExtArgs>
            result: $Utils.Optional<OneTimeTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CryptoTokenCountOutputType
   */

  export type CryptoTokenCountOutputType = {
    balances: number
    transactions: number
    bets: number
    leaderboard: number
    userBonuses: number
    referralCommissions: number
  }

  export type CryptoTokenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balances?: boolean | CryptoTokenCountOutputTypeCountBalancesArgs
    transactions?: boolean | CryptoTokenCountOutputTypeCountTransactionsArgs
    bets?: boolean | CryptoTokenCountOutputTypeCountBetsArgs
    leaderboard?: boolean | CryptoTokenCountOutputTypeCountLeaderboardArgs
    userBonuses?: boolean | CryptoTokenCountOutputTypeCountUserBonusesArgs
    referralCommissions?: boolean | CryptoTokenCountOutputTypeCountReferralCommissionsArgs
  }

  // Custom InputTypes
  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTokenCountOutputType
     */
    select?: CryptoTokenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountUserBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountReferralCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralTransactionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    referrals: number
    balances: number
    transactions: number
    bets: number
    leaderboardEntries: number
    bonuses: number
    commissions: number
    referralActions: number
    authTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    balances?: boolean | UserCountOutputTypeCountBalancesArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    bets?: boolean | UserCountOutputTypeCountBetsArgs
    leaderboardEntries?: boolean | UserCountOutputTypeCountLeaderboardEntriesArgs
    bonuses?: boolean | UserCountOutputTypeCountBonusesArgs
    commissions?: boolean | UserCountOutputTypeCountCommissionsArgs
    referralActions?: boolean | UserCountOutputTypeCountReferralActionsArgs
    authTokens?: boolean | UserCountOutputTypeCountAuthTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneTimeTokenWhereInput
  }


  /**
   * Count Type BonusCountOutputType
   */

  export type BonusCountOutputType = {
    userBonuses: number
  }

  export type BonusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBonuses?: boolean | BonusCountOutputTypeCountUserBonusesArgs
  }

  // Custom InputTypes
  /**
   * BonusCountOutputType without action
   */
  export type BonusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonusCountOutputType
     */
    select?: BonusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BonusCountOutputType without action
   */
  export type BonusCountOutputTypeCountUserBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CryptoToken
   */

  export type AggregateCryptoToken = {
    _count: CryptoTokenCountAggregateOutputType | null
    _avg: CryptoTokenAvgAggregateOutputType | null
    _sum: CryptoTokenSumAggregateOutputType | null
    _min: CryptoTokenMinAggregateOutputType | null
    _max: CryptoTokenMaxAggregateOutputType | null
  }

  export type CryptoTokenAvgAggregateOutputType = {
    id: number | null
    decimals: number | null
  }

  export type CryptoTokenSumAggregateOutputType = {
    id: number | null
    decimals: number | null
  }

  export type CryptoTokenMinAggregateOutputType = {
    id: number | null
    symbol: string | null
    name: string | null
    network: string | null
    decimals: number | null
    createdAt: Date | null
  }

  export type CryptoTokenMaxAggregateOutputType = {
    id: number | null
    symbol: string | null
    name: string | null
    network: string | null
    decimals: number | null
    createdAt: Date | null
  }

  export type CryptoTokenCountAggregateOutputType = {
    id: number
    symbol: number
    name: number
    network: number
    decimals: number
    createdAt: number
    _all: number
  }


  export type CryptoTokenAvgAggregateInputType = {
    id?: true
    decimals?: true
  }

  export type CryptoTokenSumAggregateInputType = {
    id?: true
    decimals?: true
  }

  export type CryptoTokenMinAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    network?: true
    decimals?: true
    createdAt?: true
  }

  export type CryptoTokenMaxAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    network?: true
    decimals?: true
    createdAt?: true
  }

  export type CryptoTokenCountAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    network?: true
    decimals?: true
    createdAt?: true
    _all?: true
  }

  export type CryptoTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoToken to aggregate.
     */
    where?: CryptoTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTokens to fetch.
     */
    orderBy?: CryptoTokenOrderByWithRelationInput | CryptoTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoTokens
    **/
    _count?: true | CryptoTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoTokenMaxAggregateInputType
  }

  export type GetCryptoTokenAggregateType<T extends CryptoTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoToken[P]>
      : GetScalarType<T[P], AggregateCryptoToken[P]>
  }




  export type CryptoTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoTokenWhereInput
    orderBy?: CryptoTokenOrderByWithAggregationInput | CryptoTokenOrderByWithAggregationInput[]
    by: CryptoTokenScalarFieldEnum[] | CryptoTokenScalarFieldEnum
    having?: CryptoTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoTokenCountAggregateInputType | true
    _avg?: CryptoTokenAvgAggregateInputType
    _sum?: CryptoTokenSumAggregateInputType
    _min?: CryptoTokenMinAggregateInputType
    _max?: CryptoTokenMaxAggregateInputType
  }

  export type CryptoTokenGroupByOutputType = {
    id: number
    symbol: string
    name: string
    network: string
    decimals: number
    createdAt: Date
    _count: CryptoTokenCountAggregateOutputType | null
    _avg: CryptoTokenAvgAggregateOutputType | null
    _sum: CryptoTokenSumAggregateOutputType | null
    _min: CryptoTokenMinAggregateOutputType | null
    _max: CryptoTokenMaxAggregateOutputType | null
  }

  type GetCryptoTokenGroupByPayload<T extends CryptoTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoTokenGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoTokenGroupByOutputType[P]>
        }
      >
    >


  export type CryptoTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    network?: boolean
    decimals?: boolean
    createdAt?: boolean
    balances?: boolean | CryptoToken$balancesArgs<ExtArgs>
    transactions?: boolean | CryptoToken$transactionsArgs<ExtArgs>
    bets?: boolean | CryptoToken$betsArgs<ExtArgs>
    leaderboard?: boolean | CryptoToken$leaderboardArgs<ExtArgs>
    userBonuses?: boolean | CryptoToken$userBonusesArgs<ExtArgs>
    referralCommissions?: boolean | CryptoToken$referralCommissionsArgs<ExtArgs>
    _count?: boolean | CryptoTokenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoToken"]>

  export type CryptoTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    network?: boolean
    decimals?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cryptoToken"]>

  export type CryptoTokenSelectScalar = {
    id?: boolean
    symbol?: boolean
    name?: boolean
    network?: boolean
    decimals?: boolean
    createdAt?: boolean
  }

  export type CryptoTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balances?: boolean | CryptoToken$balancesArgs<ExtArgs>
    transactions?: boolean | CryptoToken$transactionsArgs<ExtArgs>
    bets?: boolean | CryptoToken$betsArgs<ExtArgs>
    leaderboard?: boolean | CryptoToken$leaderboardArgs<ExtArgs>
    userBonuses?: boolean | CryptoToken$userBonusesArgs<ExtArgs>
    referralCommissions?: boolean | CryptoToken$referralCommissionsArgs<ExtArgs>
    _count?: boolean | CryptoTokenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CryptoTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CryptoTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoToken"
    objects: {
      balances: Prisma.$BalancePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      bets: Prisma.$BetPayload<ExtArgs>[]
      leaderboard: Prisma.$LeaderboardEntryPayload<ExtArgs>[]
      userBonuses: Prisma.$UserBonusPayload<ExtArgs>[]
      referralCommissions: Prisma.$ReferralTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol: string
      name: string
      network: string
      decimals: number
      createdAt: Date
    }, ExtArgs["result"]["cryptoToken"]>
    composites: {}
  }

  type CryptoTokenGetPayload<S extends boolean | null | undefined | CryptoTokenDefaultArgs> = $Result.GetResult<Prisma.$CryptoTokenPayload, S>

  type CryptoTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CryptoTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CryptoTokenCountAggregateInputType | true
    }

  export interface CryptoTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoToken'], meta: { name: 'CryptoToken' } }
    /**
     * Find zero or one CryptoToken that matches the filter.
     * @param {CryptoTokenFindUniqueArgs} args - Arguments to find a CryptoToken
     * @example
     * // Get one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoTokenFindUniqueArgs>(args: SelectSubset<T, CryptoTokenFindUniqueArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CryptoToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CryptoTokenFindUniqueOrThrowArgs} args - Arguments to find a CryptoToken
     * @example
     * // Get one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CryptoToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenFindFirstArgs} args - Arguments to find a CryptoToken
     * @example
     * // Get one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoTokenFindFirstArgs>(args?: SelectSubset<T, CryptoTokenFindFirstArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CryptoToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenFindFirstOrThrowArgs} args - Arguments to find a CryptoToken
     * @example
     * // Get one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CryptoTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoTokens
     * const cryptoTokens = await prisma.cryptoToken.findMany()
     * 
     * // Get first 10 CryptoTokens
     * const cryptoTokens = await prisma.cryptoToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoTokenWithIdOnly = await prisma.cryptoToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoTokenFindManyArgs>(args?: SelectSubset<T, CryptoTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CryptoToken.
     * @param {CryptoTokenCreateArgs} args - Arguments to create a CryptoToken.
     * @example
     * // Create one CryptoToken
     * const CryptoToken = await prisma.cryptoToken.create({
     *   data: {
     *     // ... data to create a CryptoToken
     *   }
     * })
     * 
     */
    create<T extends CryptoTokenCreateArgs>(args: SelectSubset<T, CryptoTokenCreateArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CryptoTokens.
     * @param {CryptoTokenCreateManyArgs} args - Arguments to create many CryptoTokens.
     * @example
     * // Create many CryptoTokens
     * const cryptoToken = await prisma.cryptoToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoTokenCreateManyArgs>(args?: SelectSubset<T, CryptoTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoTokens and returns the data saved in the database.
     * @param {CryptoTokenCreateManyAndReturnArgs} args - Arguments to create many CryptoTokens.
     * @example
     * // Create many CryptoTokens
     * const cryptoToken = await prisma.cryptoToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoTokens and only return the `id`
     * const cryptoTokenWithIdOnly = await prisma.cryptoToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CryptoToken.
     * @param {CryptoTokenDeleteArgs} args - Arguments to delete one CryptoToken.
     * @example
     * // Delete one CryptoToken
     * const CryptoToken = await prisma.cryptoToken.delete({
     *   where: {
     *     // ... filter to delete one CryptoToken
     *   }
     * })
     * 
     */
    delete<T extends CryptoTokenDeleteArgs>(args: SelectSubset<T, CryptoTokenDeleteArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CryptoToken.
     * @param {CryptoTokenUpdateArgs} args - Arguments to update one CryptoToken.
     * @example
     * // Update one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoTokenUpdateArgs>(args: SelectSubset<T, CryptoTokenUpdateArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CryptoTokens.
     * @param {CryptoTokenDeleteManyArgs} args - Arguments to filter CryptoTokens to delete.
     * @example
     * // Delete a few CryptoTokens
     * const { count } = await prisma.cryptoToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoTokenDeleteManyArgs>(args?: SelectSubset<T, CryptoTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoTokens
     * const cryptoToken = await prisma.cryptoToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoTokenUpdateManyArgs>(args: SelectSubset<T, CryptoTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoToken.
     * @param {CryptoTokenUpsertArgs} args - Arguments to update or create a CryptoToken.
     * @example
     * // Update or create a CryptoToken
     * const cryptoToken = await prisma.cryptoToken.upsert({
     *   create: {
     *     // ... data to create a CryptoToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoToken we want to update
     *   }
     * })
     */
    upsert<T extends CryptoTokenUpsertArgs>(args: SelectSubset<T, CryptoTokenUpsertArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CryptoTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenCountArgs} args - Arguments to filter CryptoTokens to count.
     * @example
     * // Count the number of CryptoTokens
     * const count = await prisma.cryptoToken.count({
     *   where: {
     *     // ... the filter for the CryptoTokens we want to count
     *   }
     * })
    **/
    count<T extends CryptoTokenCountArgs>(
      args?: Subset<T, CryptoTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoTokenAggregateArgs>(args: Subset<T, CryptoTokenAggregateArgs>): Prisma.PrismaPromise<GetCryptoTokenAggregateType<T>>

    /**
     * Group by CryptoToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoTokenGroupByArgs['orderBy'] }
        : { orderBy?: CryptoTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoToken model
   */
  readonly fields: CryptoTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    balances<T extends CryptoToken$balancesArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends CryptoToken$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    bets<T extends CryptoToken$betsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$betsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findMany"> | Null>
    leaderboard<T extends CryptoToken$leaderboardArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$leaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany"> | Null>
    userBonuses<T extends CryptoToken$userBonusesArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$userBonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany"> | Null>
    referralCommissions<T extends CryptoToken$referralCommissionsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$referralCommissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoToken model
   */ 
  interface CryptoTokenFieldRefs {
    readonly id: FieldRef<"CryptoToken", 'Int'>
    readonly symbol: FieldRef<"CryptoToken", 'String'>
    readonly name: FieldRef<"CryptoToken", 'String'>
    readonly network: FieldRef<"CryptoToken", 'String'>
    readonly decimals: FieldRef<"CryptoToken", 'Int'>
    readonly createdAt: FieldRef<"CryptoToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoToken findUnique
   */
  export type CryptoTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoToken to fetch.
     */
    where: CryptoTokenWhereUniqueInput
  }

  /**
   * CryptoToken findUniqueOrThrow
   */
  export type CryptoTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoToken to fetch.
     */
    where: CryptoTokenWhereUniqueInput
  }

  /**
   * CryptoToken findFirst
   */
  export type CryptoTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoToken to fetch.
     */
    where?: CryptoTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTokens to fetch.
     */
    orderBy?: CryptoTokenOrderByWithRelationInput | CryptoTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoTokens.
     */
    cursor?: CryptoTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoTokens.
     */
    distinct?: CryptoTokenScalarFieldEnum | CryptoTokenScalarFieldEnum[]
  }

  /**
   * CryptoToken findFirstOrThrow
   */
  export type CryptoTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoToken to fetch.
     */
    where?: CryptoTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTokens to fetch.
     */
    orderBy?: CryptoTokenOrderByWithRelationInput | CryptoTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoTokens.
     */
    cursor?: CryptoTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoTokens.
     */
    distinct?: CryptoTokenScalarFieldEnum | CryptoTokenScalarFieldEnum[]
  }

  /**
   * CryptoToken findMany
   */
  export type CryptoTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTokens to fetch.
     */
    where?: CryptoTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTokens to fetch.
     */
    orderBy?: CryptoTokenOrderByWithRelationInput | CryptoTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoTokens.
     */
    cursor?: CryptoTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTokens.
     */
    skip?: number
    distinct?: CryptoTokenScalarFieldEnum | CryptoTokenScalarFieldEnum[]
  }

  /**
   * CryptoToken create
   */
  export type CryptoTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoToken.
     */
    data: XOR<CryptoTokenCreateInput, CryptoTokenUncheckedCreateInput>
  }

  /**
   * CryptoToken createMany
   */
  export type CryptoTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoTokens.
     */
    data: CryptoTokenCreateManyInput | CryptoTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoToken createManyAndReturn
   */
  export type CryptoTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CryptoTokens.
     */
    data: CryptoTokenCreateManyInput | CryptoTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoToken update
   */
  export type CryptoTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoToken.
     */
    data: XOR<CryptoTokenUpdateInput, CryptoTokenUncheckedUpdateInput>
    /**
     * Choose, which CryptoToken to update.
     */
    where: CryptoTokenWhereUniqueInput
  }

  /**
   * CryptoToken updateMany
   */
  export type CryptoTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoTokens.
     */
    data: XOR<CryptoTokenUpdateManyMutationInput, CryptoTokenUncheckedUpdateManyInput>
    /**
     * Filter which CryptoTokens to update
     */
    where?: CryptoTokenWhereInput
  }

  /**
   * CryptoToken upsert
   */
  export type CryptoTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoToken to update in case it exists.
     */
    where: CryptoTokenWhereUniqueInput
    /**
     * In case the CryptoToken found by the `where` argument doesn't exist, create a new CryptoToken with this data.
     */
    create: XOR<CryptoTokenCreateInput, CryptoTokenUncheckedCreateInput>
    /**
     * In case the CryptoToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoTokenUpdateInput, CryptoTokenUncheckedUpdateInput>
  }

  /**
   * CryptoToken delete
   */
  export type CryptoTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter which CryptoToken to delete.
     */
    where: CryptoTokenWhereUniqueInput
  }

  /**
   * CryptoToken deleteMany
   */
  export type CryptoTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoTokens to delete
     */
    where?: CryptoTokenWhereInput
  }

  /**
   * CryptoToken.balances
   */
  export type CryptoToken$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    cursor?: BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * CryptoToken.transactions
   */
  export type CryptoToken$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * CryptoToken.bets
   */
  export type CryptoToken$betsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    where?: BetWhereInput
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    cursor?: BetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * CryptoToken.leaderboard
   */
  export type CryptoToken$leaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    cursor?: LeaderboardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * CryptoToken.userBonuses
   */
  export type CryptoToken$userBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    cursor?: UserBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * CryptoToken.referralCommissions
   */
  export type CryptoToken$referralCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    where?: ReferralTransactionWhereInput
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    cursor?: ReferralTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * CryptoToken without action
   */
  export type CryptoTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    referredById: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    referredById: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    photoUrl: string | null
    passwordHash: string | null
    salt: string | null
    isAdmin: boolean | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredById: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    photoUrl: string | null
    passwordHash: string | null
    salt: string | null
    isAdmin: boolean | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredById: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    telegramId: number
    username: number
    firstName: number
    lastName: number
    photoUrl: number
    passwordHash: number
    salt: number
    isAdmin: number
    isBlocked: number
    createdAt: number
    updatedAt: number
    referralCode: number
    referredById: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    referredById?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    referredById?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    photoUrl?: true
    passwordHash?: true
    salt?: true
    isAdmin?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    photoUrl?: true
    passwordHash?: true
    salt?: true
    isAdmin?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    photoUrl?: true
    passwordHash?: true
    salt?: true
    isAdmin?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    telegramId: string
    username: string | null
    firstName: string | null
    lastName: string | null
    photoUrl: string | null
    passwordHash: string | null
    salt: string | null
    isAdmin: boolean
    isBlocked: boolean
    createdAt: Date
    updatedAt: Date
    referralCode: string
    referredById: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    photoUrl?: boolean
    passwordHash?: boolean
    salt?: boolean
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredById?: boolean
    referrer?: boolean | User$referrerArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    balances?: boolean | User$balancesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    bets?: boolean | User$betsArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    bonuses?: boolean | User$bonusesArgs<ExtArgs>
    commissions?: boolean | User$commissionsArgs<ExtArgs>
    referralActions?: boolean | User$referralActionsArgs<ExtArgs>
    authTokens?: boolean | User$authTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    photoUrl?: boolean
    passwordHash?: boolean
    salt?: boolean
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredById?: boolean
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    photoUrl?: boolean
    passwordHash?: boolean
    salt?: boolean
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredById?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | User$referrerArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    balances?: boolean | User$balancesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    bets?: boolean | User$betsArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    bonuses?: boolean | User$bonusesArgs<ExtArgs>
    commissions?: boolean | User$commissionsArgs<ExtArgs>
    referralActions?: boolean | User$referralActionsArgs<ExtArgs>
    authTokens?: boolean | User$authTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs> | null
      referrals: Prisma.$UserPayload<ExtArgs>[]
      balances: Prisma.$BalancePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      bets: Prisma.$BetPayload<ExtArgs>[]
      leaderboardEntries: Prisma.$LeaderboardEntryPayload<ExtArgs>[]
      bonuses: Prisma.$UserBonusPayload<ExtArgs>[]
      commissions: Prisma.$ReferralTransactionPayload<ExtArgs>[]
      referralActions: Prisma.$ReferralTransactionPayload<ExtArgs>[]
      authTokens: Prisma.$OneTimeTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telegramId: string
      username: string | null
      firstName: string | null
      lastName: string | null
      photoUrl: string | null
      passwordHash: string | null
      salt: string | null
      isAdmin: boolean
      isBlocked: boolean
      createdAt: Date
      updatedAt: Date
      referralCode: string
      referredById: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends User$referrerArgs<ExtArgs> = {}>(args?: Subset<T, User$referrerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    balances<T extends User$balancesArgs<ExtArgs> = {}>(args?: Subset<T, User$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    bets<T extends User$betsArgs<ExtArgs> = {}>(args?: Subset<T, User$betsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findMany"> | Null>
    leaderboardEntries<T extends User$leaderboardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany"> | Null>
    bonuses<T extends User$bonusesArgs<ExtArgs> = {}>(args?: Subset<T, User$bonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany"> | Null>
    commissions<T extends User$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    referralActions<T extends User$referralActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    authTokens<T extends User$authTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$authTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly telegramId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly photoUrl: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly salt: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly isBlocked: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly referredById: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.referrer
   */
  export type User$referrerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.balances
   */
  export type User$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    cursor?: BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.bets
   */
  export type User$betsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    where?: BetWhereInput
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    cursor?: BetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * User.leaderboardEntries
   */
  export type User$leaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    cursor?: LeaderboardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * User.bonuses
   */
  export type User$bonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    cursor?: UserBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * User.commissions
   */
  export type User$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    where?: ReferralTransactionWhereInput
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    cursor?: ReferralTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * User.referralActions
   */
  export type User$referralActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    where?: ReferralTransactionWhereInput
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    cursor?: ReferralTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * User.authTokens
   */
  export type User$authTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    where?: OneTimeTokenWhereInput
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    cursor?: OneTimeTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OneTimeTokenScalarFieldEnum | OneTimeTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Balance
   */

  export type AggregateBalance = {
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  export type BalanceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type BalanceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type BalanceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    type: $Enums.BalanceType | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalanceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    type: $Enums.BalanceType | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalanceCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    type: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BalanceAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    amount?: true
  }

  export type BalanceSumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    amount?: true
  }

  export type BalanceMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalanceMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalanceCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balance to aggregate.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceMaxAggregateInputType
  }

  export type GetBalanceAggregateType<T extends BalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance[P]>
      : GetScalarType<T[P], AggregateBalance[P]>
  }




  export type BalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithAggregationInput | BalanceOrderByWithAggregationInput[]
    by: BalanceScalarFieldEnum[] | BalanceScalarFieldEnum
    having?: BalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceCountAggregateInputType | true
    _avg?: BalanceAvgAggregateInputType
    _sum?: BalanceSumAggregateInputType
    _min?: BalanceMinAggregateInputType
    _max?: BalanceMaxAggregateInputType
  }

  export type BalanceGroupByOutputType = {
    id: number
    userId: number
    tokenId: number
    type: $Enums.BalanceType
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  type GetBalanceGroupByPayload<T extends BalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceGroupByOutputType[P]>
        }
      >
    >


  export type BalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type BalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $BalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Balance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number
      type: $Enums.BalanceType
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["balance"]>
    composites: {}
  }

  type BalanceGetPayload<S extends boolean | null | undefined | BalanceDefaultArgs> = $Result.GetResult<Prisma.$BalancePayload, S>

  type BalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BalanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BalanceCountAggregateInputType | true
    }

  export interface BalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balance'], meta: { name: 'Balance' } }
    /**
     * Find zero or one Balance that matches the filter.
     * @param {BalanceFindUniqueArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceFindUniqueArgs>(args: SelectSubset<T, BalanceFindUniqueArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Balance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BalanceFindUniqueOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceFindFirstArgs>(args?: SelectSubset<T, BalanceFindFirstArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balance.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceWithIdOnly = await prisma.balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceFindManyArgs>(args?: SelectSubset<T, BalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Balance.
     * @param {BalanceCreateArgs} args - Arguments to create a Balance.
     * @example
     * // Create one Balance
     * const Balance = await prisma.balance.create({
     *   data: {
     *     // ... data to create a Balance
     *   }
     * })
     * 
     */
    create<T extends BalanceCreateArgs>(args: SelectSubset<T, BalanceCreateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Balances.
     * @param {BalanceCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceCreateManyArgs>(args?: SelectSubset<T, BalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balances and returns the data saved in the database.
     * @param {BalanceCreateManyAndReturnArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Balance.
     * @param {BalanceDeleteArgs} args - Arguments to delete one Balance.
     * @example
     * // Delete one Balance
     * const Balance = await prisma.balance.delete({
     *   where: {
     *     // ... filter to delete one Balance
     *   }
     * })
     * 
     */
    delete<T extends BalanceDeleteArgs>(args: SelectSubset<T, BalanceDeleteArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Balance.
     * @param {BalanceUpdateArgs} args - Arguments to update one Balance.
     * @example
     * // Update one Balance
     * const balance = await prisma.balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceUpdateArgs>(args: SelectSubset<T, BalanceUpdateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Balances.
     * @param {BalanceDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceDeleteManyArgs>(args?: SelectSubset<T, BalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceUpdateManyArgs>(args: SelectSubset<T, BalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Balance.
     * @param {BalanceUpsertArgs} args - Arguments to update or create a Balance.
     * @example
     * // Update or create a Balance
     * const balance = await prisma.balance.upsert({
     *   create: {
     *     // ... data to create a Balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance we want to update
     *   }
     * })
     */
    upsert<T extends BalanceUpsertArgs>(args: SelectSubset<T, BalanceUpsertArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balance.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalanceCountArgs>(
      args?: Subset<T, BalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceAggregateArgs>(args: Subset<T, BalanceAggregateArgs>): Prisma.PrismaPromise<GetBalanceAggregateType<T>>

    /**
     * Group by Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceGroupByArgs['orderBy'] }
        : { orderBy?: BalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Balance model
   */
  readonly fields: BalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Balance model
   */ 
  interface BalanceFieldRefs {
    readonly id: FieldRef<"Balance", 'Int'>
    readonly userId: FieldRef<"Balance", 'Int'>
    readonly tokenId: FieldRef<"Balance", 'Int'>
    readonly type: FieldRef<"Balance", 'BalanceType'>
    readonly amount: FieldRef<"Balance", 'Decimal'>
    readonly createdAt: FieldRef<"Balance", 'DateTime'>
    readonly updatedAt: FieldRef<"Balance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Balance findUnique
   */
  export type BalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findUniqueOrThrow
   */
  export type BalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findFirst
   */
  export type BalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findFirstOrThrow
   */
  export type BalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findMany
   */
  export type BalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance create
   */
  export type BalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Balance.
     */
    data: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
  }

  /**
   * Balance createMany
   */
  export type BalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Balance createManyAndReturn
   */
  export type BalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance update
   */
  export type BalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Balance.
     */
    data: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
    /**
     * Choose, which Balance to update.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance updateMany
   */
  export type BalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
  }

  /**
   * Balance upsert
   */
  export type BalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Balance to update in case it exists.
     */
    where: BalanceWhereUniqueInput
    /**
     * In case the Balance found by the `where` argument doesn't exist, create a new Balance with this data.
     */
    create: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
    /**
     * In case the Balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
  }

  /**
   * Balance delete
   */
  export type BalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter which Balance to delete.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance deleteMany
   */
  export type BalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to delete
     */
    where?: BalanceWhereInput
  }

  /**
   * Balance without action
   */
  export type BalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    type: $Enums.TransactionType | null
    status: $Enums.TransactionStatus | null
    amount: Decimal | null
    txHash: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    type: $Enums.TransactionType | null
    status: $Enums.TransactionStatus | null
    amount: Decimal | null
    txHash: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    type: number
    status: number
    amount: number
    txHash: number
    walletAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    status?: true
    amount?: true
    txHash?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    status?: true
    amount?: true
    txHash?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    status?: true
    amount?: true
    txHash?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    userId: number
    tokenId: number
    type: $Enums.TransactionType
    status: $Enums.TransactionStatus
    amount: Decimal
    txHash: string | null
    walletAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    txHash?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    txHash?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    txHash?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number
      type: $Enums.TransactionType
      status: $Enums.TransactionStatus
      amount: Prisma.Decimal
      txHash: string | null
      walletAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly userId: FieldRef<"Transaction", 'Int'>
    readonly tokenId: FieldRef<"Transaction", 'Int'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly txHash: FieldRef<"Transaction", 'String'>
    readonly walletAddress: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Bet
   */

  export type AggregateBet = {
    _count: BetCountAggregateOutputType | null
    _avg: BetAvgAggregateOutputType | null
    _sum: BetSumAggregateOutputType | null
    _min: BetMinAggregateOutputType | null
    _max: BetMaxAggregateOutputType | null
  }

  export type BetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    betAmount: Decimal | null
    payoutAmount: Decimal | null
    netAmount: Decimal | null
    payoutRatio: number | null
  }

  export type BetSumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    betAmount: Decimal | null
    payoutAmount: Decimal | null
    netAmount: Decimal | null
    payoutRatio: number | null
  }

  export type BetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    gameType: $Enums.GameType | null
    betAmount: Decimal | null
    payoutAmount: Decimal | null
    netAmount: Decimal | null
    payoutRatio: number | null
    roundId: string | null
    createdAt: Date | null
  }

  export type BetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    gameType: $Enums.GameType | null
    betAmount: Decimal | null
    payoutAmount: Decimal | null
    netAmount: Decimal | null
    payoutRatio: number | null
    roundId: string | null
    createdAt: Date | null
  }

  export type BetCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    gameType: number
    betAmount: number
    payoutAmount: number
    netAmount: number
    payoutRatio: number
    roundId: number
    details: number
    createdAt: number
    _all: number
  }


  export type BetAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
  }

  export type BetSumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
  }

  export type BetMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameType?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
    roundId?: true
    createdAt?: true
  }

  export type BetMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameType?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
    roundId?: true
    createdAt?: true
  }

  export type BetCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameType?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
    roundId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type BetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bet to aggregate.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bets
    **/
    _count?: true | BetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetMaxAggregateInputType
  }

  export type GetBetAggregateType<T extends BetAggregateArgs> = {
        [P in keyof T & keyof AggregateBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBet[P]>
      : GetScalarType<T[P], AggregateBet[P]>
  }




  export type BetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetWhereInput
    orderBy?: BetOrderByWithAggregationInput | BetOrderByWithAggregationInput[]
    by: BetScalarFieldEnum[] | BetScalarFieldEnum
    having?: BetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetCountAggregateInputType | true
    _avg?: BetAvgAggregateInputType
    _sum?: BetSumAggregateInputType
    _min?: BetMinAggregateInputType
    _max?: BetMaxAggregateInputType
  }

  export type BetGroupByOutputType = {
    id: number
    userId: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal
    payoutAmount: Decimal
    netAmount: Decimal
    payoutRatio: number
    roundId: string
    details: JsonValue | null
    createdAt: Date
    _count: BetCountAggregateOutputType | null
    _avg: BetAvgAggregateOutputType | null
    _sum: BetSumAggregateOutputType | null
    _min: BetMinAggregateOutputType | null
    _max: BetMaxAggregateOutputType | null
  }

  type GetBetGroupByPayload<T extends BetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetGroupByOutputType[P]>
            : GetScalarType<T[P], BetGroupByOutputType[P]>
        }
      >
    >


  export type BetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameType?: boolean
    betAmount?: boolean
    payoutAmount?: boolean
    netAmount?: boolean
    payoutRatio?: boolean
    roundId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bet"]>

  export type BetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameType?: boolean
    betAmount?: boolean
    payoutAmount?: boolean
    netAmount?: boolean
    payoutRatio?: boolean
    roundId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bet"]>

  export type BetSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameType?: boolean
    betAmount?: boolean
    payoutAmount?: boolean
    netAmount?: boolean
    payoutRatio?: boolean
    roundId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type BetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type BetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $BetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number
      gameType: $Enums.GameType
      betAmount: Prisma.Decimal
      payoutAmount: Prisma.Decimal
      netAmount: Prisma.Decimal
      payoutRatio: number
      roundId: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["bet"]>
    composites: {}
  }

  type BetGetPayload<S extends boolean | null | undefined | BetDefaultArgs> = $Result.GetResult<Prisma.$BetPayload, S>

  type BetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BetCountAggregateInputType | true
    }

  export interface BetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bet'], meta: { name: 'Bet' } }
    /**
     * Find zero or one Bet that matches the filter.
     * @param {BetFindUniqueArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetFindUniqueArgs>(args: SelectSubset<T, BetFindUniqueArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BetFindUniqueOrThrowArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetFindUniqueOrThrowArgs>(args: SelectSubset<T, BetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindFirstArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetFindFirstArgs>(args?: SelectSubset<T, BetFindFirstArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindFirstOrThrowArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetFindFirstOrThrowArgs>(args?: SelectSubset<T, BetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bets
     * const bets = await prisma.bet.findMany()
     * 
     * // Get first 10 Bets
     * const bets = await prisma.bet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betWithIdOnly = await prisma.bet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetFindManyArgs>(args?: SelectSubset<T, BetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bet.
     * @param {BetCreateArgs} args - Arguments to create a Bet.
     * @example
     * // Create one Bet
     * const Bet = await prisma.bet.create({
     *   data: {
     *     // ... data to create a Bet
     *   }
     * })
     * 
     */
    create<T extends BetCreateArgs>(args: SelectSubset<T, BetCreateArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bets.
     * @param {BetCreateManyArgs} args - Arguments to create many Bets.
     * @example
     * // Create many Bets
     * const bet = await prisma.bet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetCreateManyArgs>(args?: SelectSubset<T, BetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bets and returns the data saved in the database.
     * @param {BetCreateManyAndReturnArgs} args - Arguments to create many Bets.
     * @example
     * // Create many Bets
     * const bet = await prisma.bet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bets and only return the `id`
     * const betWithIdOnly = await prisma.bet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetCreateManyAndReturnArgs>(args?: SelectSubset<T, BetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bet.
     * @param {BetDeleteArgs} args - Arguments to delete one Bet.
     * @example
     * // Delete one Bet
     * const Bet = await prisma.bet.delete({
     *   where: {
     *     // ... filter to delete one Bet
     *   }
     * })
     * 
     */
    delete<T extends BetDeleteArgs>(args: SelectSubset<T, BetDeleteArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bet.
     * @param {BetUpdateArgs} args - Arguments to update one Bet.
     * @example
     * // Update one Bet
     * const bet = await prisma.bet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetUpdateArgs>(args: SelectSubset<T, BetUpdateArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bets.
     * @param {BetDeleteManyArgs} args - Arguments to filter Bets to delete.
     * @example
     * // Delete a few Bets
     * const { count } = await prisma.bet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetDeleteManyArgs>(args?: SelectSubset<T, BetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bets
     * const bet = await prisma.bet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetUpdateManyArgs>(args: SelectSubset<T, BetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bet.
     * @param {BetUpsertArgs} args - Arguments to update or create a Bet.
     * @example
     * // Update or create a Bet
     * const bet = await prisma.bet.upsert({
     *   create: {
     *     // ... data to create a Bet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bet we want to update
     *   }
     * })
     */
    upsert<T extends BetUpsertArgs>(args: SelectSubset<T, BetUpsertArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetCountArgs} args - Arguments to filter Bets to count.
     * @example
     * // Count the number of Bets
     * const count = await prisma.bet.count({
     *   where: {
     *     // ... the filter for the Bets we want to count
     *   }
     * })
    **/
    count<T extends BetCountArgs>(
      args?: Subset<T, BetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetAggregateArgs>(args: Subset<T, BetAggregateArgs>): Prisma.PrismaPromise<GetBetAggregateType<T>>

    /**
     * Group by Bet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetGroupByArgs['orderBy'] }
        : { orderBy?: BetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bet model
   */
  readonly fields: BetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bet model
   */ 
  interface BetFieldRefs {
    readonly id: FieldRef<"Bet", 'Int'>
    readonly userId: FieldRef<"Bet", 'Int'>
    readonly tokenId: FieldRef<"Bet", 'Int'>
    readonly gameType: FieldRef<"Bet", 'GameType'>
    readonly betAmount: FieldRef<"Bet", 'Decimal'>
    readonly payoutAmount: FieldRef<"Bet", 'Decimal'>
    readonly netAmount: FieldRef<"Bet", 'Decimal'>
    readonly payoutRatio: FieldRef<"Bet", 'Float'>
    readonly roundId: FieldRef<"Bet", 'String'>
    readonly details: FieldRef<"Bet", 'Json'>
    readonly createdAt: FieldRef<"Bet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bet findUnique
   */
  export type BetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet findUniqueOrThrow
   */
  export type BetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet findFirst
   */
  export type BetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bets.
     */
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet findFirstOrThrow
   */
  export type BetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bets.
     */
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet findMany
   */
  export type BetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bets to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet create
   */
  export type BetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The data needed to create a Bet.
     */
    data: XOR<BetCreateInput, BetUncheckedCreateInput>
  }

  /**
   * Bet createMany
   */
  export type BetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bets.
     */
    data: BetCreateManyInput | BetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bet createManyAndReturn
   */
  export type BetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bets.
     */
    data: BetCreateManyInput | BetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bet update
   */
  export type BetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The data needed to update a Bet.
     */
    data: XOR<BetUpdateInput, BetUncheckedUpdateInput>
    /**
     * Choose, which Bet to update.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet updateMany
   */
  export type BetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bets.
     */
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyInput>
    /**
     * Filter which Bets to update
     */
    where?: BetWhereInput
  }

  /**
   * Bet upsert
   */
  export type BetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The filter to search for the Bet to update in case it exists.
     */
    where: BetWhereUniqueInput
    /**
     * In case the Bet found by the `where` argument doesn't exist, create a new Bet with this data.
     */
    create: XOR<BetCreateInput, BetUncheckedCreateInput>
    /**
     * In case the Bet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetUpdateInput, BetUncheckedUpdateInput>
  }

  /**
   * Bet delete
   */
  export type BetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter which Bet to delete.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet deleteMany
   */
  export type BetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bets to delete
     */
    where?: BetWhereInput
  }

  /**
   * Bet without action
   */
  export type BetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
  }


  /**
   * Model Bonus
   */

  export type AggregateBonus = {
    _count: BonusCountAggregateOutputType | null
    _avg: BonusAvgAggregateOutputType | null
    _sum: BonusSumAggregateOutputType | null
    _min: BonusMinAggregateOutputType | null
    _max: BonusMaxAggregateOutputType | null
  }

  export type BonusAvgAggregateOutputType = {
    id: number | null
    wageringMultiplier: number | null
    maxBonusAmount: Decimal | null
  }

  export type BonusSumAggregateOutputType = {
    id: number | null
    wageringMultiplier: number | null
    maxBonusAmount: Decimal | null
  }

  export type BonusMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    wageringMultiplier: number | null
    maxBonusAmount: Decimal | null
  }

  export type BonusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    wageringMultiplier: number | null
    maxBonusAmount: Decimal | null
  }

  export type BonusCountAggregateOutputType = {
    id: number
    name: number
    description: number
    wageringMultiplier: number
    maxBonusAmount: number
    _all: number
  }


  export type BonusAvgAggregateInputType = {
    id?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
  }

  export type BonusSumAggregateInputType = {
    id?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
  }

  export type BonusMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
  }

  export type BonusMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
  }

  export type BonusCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
    _all?: true
  }

  export type BonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonus to aggregate.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bonuses
    **/
    _count?: true | BonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BonusMaxAggregateInputType
  }

  export type GetBonusAggregateType<T extends BonusAggregateArgs> = {
        [P in keyof T & keyof AggregateBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBonus[P]>
      : GetScalarType<T[P], AggregateBonus[P]>
  }




  export type BonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithAggregationInput | BonusOrderByWithAggregationInput[]
    by: BonusScalarFieldEnum[] | BonusScalarFieldEnum
    having?: BonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BonusCountAggregateInputType | true
    _avg?: BonusAvgAggregateInputType
    _sum?: BonusSumAggregateInputType
    _min?: BonusMinAggregateInputType
    _max?: BonusMaxAggregateInputType
  }

  export type BonusGroupByOutputType = {
    id: number
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal
    _count: BonusCountAggregateOutputType | null
    _avg: BonusAvgAggregateOutputType | null
    _sum: BonusSumAggregateOutputType | null
    _min: BonusMinAggregateOutputType | null
    _max: BonusMaxAggregateOutputType | null
  }

  type GetBonusGroupByPayload<T extends BonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BonusGroupByOutputType[P]>
            : GetScalarType<T[P], BonusGroupByOutputType[P]>
        }
      >
    >


  export type BonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    wageringMultiplier?: boolean
    maxBonusAmount?: boolean
    userBonuses?: boolean | Bonus$userBonusesArgs<ExtArgs>
    _count?: boolean | BonusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    wageringMultiplier?: boolean
    maxBonusAmount?: boolean
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    wageringMultiplier?: boolean
    maxBonusAmount?: boolean
  }

  export type BonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBonuses?: boolean | Bonus$userBonusesArgs<ExtArgs>
    _count?: boolean | BonusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bonus"
    objects: {
      userBonuses: Prisma.$UserBonusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      wageringMultiplier: number
      maxBonusAmount: Prisma.Decimal
    }, ExtArgs["result"]["bonus"]>
    composites: {}
  }

  type BonusGetPayload<S extends boolean | null | undefined | BonusDefaultArgs> = $Result.GetResult<Prisma.$BonusPayload, S>

  type BonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BonusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BonusCountAggregateInputType | true
    }

  export interface BonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bonus'], meta: { name: 'Bonus' } }
    /**
     * Find zero or one Bonus that matches the filter.
     * @param {BonusFindUniqueArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BonusFindUniqueArgs>(args: SelectSubset<T, BonusFindUniqueArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bonus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BonusFindUniqueOrThrowArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BonusFindUniqueOrThrowArgs>(args: SelectSubset<T, BonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindFirstArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BonusFindFirstArgs>(args?: SelectSubset<T, BonusFindFirstArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindFirstOrThrowArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BonusFindFirstOrThrowArgs>(args?: SelectSubset<T, BonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bonuses
     * const bonuses = await prisma.bonus.findMany()
     * 
     * // Get first 10 Bonuses
     * const bonuses = await prisma.bonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bonusWithIdOnly = await prisma.bonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BonusFindManyArgs>(args?: SelectSubset<T, BonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bonus.
     * @param {BonusCreateArgs} args - Arguments to create a Bonus.
     * @example
     * // Create one Bonus
     * const Bonus = await prisma.bonus.create({
     *   data: {
     *     // ... data to create a Bonus
     *   }
     * })
     * 
     */
    create<T extends BonusCreateArgs>(args: SelectSubset<T, BonusCreateArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bonuses.
     * @param {BonusCreateManyArgs} args - Arguments to create many Bonuses.
     * @example
     * // Create many Bonuses
     * const bonus = await prisma.bonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BonusCreateManyArgs>(args?: SelectSubset<T, BonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bonuses and returns the data saved in the database.
     * @param {BonusCreateManyAndReturnArgs} args - Arguments to create many Bonuses.
     * @example
     * // Create many Bonuses
     * const bonus = await prisma.bonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bonuses and only return the `id`
     * const bonusWithIdOnly = await prisma.bonus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BonusCreateManyAndReturnArgs>(args?: SelectSubset<T, BonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bonus.
     * @param {BonusDeleteArgs} args - Arguments to delete one Bonus.
     * @example
     * // Delete one Bonus
     * const Bonus = await prisma.bonus.delete({
     *   where: {
     *     // ... filter to delete one Bonus
     *   }
     * })
     * 
     */
    delete<T extends BonusDeleteArgs>(args: SelectSubset<T, BonusDeleteArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bonus.
     * @param {BonusUpdateArgs} args - Arguments to update one Bonus.
     * @example
     * // Update one Bonus
     * const bonus = await prisma.bonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BonusUpdateArgs>(args: SelectSubset<T, BonusUpdateArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bonuses.
     * @param {BonusDeleteManyArgs} args - Arguments to filter Bonuses to delete.
     * @example
     * // Delete a few Bonuses
     * const { count } = await prisma.bonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BonusDeleteManyArgs>(args?: SelectSubset<T, BonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bonuses
     * const bonus = await prisma.bonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BonusUpdateManyArgs>(args: SelectSubset<T, BonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bonus.
     * @param {BonusUpsertArgs} args - Arguments to update or create a Bonus.
     * @example
     * // Update or create a Bonus
     * const bonus = await prisma.bonus.upsert({
     *   create: {
     *     // ... data to create a Bonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bonus we want to update
     *   }
     * })
     */
    upsert<T extends BonusUpsertArgs>(args: SelectSubset<T, BonusUpsertArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusCountArgs} args - Arguments to filter Bonuses to count.
     * @example
     * // Count the number of Bonuses
     * const count = await prisma.bonus.count({
     *   where: {
     *     // ... the filter for the Bonuses we want to count
     *   }
     * })
    **/
    count<T extends BonusCountArgs>(
      args?: Subset<T, BonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BonusAggregateArgs>(args: Subset<T, BonusAggregateArgs>): Prisma.PrismaPromise<GetBonusAggregateType<T>>

    /**
     * Group by Bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BonusGroupByArgs['orderBy'] }
        : { orderBy?: BonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bonus model
   */
  readonly fields: BonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userBonuses<T extends Bonus$userBonusesArgs<ExtArgs> = {}>(args?: Subset<T, Bonus$userBonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bonus model
   */ 
  interface BonusFieldRefs {
    readonly id: FieldRef<"Bonus", 'Int'>
    readonly name: FieldRef<"Bonus", 'String'>
    readonly description: FieldRef<"Bonus", 'String'>
    readonly wageringMultiplier: FieldRef<"Bonus", 'Float'>
    readonly maxBonusAmount: FieldRef<"Bonus", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Bonus findUnique
   */
  export type BonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus findUniqueOrThrow
   */
  export type BonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus findFirst
   */
  export type BonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonuses.
     */
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus findFirstOrThrow
   */
  export type BonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonuses.
     */
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus findMany
   */
  export type BonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonuses to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus create
   */
  export type BonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The data needed to create a Bonus.
     */
    data: XOR<BonusCreateInput, BonusUncheckedCreateInput>
  }

  /**
   * Bonus createMany
   */
  export type BonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bonuses.
     */
    data: BonusCreateManyInput | BonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bonus createManyAndReturn
   */
  export type BonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bonuses.
     */
    data: BonusCreateManyInput | BonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bonus update
   */
  export type BonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The data needed to update a Bonus.
     */
    data: XOR<BonusUpdateInput, BonusUncheckedUpdateInput>
    /**
     * Choose, which Bonus to update.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus updateMany
   */
  export type BonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bonuses.
     */
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyInput>
    /**
     * Filter which Bonuses to update
     */
    where?: BonusWhereInput
  }

  /**
   * Bonus upsert
   */
  export type BonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The filter to search for the Bonus to update in case it exists.
     */
    where: BonusWhereUniqueInput
    /**
     * In case the Bonus found by the `where` argument doesn't exist, create a new Bonus with this data.
     */
    create: XOR<BonusCreateInput, BonusUncheckedCreateInput>
    /**
     * In case the Bonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BonusUpdateInput, BonusUncheckedUpdateInput>
  }

  /**
   * Bonus delete
   */
  export type BonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter which Bonus to delete.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus deleteMany
   */
  export type BonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonuses to delete
     */
    where?: BonusWhereInput
  }

  /**
   * Bonus.userBonuses
   */
  export type Bonus$userBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    cursor?: UserBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * Bonus without action
   */
  export type BonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
  }


  /**
   * Model UserBonus
   */

  export type AggregateUserBonus = {
    _count: UserBonusCountAggregateOutputType | null
    _avg: UserBonusAvgAggregateOutputType | null
    _sum: UserBonusSumAggregateOutputType | null
    _min: UserBonusMinAggregateOutputType | null
    _max: UserBonusMaxAggregateOutputType | null
  }

  export type UserBonusAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    bonusId: number | null
    tokenId: number | null
    grantedAmount: Decimal | null
    requiredWager: Decimal | null
    wageredAmount: Decimal | null
  }

  export type UserBonusSumAggregateOutputType = {
    id: number | null
    userId: number | null
    bonusId: number | null
    tokenId: number | null
    grantedAmount: Decimal | null
    requiredWager: Decimal | null
    wageredAmount: Decimal | null
  }

  export type UserBonusMinAggregateOutputType = {
    id: number | null
    userId: number | null
    bonusId: number | null
    tokenId: number | null
    grantedAmount: Decimal | null
    requiredWager: Decimal | null
    wageredAmount: Decimal | null
    isActive: boolean | null
    isCompleted: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type UserBonusMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    bonusId: number | null
    tokenId: number | null
    grantedAmount: Decimal | null
    requiredWager: Decimal | null
    wageredAmount: Decimal | null
    isActive: boolean | null
    isCompleted: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type UserBonusCountAggregateOutputType = {
    id: number
    userId: number
    bonusId: number
    tokenId: number
    grantedAmount: number
    requiredWager: number
    wageredAmount: number
    isActive: number
    isCompleted: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type UserBonusAvgAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
  }

  export type UserBonusSumAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
  }

  export type UserBonusMinAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
    isActive?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
  }

  export type UserBonusMaxAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
    isActive?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
  }

  export type UserBonusCountAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
    isActive?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type UserBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBonus to aggregate.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBonuses
    **/
    _count?: true | UserBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBonusMaxAggregateInputType
  }

  export type GetUserBonusAggregateType<T extends UserBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBonus[P]>
      : GetScalarType<T[P], AggregateUserBonus[P]>
  }




  export type UserBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithAggregationInput | UserBonusOrderByWithAggregationInput[]
    by: UserBonusScalarFieldEnum[] | UserBonusScalarFieldEnum
    having?: UserBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBonusCountAggregateInputType | true
    _avg?: UserBonusAvgAggregateInputType
    _sum?: UserBonusSumAggregateInputType
    _min?: UserBonusMinAggregateInputType
    _max?: UserBonusMaxAggregateInputType
  }

  export type UserBonusGroupByOutputType = {
    id: number
    userId: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal
    requiredWager: Decimal
    wageredAmount: Decimal
    isActive: boolean
    isCompleted: boolean
    createdAt: Date
    expiresAt: Date | null
    _count: UserBonusCountAggregateOutputType | null
    _avg: UserBonusAvgAggregateOutputType | null
    _sum: UserBonusSumAggregateOutputType | null
    _min: UserBonusMinAggregateOutputType | null
    _max: UserBonusMaxAggregateOutputType | null
  }

  type GetUserBonusGroupByPayload<T extends UserBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBonusGroupByOutputType[P]>
            : GetScalarType<T[P], UserBonusGroupByOutputType[P]>
        }
      >
    >


  export type UserBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bonusId?: boolean
    tokenId?: boolean
    grantedAmount?: boolean
    requiredWager?: boolean
    wageredAmount?: boolean
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBonus"]>

  export type UserBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bonusId?: boolean
    tokenId?: boolean
    grantedAmount?: boolean
    requiredWager?: boolean
    wageredAmount?: boolean
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBonus"]>

  export type UserBonusSelectScalar = {
    id?: boolean
    userId?: boolean
    bonusId?: boolean
    tokenId?: boolean
    grantedAmount?: boolean
    requiredWager?: boolean
    wageredAmount?: boolean
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type UserBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type UserBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $UserBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBonus"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bonus: Prisma.$BonusPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      bonusId: number
      tokenId: number
      grantedAmount: Prisma.Decimal
      requiredWager: Prisma.Decimal
      wageredAmount: Prisma.Decimal
      isActive: boolean
      isCompleted: boolean
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["userBonus"]>
    composites: {}
  }

  type UserBonusGetPayload<S extends boolean | null | undefined | UserBonusDefaultArgs> = $Result.GetResult<Prisma.$UserBonusPayload, S>

  type UserBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBonusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBonusCountAggregateInputType | true
    }

  export interface UserBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBonus'], meta: { name: 'UserBonus' } }
    /**
     * Find zero or one UserBonus that matches the filter.
     * @param {UserBonusFindUniqueArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBonusFindUniqueArgs>(args: SelectSubset<T, UserBonusFindUniqueArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBonus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBonusFindUniqueOrThrowArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindFirstArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBonusFindFirstArgs>(args?: SelectSubset<T, UserBonusFindFirstArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindFirstOrThrowArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBonuses
     * const userBonuses = await prisma.userBonus.findMany()
     * 
     * // Get first 10 UserBonuses
     * const userBonuses = await prisma.userBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBonusWithIdOnly = await prisma.userBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBonusFindManyArgs>(args?: SelectSubset<T, UserBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBonus.
     * @param {UserBonusCreateArgs} args - Arguments to create a UserBonus.
     * @example
     * // Create one UserBonus
     * const UserBonus = await prisma.userBonus.create({
     *   data: {
     *     // ... data to create a UserBonus
     *   }
     * })
     * 
     */
    create<T extends UserBonusCreateArgs>(args: SelectSubset<T, UserBonusCreateArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBonuses.
     * @param {UserBonusCreateManyArgs} args - Arguments to create many UserBonuses.
     * @example
     * // Create many UserBonuses
     * const userBonus = await prisma.userBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBonusCreateManyArgs>(args?: SelectSubset<T, UserBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBonuses and returns the data saved in the database.
     * @param {UserBonusCreateManyAndReturnArgs} args - Arguments to create many UserBonuses.
     * @example
     * // Create many UserBonuses
     * const userBonus = await prisma.userBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBonuses and only return the `id`
     * const userBonusWithIdOnly = await prisma.userBonus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBonus.
     * @param {UserBonusDeleteArgs} args - Arguments to delete one UserBonus.
     * @example
     * // Delete one UserBonus
     * const UserBonus = await prisma.userBonus.delete({
     *   where: {
     *     // ... filter to delete one UserBonus
     *   }
     * })
     * 
     */
    delete<T extends UserBonusDeleteArgs>(args: SelectSubset<T, UserBonusDeleteArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBonus.
     * @param {UserBonusUpdateArgs} args - Arguments to update one UserBonus.
     * @example
     * // Update one UserBonus
     * const userBonus = await prisma.userBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBonusUpdateArgs>(args: SelectSubset<T, UserBonusUpdateArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBonuses.
     * @param {UserBonusDeleteManyArgs} args - Arguments to filter UserBonuses to delete.
     * @example
     * // Delete a few UserBonuses
     * const { count } = await prisma.userBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBonusDeleteManyArgs>(args?: SelectSubset<T, UserBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBonuses
     * const userBonus = await prisma.userBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBonusUpdateManyArgs>(args: SelectSubset<T, UserBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBonus.
     * @param {UserBonusUpsertArgs} args - Arguments to update or create a UserBonus.
     * @example
     * // Update or create a UserBonus
     * const userBonus = await prisma.userBonus.upsert({
     *   create: {
     *     // ... data to create a UserBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBonus we want to update
     *   }
     * })
     */
    upsert<T extends UserBonusUpsertArgs>(args: SelectSubset<T, UserBonusUpsertArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusCountArgs} args - Arguments to filter UserBonuses to count.
     * @example
     * // Count the number of UserBonuses
     * const count = await prisma.userBonus.count({
     *   where: {
     *     // ... the filter for the UserBonuses we want to count
     *   }
     * })
    **/
    count<T extends UserBonusCountArgs>(
      args?: Subset<T, UserBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBonusAggregateArgs>(args: Subset<T, UserBonusAggregateArgs>): Prisma.PrismaPromise<GetUserBonusAggregateType<T>>

    /**
     * Group by UserBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBonusGroupByArgs['orderBy'] }
        : { orderBy?: UserBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBonus model
   */
  readonly fields: UserBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bonus<T extends BonusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BonusDefaultArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBonus model
   */ 
  interface UserBonusFieldRefs {
    readonly id: FieldRef<"UserBonus", 'Int'>
    readonly userId: FieldRef<"UserBonus", 'Int'>
    readonly bonusId: FieldRef<"UserBonus", 'Int'>
    readonly tokenId: FieldRef<"UserBonus", 'Int'>
    readonly grantedAmount: FieldRef<"UserBonus", 'Decimal'>
    readonly requiredWager: FieldRef<"UserBonus", 'Decimal'>
    readonly wageredAmount: FieldRef<"UserBonus", 'Decimal'>
    readonly isActive: FieldRef<"UserBonus", 'Boolean'>
    readonly isCompleted: FieldRef<"UserBonus", 'Boolean'>
    readonly createdAt: FieldRef<"UserBonus", 'DateTime'>
    readonly expiresAt: FieldRef<"UserBonus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBonus findUnique
   */
  export type UserBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus findUniqueOrThrow
   */
  export type UserBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus findFirst
   */
  export type UserBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBonuses.
     */
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus findFirstOrThrow
   */
  export type UserBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBonuses.
     */
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus findMany
   */
  export type UserBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonuses to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus create
   */
  export type UserBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBonus.
     */
    data: XOR<UserBonusCreateInput, UserBonusUncheckedCreateInput>
  }

  /**
   * UserBonus createMany
   */
  export type UserBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBonuses.
     */
    data: UserBonusCreateManyInput | UserBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBonus createManyAndReturn
   */
  export type UserBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBonuses.
     */
    data: UserBonusCreateManyInput | UserBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBonus update
   */
  export type UserBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBonus.
     */
    data: XOR<UserBonusUpdateInput, UserBonusUncheckedUpdateInput>
    /**
     * Choose, which UserBonus to update.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus updateMany
   */
  export type UserBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBonuses.
     */
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyInput>
    /**
     * Filter which UserBonuses to update
     */
    where?: UserBonusWhereInput
  }

  /**
   * UserBonus upsert
   */
  export type UserBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBonus to update in case it exists.
     */
    where: UserBonusWhereUniqueInput
    /**
     * In case the UserBonus found by the `where` argument doesn't exist, create a new UserBonus with this data.
     */
    create: XOR<UserBonusCreateInput, UserBonusUncheckedCreateInput>
    /**
     * In case the UserBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBonusUpdateInput, UserBonusUncheckedUpdateInput>
  }

  /**
   * UserBonus delete
   */
  export type UserBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter which UserBonus to delete.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus deleteMany
   */
  export type UserBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBonuses to delete
     */
    where?: UserBonusWhereInput
  }

  /**
   * UserBonus without action
   */
  export type UserBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
  }


  /**
   * Model LeaderboardEntry
   */

  export type AggregateLeaderboardEntry = {
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  export type LeaderboardEntryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    score: Decimal | null
  }

  export type LeaderboardEntrySumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    score: Decimal | null
  }

  export type LeaderboardEntryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    metric: string | null
    score: Decimal | null
    period: string | null
    updatedAt: Date | null
  }

  export type LeaderboardEntryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    metric: string | null
    score: Decimal | null
    period: string | null
    updatedAt: Date | null
  }

  export type LeaderboardEntryCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    metric: number
    score: number
    period: number
    updatedAt: number
    _all: number
  }


  export type LeaderboardEntryAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    score?: true
  }

  export type LeaderboardEntrySumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    score?: true
  }

  export type LeaderboardEntryMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    metric?: true
    score?: true
    period?: true
    updatedAt?: true
  }

  export type LeaderboardEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    metric?: true
    score?: true
    period?: true
    updatedAt?: true
  }

  export type LeaderboardEntryCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    metric?: true
    score?: true
    period?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaderboardEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntry to aggregate.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderboardEntries
    **/
    _count?: true | LeaderboardEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type GetLeaderboardEntryAggregateType<T extends LeaderboardEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboardEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
      : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
  }




  export type LeaderboardEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithAggregationInput | LeaderboardEntryOrderByWithAggregationInput[]
    by: LeaderboardEntryScalarFieldEnum[] | LeaderboardEntryScalarFieldEnum
    having?: LeaderboardEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardEntryCountAggregateInputType | true
    _avg?: LeaderboardEntryAvgAggregateInputType
    _sum?: LeaderboardEntrySumAggregateInputType
    _min?: LeaderboardEntryMinAggregateInputType
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type LeaderboardEntryGroupByOutputType = {
    id: number
    userId: number
    tokenId: number | null
    metric: string
    score: Decimal
    period: string
    updatedAt: Date
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  type GetLeaderboardEntryGroupByPayload<T extends LeaderboardEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    metric?: boolean
    score?: boolean
    period?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | LeaderboardEntry$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    metric?: boolean
    score?: boolean
    period?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | LeaderboardEntry$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    metric?: boolean
    score?: boolean
    period?: boolean
    updatedAt?: boolean
  }

  export type LeaderboardEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | LeaderboardEntry$tokenArgs<ExtArgs>
  }
  export type LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | LeaderboardEntry$tokenArgs<ExtArgs>
  }

  export type $LeaderboardEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderboardEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number | null
      metric: string
      score: Prisma.Decimal
      period: string
      updatedAt: Date
    }, ExtArgs["result"]["leaderboardEntry"]>
    composites: {}
  }

  type LeaderboardEntryGetPayload<S extends boolean | null | undefined | LeaderboardEntryDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardEntryPayload, S>

  type LeaderboardEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaderboardEntryCountAggregateInputType | true
    }

  export interface LeaderboardEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardEntry'], meta: { name: 'LeaderboardEntry' } }
    /**
     * Find zero or one LeaderboardEntry that matches the filter.
     * @param {LeaderboardEntryFindUniqueArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardEntryFindUniqueArgs>(args: SelectSubset<T, LeaderboardEntryFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaderboardEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaderboardEntryFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaderboardEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardEntryFindFirstArgs>(args?: SelectSubset<T, LeaderboardEntryFindFirstArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaderboardEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaderboardEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
     * 
     * // Get first 10 LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaderboardEntryFindManyArgs>(args?: SelectSubset<T, LeaderboardEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaderboardEntry.
     * @param {LeaderboardEntryCreateArgs} args - Arguments to create a LeaderboardEntry.
     * @example
     * // Create one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.create({
     *   data: {
     *     // ... data to create a LeaderboardEntry
     *   }
     * })
     * 
     */
    create<T extends LeaderboardEntryCreateArgs>(args: SelectSubset<T, LeaderboardEntryCreateArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaderboardEntries.
     * @param {LeaderboardEntryCreateManyArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardEntryCreateManyArgs>(args?: SelectSubset<T, LeaderboardEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaderboardEntries and returns the data saved in the database.
     * @param {LeaderboardEntryCreateManyAndReturnArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaderboardEntries and only return the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderboardEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaderboardEntry.
     * @param {LeaderboardEntryDeleteArgs} args - Arguments to delete one LeaderboardEntry.
     * @example
     * // Delete one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardEntry
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardEntryDeleteArgs>(args: SelectSubset<T, LeaderboardEntryDeleteArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaderboardEntry.
     * @param {LeaderboardEntryUpdateArgs} args - Arguments to update one LeaderboardEntry.
     * @example
     * // Update one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardEntryUpdateArgs>(args: SelectSubset<T, LeaderboardEntryUpdateArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaderboardEntries.
     * @param {LeaderboardEntryDeleteManyArgs} args - Arguments to filter LeaderboardEntries to delete.
     * @example
     * // Delete a few LeaderboardEntries
     * const { count } = await prisma.leaderboardEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardEntryDeleteManyArgs>(args?: SelectSubset<T, LeaderboardEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardEntryUpdateManyArgs>(args: SelectSubset<T, LeaderboardEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaderboardEntry.
     * @param {LeaderboardEntryUpsertArgs} args - Arguments to update or create a LeaderboardEntry.
     * @example
     * // Update or create a LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.upsert({
     *   create: {
     *     // ... data to create a LeaderboardEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardEntry we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardEntryUpsertArgs>(args: SelectSubset<T, LeaderboardEntryUpsertArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryCountArgs} args - Arguments to filter LeaderboardEntries to count.
     * @example
     * // Count the number of LeaderboardEntries
     * const count = await prisma.leaderboardEntry.count({
     *   where: {
     *     // ... the filter for the LeaderboardEntries we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardEntryCountArgs>(
      args?: Subset<T, LeaderboardEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardEntryAggregateArgs>(args: Subset<T, LeaderboardEntryAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardEntryAggregateType<T>>

    /**
     * Group by LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardEntryGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderboardEntry model
   */
  readonly fields: LeaderboardEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends LeaderboardEntry$tokenArgs<ExtArgs> = {}>(args?: Subset<T, LeaderboardEntry$tokenArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaderboardEntry model
   */ 
  interface LeaderboardEntryFieldRefs {
    readonly id: FieldRef<"LeaderboardEntry", 'Int'>
    readonly userId: FieldRef<"LeaderboardEntry", 'Int'>
    readonly tokenId: FieldRef<"LeaderboardEntry", 'Int'>
    readonly metric: FieldRef<"LeaderboardEntry", 'String'>
    readonly score: FieldRef<"LeaderboardEntry", 'Decimal'>
    readonly period: FieldRef<"LeaderboardEntry", 'String'>
    readonly updatedAt: FieldRef<"LeaderboardEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaderboardEntry findUnique
   */
  export type LeaderboardEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry findUniqueOrThrow
   */
  export type LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry findFirst
   */
  export type LeaderboardEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry findFirstOrThrow
   */
  export type LeaderboardEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry findMany
   */
  export type LeaderboardEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntries to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry create
   */
  export type LeaderboardEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
  }

  /**
   * LeaderboardEntry createMany
   */
  export type LeaderboardEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaderboardEntry createManyAndReturn
   */
  export type LeaderboardEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaderboardEntry update
   */
  export type LeaderboardEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
    /**
     * Choose, which LeaderboardEntry to update.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry updateMany
   */
  export type LeaderboardEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderboardEntries.
     */
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardEntries to update
     */
    where?: LeaderboardEntryWhereInput
  }

  /**
   * LeaderboardEntry upsert
   */
  export type LeaderboardEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaderboardEntry to update in case it exists.
     */
    where: LeaderboardEntryWhereUniqueInput
    /**
     * In case the LeaderboardEntry found by the `where` argument doesn't exist, create a new LeaderboardEntry with this data.
     */
    create: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
    /**
     * In case the LeaderboardEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
  }

  /**
   * LeaderboardEntry delete
   */
  export type LeaderboardEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter which LeaderboardEntry to delete.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry deleteMany
   */
  export type LeaderboardEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntries to delete
     */
    where?: LeaderboardEntryWhereInput
  }

  /**
   * LeaderboardEntry.token
   */
  export type LeaderboardEntry$tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    where?: CryptoTokenWhereInput
  }

  /**
   * LeaderboardEntry without action
   */
  export type LeaderboardEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
  }


  /**
   * Model ReferralTransaction
   */

  export type AggregateReferralTransaction = {
    _count: ReferralTransactionCountAggregateOutputType | null
    _avg: ReferralTransactionAvgAggregateOutputType | null
    _sum: ReferralTransactionSumAggregateOutputType | null
    _min: ReferralTransactionMinAggregateOutputType | null
    _max: ReferralTransactionMaxAggregateOutputType | null
  }

  export type ReferralTransactionAvgAggregateOutputType = {
    id: number | null
    referrerId: number | null
    refereeId: number | null
    tokenId: number | null
    amount: Decimal | null
    sourceEntityId: number | null
  }

  export type ReferralTransactionSumAggregateOutputType = {
    id: number | null
    referrerId: number | null
    refereeId: number | null
    tokenId: number | null
    amount: Decimal | null
    sourceEntityId: number | null
  }

  export type ReferralTransactionMinAggregateOutputType = {
    id: number | null
    referrerId: number | null
    refereeId: number | null
    tokenId: number | null
    eventType: $Enums.ReferralEventType | null
    amount: Decimal | null
    sourceEntityId: number | null
    sourceEntityType: string | null
    createdAt: Date | null
  }

  export type ReferralTransactionMaxAggregateOutputType = {
    id: number | null
    referrerId: number | null
    refereeId: number | null
    tokenId: number | null
    eventType: $Enums.ReferralEventType | null
    amount: Decimal | null
    sourceEntityId: number | null
    sourceEntityType: string | null
    createdAt: Date | null
  }

  export type ReferralTransactionCountAggregateOutputType = {
    id: number
    referrerId: number
    refereeId: number
    tokenId: number
    eventType: number
    amount: number
    sourceEntityId: number
    sourceEntityType: number
    createdAt: number
    _all: number
  }


  export type ReferralTransactionAvgAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    amount?: true
    sourceEntityId?: true
  }

  export type ReferralTransactionSumAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    amount?: true
    sourceEntityId?: true
  }

  export type ReferralTransactionMinAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    eventType?: true
    amount?: true
    sourceEntityId?: true
    sourceEntityType?: true
    createdAt?: true
  }

  export type ReferralTransactionMaxAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    eventType?: true
    amount?: true
    sourceEntityId?: true
    sourceEntityType?: true
    createdAt?: true
  }

  export type ReferralTransactionCountAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    eventType?: true
    amount?: true
    sourceEntityId?: true
    sourceEntityType?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralTransaction to aggregate.
     */
    where?: ReferralTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralTransactions to fetch.
     */
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralTransactions
    **/
    _count?: true | ReferralTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralTransactionMaxAggregateInputType
  }

  export type GetReferralTransactionAggregateType<T extends ReferralTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralTransaction[P]>
      : GetScalarType<T[P], AggregateReferralTransaction[P]>
  }




  export type ReferralTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralTransactionWhereInput
    orderBy?: ReferralTransactionOrderByWithAggregationInput | ReferralTransactionOrderByWithAggregationInput[]
    by: ReferralTransactionScalarFieldEnum[] | ReferralTransactionScalarFieldEnum
    having?: ReferralTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralTransactionCountAggregateInputType | true
    _avg?: ReferralTransactionAvgAggregateInputType
    _sum?: ReferralTransactionSumAggregateInputType
    _min?: ReferralTransactionMinAggregateInputType
    _max?: ReferralTransactionMaxAggregateInputType
  }

  export type ReferralTransactionGroupByOutputType = {
    id: number
    referrerId: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal
    sourceEntityId: number
    sourceEntityType: string
    createdAt: Date
    _count: ReferralTransactionCountAggregateOutputType | null
    _avg: ReferralTransactionAvgAggregateOutputType | null
    _sum: ReferralTransactionSumAggregateOutputType | null
    _min: ReferralTransactionMinAggregateOutputType | null
    _max: ReferralTransactionMaxAggregateOutputType | null
  }

  type GetReferralTransactionGroupByPayload<T extends ReferralTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralTransactionGroupByOutputType[P]>
        }
      >
    >


  export type ReferralTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    tokenId?: boolean
    eventType?: boolean
    amount?: boolean
    sourceEntityId?: boolean
    sourceEntityType?: boolean
    createdAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralTransaction"]>

  export type ReferralTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    tokenId?: boolean
    eventType?: boolean
    amount?: boolean
    sourceEntityId?: boolean
    sourceEntityType?: boolean
    createdAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralTransaction"]>

  export type ReferralTransactionSelectScalar = {
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    tokenId?: boolean
    eventType?: boolean
    amount?: boolean
    sourceEntityId?: boolean
    sourceEntityType?: boolean
    createdAt?: boolean
  }

  export type ReferralTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type ReferralTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $ReferralTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralTransaction"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referee: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      referrerId: number
      refereeId: number
      tokenId: number
      eventType: $Enums.ReferralEventType
      amount: Prisma.Decimal
      sourceEntityId: number
      sourceEntityType: string
      createdAt: Date
    }, ExtArgs["result"]["referralTransaction"]>
    composites: {}
  }

  type ReferralTransactionGetPayload<S extends boolean | null | undefined | ReferralTransactionDefaultArgs> = $Result.GetResult<Prisma.$ReferralTransactionPayload, S>

  type ReferralTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralTransactionCountAggregateInputType | true
    }

  export interface ReferralTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralTransaction'], meta: { name: 'ReferralTransaction' } }
    /**
     * Find zero or one ReferralTransaction that matches the filter.
     * @param {ReferralTransactionFindUniqueArgs} args - Arguments to find a ReferralTransaction
     * @example
     * // Get one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralTransactionFindUniqueArgs>(args: SelectSubset<T, ReferralTransactionFindUniqueArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralTransactionFindUniqueOrThrowArgs} args - Arguments to find a ReferralTransaction
     * @example
     * // Get one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionFindFirstArgs} args - Arguments to find a ReferralTransaction
     * @example
     * // Get one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralTransactionFindFirstArgs>(args?: SelectSubset<T, ReferralTransactionFindFirstArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionFindFirstOrThrowArgs} args - Arguments to find a ReferralTransaction
     * @example
     * // Get one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralTransactions
     * const referralTransactions = await prisma.referralTransaction.findMany()
     * 
     * // Get first 10 ReferralTransactions
     * const referralTransactions = await prisma.referralTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralTransactionWithIdOnly = await prisma.referralTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralTransactionFindManyArgs>(args?: SelectSubset<T, ReferralTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralTransaction.
     * @param {ReferralTransactionCreateArgs} args - Arguments to create a ReferralTransaction.
     * @example
     * // Create one ReferralTransaction
     * const ReferralTransaction = await prisma.referralTransaction.create({
     *   data: {
     *     // ... data to create a ReferralTransaction
     *   }
     * })
     * 
     */
    create<T extends ReferralTransactionCreateArgs>(args: SelectSubset<T, ReferralTransactionCreateArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralTransactions.
     * @param {ReferralTransactionCreateManyArgs} args - Arguments to create many ReferralTransactions.
     * @example
     * // Create many ReferralTransactions
     * const referralTransaction = await prisma.referralTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralTransactionCreateManyArgs>(args?: SelectSubset<T, ReferralTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralTransactions and returns the data saved in the database.
     * @param {ReferralTransactionCreateManyAndReturnArgs} args - Arguments to create many ReferralTransactions.
     * @example
     * // Create many ReferralTransactions
     * const referralTransaction = await prisma.referralTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralTransactions and only return the `id`
     * const referralTransactionWithIdOnly = await prisma.referralTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralTransaction.
     * @param {ReferralTransactionDeleteArgs} args - Arguments to delete one ReferralTransaction.
     * @example
     * // Delete one ReferralTransaction
     * const ReferralTransaction = await prisma.referralTransaction.delete({
     *   where: {
     *     // ... filter to delete one ReferralTransaction
     *   }
     * })
     * 
     */
    delete<T extends ReferralTransactionDeleteArgs>(args: SelectSubset<T, ReferralTransactionDeleteArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralTransaction.
     * @param {ReferralTransactionUpdateArgs} args - Arguments to update one ReferralTransaction.
     * @example
     * // Update one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralTransactionUpdateArgs>(args: SelectSubset<T, ReferralTransactionUpdateArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralTransactions.
     * @param {ReferralTransactionDeleteManyArgs} args - Arguments to filter ReferralTransactions to delete.
     * @example
     * // Delete a few ReferralTransactions
     * const { count } = await prisma.referralTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralTransactionDeleteManyArgs>(args?: SelectSubset<T, ReferralTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralTransactions
     * const referralTransaction = await prisma.referralTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralTransactionUpdateManyArgs>(args: SelectSubset<T, ReferralTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralTransaction.
     * @param {ReferralTransactionUpsertArgs} args - Arguments to update or create a ReferralTransaction.
     * @example
     * // Update or create a ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.upsert({
     *   create: {
     *     // ... data to create a ReferralTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralTransaction we want to update
     *   }
     * })
     */
    upsert<T extends ReferralTransactionUpsertArgs>(args: SelectSubset<T, ReferralTransactionUpsertArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionCountArgs} args - Arguments to filter ReferralTransactions to count.
     * @example
     * // Count the number of ReferralTransactions
     * const count = await prisma.referralTransaction.count({
     *   where: {
     *     // ... the filter for the ReferralTransactions we want to count
     *   }
     * })
    **/
    count<T extends ReferralTransactionCountArgs>(
      args?: Subset<T, ReferralTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralTransactionAggregateArgs>(args: Subset<T, ReferralTransactionAggregateArgs>): Prisma.PrismaPromise<GetReferralTransactionAggregateType<T>>

    /**
     * Group by ReferralTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralTransactionGroupByArgs['orderBy'] }
        : { orderBy?: ReferralTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralTransaction model
   */
  readonly fields: ReferralTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralTransaction model
   */ 
  interface ReferralTransactionFieldRefs {
    readonly id: FieldRef<"ReferralTransaction", 'Int'>
    readonly referrerId: FieldRef<"ReferralTransaction", 'Int'>
    readonly refereeId: FieldRef<"ReferralTransaction", 'Int'>
    readonly tokenId: FieldRef<"ReferralTransaction", 'Int'>
    readonly eventType: FieldRef<"ReferralTransaction", 'ReferralEventType'>
    readonly amount: FieldRef<"ReferralTransaction", 'Decimal'>
    readonly sourceEntityId: FieldRef<"ReferralTransaction", 'Int'>
    readonly sourceEntityType: FieldRef<"ReferralTransaction", 'String'>
    readonly createdAt: FieldRef<"ReferralTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralTransaction findUnique
   */
  export type ReferralTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransaction to fetch.
     */
    where: ReferralTransactionWhereUniqueInput
  }

  /**
   * ReferralTransaction findUniqueOrThrow
   */
  export type ReferralTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransaction to fetch.
     */
    where: ReferralTransactionWhereUniqueInput
  }

  /**
   * ReferralTransaction findFirst
   */
  export type ReferralTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransaction to fetch.
     */
    where?: ReferralTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralTransactions to fetch.
     */
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralTransactions.
     */
    cursor?: ReferralTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralTransactions.
     */
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * ReferralTransaction findFirstOrThrow
   */
  export type ReferralTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransaction to fetch.
     */
    where?: ReferralTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralTransactions to fetch.
     */
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralTransactions.
     */
    cursor?: ReferralTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralTransactions.
     */
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * ReferralTransaction findMany
   */
  export type ReferralTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransactions to fetch.
     */
    where?: ReferralTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralTransactions to fetch.
     */
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralTransactions.
     */
    cursor?: ReferralTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralTransactions.
     */
    skip?: number
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * ReferralTransaction create
   */
  export type ReferralTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralTransaction.
     */
    data: XOR<ReferralTransactionCreateInput, ReferralTransactionUncheckedCreateInput>
  }

  /**
   * ReferralTransaction createMany
   */
  export type ReferralTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralTransactions.
     */
    data: ReferralTransactionCreateManyInput | ReferralTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralTransaction createManyAndReturn
   */
  export type ReferralTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralTransactions.
     */
    data: ReferralTransactionCreateManyInput | ReferralTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralTransaction update
   */
  export type ReferralTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralTransaction.
     */
    data: XOR<ReferralTransactionUpdateInput, ReferralTransactionUncheckedUpdateInput>
    /**
     * Choose, which ReferralTransaction to update.
     */
    where: ReferralTransactionWhereUniqueInput
  }

  /**
   * ReferralTransaction updateMany
   */
  export type ReferralTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralTransactions.
     */
    data: XOR<ReferralTransactionUpdateManyMutationInput, ReferralTransactionUncheckedUpdateManyInput>
    /**
     * Filter which ReferralTransactions to update
     */
    where?: ReferralTransactionWhereInput
  }

  /**
   * ReferralTransaction upsert
   */
  export type ReferralTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralTransaction to update in case it exists.
     */
    where: ReferralTransactionWhereUniqueInput
    /**
     * In case the ReferralTransaction found by the `where` argument doesn't exist, create a new ReferralTransaction with this data.
     */
    create: XOR<ReferralTransactionCreateInput, ReferralTransactionUncheckedCreateInput>
    /**
     * In case the ReferralTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralTransactionUpdateInput, ReferralTransactionUncheckedUpdateInput>
  }

  /**
   * ReferralTransaction delete
   */
  export type ReferralTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter which ReferralTransaction to delete.
     */
    where: ReferralTransactionWhereUniqueInput
  }

  /**
   * ReferralTransaction deleteMany
   */
  export type ReferralTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralTransactions to delete
     */
    where?: ReferralTransactionWhereInput
  }

  /**
   * ReferralTransaction without action
   */
  export type ReferralTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
  }


  /**
   * Model OneTimeToken
   */

  export type AggregateOneTimeToken = {
    _count: OneTimeTokenCountAggregateOutputType | null
    _avg: OneTimeTokenAvgAggregateOutputType | null
    _sum: OneTimeTokenSumAggregateOutputType | null
    _min: OneTimeTokenMinAggregateOutputType | null
    _max: OneTimeTokenMaxAggregateOutputType | null
  }

  export type OneTimeTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OneTimeTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OneTimeTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    createdAt: Date | null
    expiresAt: Date | null
    used: boolean | null
  }

  export type OneTimeTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    createdAt: Date | null
    expiresAt: Date | null
    used: boolean | null
  }

  export type OneTimeTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    createdAt: number
    expiresAt: number
    used: number
    _all: number
  }


  export type OneTimeTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OneTimeTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OneTimeTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    used?: true
  }

  export type OneTimeTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    used?: true
  }

  export type OneTimeTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    used?: true
    _all?: true
  }

  export type OneTimeTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneTimeToken to aggregate.
     */
    where?: OneTimeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeTokens to fetch.
     */
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OneTimeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OneTimeTokens
    **/
    _count?: true | OneTimeTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OneTimeTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OneTimeTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OneTimeTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OneTimeTokenMaxAggregateInputType
  }

  export type GetOneTimeTokenAggregateType<T extends OneTimeTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOneTimeToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOneTimeToken[P]>
      : GetScalarType<T[P], AggregateOneTimeToken[P]>
  }




  export type OneTimeTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneTimeTokenWhereInput
    orderBy?: OneTimeTokenOrderByWithAggregationInput | OneTimeTokenOrderByWithAggregationInput[]
    by: OneTimeTokenScalarFieldEnum[] | OneTimeTokenScalarFieldEnum
    having?: OneTimeTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OneTimeTokenCountAggregateInputType | true
    _avg?: OneTimeTokenAvgAggregateInputType
    _sum?: OneTimeTokenSumAggregateInputType
    _min?: OneTimeTokenMinAggregateInputType
    _max?: OneTimeTokenMaxAggregateInputType
  }

  export type OneTimeTokenGroupByOutputType = {
    id: number
    token: string
    userId: number
    createdAt: Date
    expiresAt: Date
    used: boolean
    _count: OneTimeTokenCountAggregateOutputType | null
    _avg: OneTimeTokenAvgAggregateOutputType | null
    _sum: OneTimeTokenSumAggregateOutputType | null
    _min: OneTimeTokenMinAggregateOutputType | null
    _max: OneTimeTokenMaxAggregateOutputType | null
  }

  type GetOneTimeTokenGroupByPayload<T extends OneTimeTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OneTimeTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OneTimeTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OneTimeTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OneTimeTokenGroupByOutputType[P]>
        }
      >
    >


  export type OneTimeTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneTimeToken"]>

  export type OneTimeTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneTimeToken"]>

  export type OneTimeTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    used?: boolean
  }

  export type OneTimeTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OneTimeTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OneTimeTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OneTimeToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      userId: number
      createdAt: Date
      expiresAt: Date
      used: boolean
    }, ExtArgs["result"]["oneTimeToken"]>
    composites: {}
  }

  type OneTimeTokenGetPayload<S extends boolean | null | undefined | OneTimeTokenDefaultArgs> = $Result.GetResult<Prisma.$OneTimeTokenPayload, S>

  type OneTimeTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OneTimeTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OneTimeTokenCountAggregateInputType | true
    }

  export interface OneTimeTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OneTimeToken'], meta: { name: 'OneTimeToken' } }
    /**
     * Find zero or one OneTimeToken that matches the filter.
     * @param {OneTimeTokenFindUniqueArgs} args - Arguments to find a OneTimeToken
     * @example
     * // Get one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OneTimeTokenFindUniqueArgs>(args: SelectSubset<T, OneTimeTokenFindUniqueArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OneTimeToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OneTimeTokenFindUniqueOrThrowArgs} args - Arguments to find a OneTimeToken
     * @example
     * // Get one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OneTimeTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, OneTimeTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OneTimeToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenFindFirstArgs} args - Arguments to find a OneTimeToken
     * @example
     * // Get one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OneTimeTokenFindFirstArgs>(args?: SelectSubset<T, OneTimeTokenFindFirstArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OneTimeToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenFindFirstOrThrowArgs} args - Arguments to find a OneTimeToken
     * @example
     * // Get one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OneTimeTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, OneTimeTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OneTimeTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OneTimeTokens
     * const oneTimeTokens = await prisma.oneTimeToken.findMany()
     * 
     * // Get first 10 OneTimeTokens
     * const oneTimeTokens = await prisma.oneTimeToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oneTimeTokenWithIdOnly = await prisma.oneTimeToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OneTimeTokenFindManyArgs>(args?: SelectSubset<T, OneTimeTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OneTimeToken.
     * @param {OneTimeTokenCreateArgs} args - Arguments to create a OneTimeToken.
     * @example
     * // Create one OneTimeToken
     * const OneTimeToken = await prisma.oneTimeToken.create({
     *   data: {
     *     // ... data to create a OneTimeToken
     *   }
     * })
     * 
     */
    create<T extends OneTimeTokenCreateArgs>(args: SelectSubset<T, OneTimeTokenCreateArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OneTimeTokens.
     * @param {OneTimeTokenCreateManyArgs} args - Arguments to create many OneTimeTokens.
     * @example
     * // Create many OneTimeTokens
     * const oneTimeToken = await prisma.oneTimeToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OneTimeTokenCreateManyArgs>(args?: SelectSubset<T, OneTimeTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OneTimeTokens and returns the data saved in the database.
     * @param {OneTimeTokenCreateManyAndReturnArgs} args - Arguments to create many OneTimeTokens.
     * @example
     * // Create many OneTimeTokens
     * const oneTimeToken = await prisma.oneTimeToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OneTimeTokens and only return the `id`
     * const oneTimeTokenWithIdOnly = await prisma.oneTimeToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OneTimeTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, OneTimeTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OneTimeToken.
     * @param {OneTimeTokenDeleteArgs} args - Arguments to delete one OneTimeToken.
     * @example
     * // Delete one OneTimeToken
     * const OneTimeToken = await prisma.oneTimeToken.delete({
     *   where: {
     *     // ... filter to delete one OneTimeToken
     *   }
     * })
     * 
     */
    delete<T extends OneTimeTokenDeleteArgs>(args: SelectSubset<T, OneTimeTokenDeleteArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OneTimeToken.
     * @param {OneTimeTokenUpdateArgs} args - Arguments to update one OneTimeToken.
     * @example
     * // Update one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OneTimeTokenUpdateArgs>(args: SelectSubset<T, OneTimeTokenUpdateArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OneTimeTokens.
     * @param {OneTimeTokenDeleteManyArgs} args - Arguments to filter OneTimeTokens to delete.
     * @example
     * // Delete a few OneTimeTokens
     * const { count } = await prisma.oneTimeToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OneTimeTokenDeleteManyArgs>(args?: SelectSubset<T, OneTimeTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OneTimeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OneTimeTokens
     * const oneTimeToken = await prisma.oneTimeToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OneTimeTokenUpdateManyArgs>(args: SelectSubset<T, OneTimeTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OneTimeToken.
     * @param {OneTimeTokenUpsertArgs} args - Arguments to update or create a OneTimeToken.
     * @example
     * // Update or create a OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.upsert({
     *   create: {
     *     // ... data to create a OneTimeToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OneTimeToken we want to update
     *   }
     * })
     */
    upsert<T extends OneTimeTokenUpsertArgs>(args: SelectSubset<T, OneTimeTokenUpsertArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OneTimeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenCountArgs} args - Arguments to filter OneTimeTokens to count.
     * @example
     * // Count the number of OneTimeTokens
     * const count = await prisma.oneTimeToken.count({
     *   where: {
     *     // ... the filter for the OneTimeTokens we want to count
     *   }
     * })
    **/
    count<T extends OneTimeTokenCountArgs>(
      args?: Subset<T, OneTimeTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OneTimeTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OneTimeToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OneTimeTokenAggregateArgs>(args: Subset<T, OneTimeTokenAggregateArgs>): Prisma.PrismaPromise<GetOneTimeTokenAggregateType<T>>

    /**
     * Group by OneTimeToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OneTimeTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OneTimeTokenGroupByArgs['orderBy'] }
        : { orderBy?: OneTimeTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OneTimeTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOneTimeTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OneTimeToken model
   */
  readonly fields: OneTimeTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OneTimeToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OneTimeTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OneTimeToken model
   */ 
  interface OneTimeTokenFieldRefs {
    readonly id: FieldRef<"OneTimeToken", 'Int'>
    readonly token: FieldRef<"OneTimeToken", 'String'>
    readonly userId: FieldRef<"OneTimeToken", 'Int'>
    readonly createdAt: FieldRef<"OneTimeToken", 'DateTime'>
    readonly expiresAt: FieldRef<"OneTimeToken", 'DateTime'>
    readonly used: FieldRef<"OneTimeToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OneTimeToken findUnique
   */
  export type OneTimeTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeToken to fetch.
     */
    where: OneTimeTokenWhereUniqueInput
  }

  /**
   * OneTimeToken findUniqueOrThrow
   */
  export type OneTimeTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeToken to fetch.
     */
    where: OneTimeTokenWhereUniqueInput
  }

  /**
   * OneTimeToken findFirst
   */
  export type OneTimeTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeToken to fetch.
     */
    where?: OneTimeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeTokens to fetch.
     */
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneTimeTokens.
     */
    cursor?: OneTimeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneTimeTokens.
     */
    distinct?: OneTimeTokenScalarFieldEnum | OneTimeTokenScalarFieldEnum[]
  }

  /**
   * OneTimeToken findFirstOrThrow
   */
  export type OneTimeTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeToken to fetch.
     */
    where?: OneTimeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeTokens to fetch.
     */
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneTimeTokens.
     */
    cursor?: OneTimeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneTimeTokens.
     */
    distinct?: OneTimeTokenScalarFieldEnum | OneTimeTokenScalarFieldEnum[]
  }

  /**
   * OneTimeToken findMany
   */
  export type OneTimeTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeTokens to fetch.
     */
    where?: OneTimeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeTokens to fetch.
     */
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OneTimeTokens.
     */
    cursor?: OneTimeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeTokens.
     */
    skip?: number
    distinct?: OneTimeTokenScalarFieldEnum | OneTimeTokenScalarFieldEnum[]
  }

  /**
   * OneTimeToken create
   */
  export type OneTimeTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a OneTimeToken.
     */
    data: XOR<OneTimeTokenCreateInput, OneTimeTokenUncheckedCreateInput>
  }

  /**
   * OneTimeToken createMany
   */
  export type OneTimeTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OneTimeTokens.
     */
    data: OneTimeTokenCreateManyInput | OneTimeTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OneTimeToken createManyAndReturn
   */
  export type OneTimeTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OneTimeTokens.
     */
    data: OneTimeTokenCreateManyInput | OneTimeTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OneTimeToken update
   */
  export type OneTimeTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a OneTimeToken.
     */
    data: XOR<OneTimeTokenUpdateInput, OneTimeTokenUncheckedUpdateInput>
    /**
     * Choose, which OneTimeToken to update.
     */
    where: OneTimeTokenWhereUniqueInput
  }

  /**
   * OneTimeToken updateMany
   */
  export type OneTimeTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OneTimeTokens.
     */
    data: XOR<OneTimeTokenUpdateManyMutationInput, OneTimeTokenUncheckedUpdateManyInput>
    /**
     * Filter which OneTimeTokens to update
     */
    where?: OneTimeTokenWhereInput
  }

  /**
   * OneTimeToken upsert
   */
  export type OneTimeTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the OneTimeToken to update in case it exists.
     */
    where: OneTimeTokenWhereUniqueInput
    /**
     * In case the OneTimeToken found by the `where` argument doesn't exist, create a new OneTimeToken with this data.
     */
    create: XOR<OneTimeTokenCreateInput, OneTimeTokenUncheckedCreateInput>
    /**
     * In case the OneTimeToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OneTimeTokenUpdateInput, OneTimeTokenUncheckedUpdateInput>
  }

  /**
   * OneTimeToken delete
   */
  export type OneTimeTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter which OneTimeToken to delete.
     */
    where: OneTimeTokenWhereUniqueInput
  }

  /**
   * OneTimeToken deleteMany
   */
  export type OneTimeTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneTimeTokens to delete
     */
    where?: OneTimeTokenWhereInput
  }

  /**
   * OneTimeToken without action
   */
  export type OneTimeTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CryptoTokenScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    name: 'name',
    network: 'network',
    decimals: 'decimals',
    createdAt: 'createdAt'
  };

  export type CryptoTokenScalarFieldEnum = (typeof CryptoTokenScalarFieldEnum)[keyof typeof CryptoTokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    telegramId: 'telegramId',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    photoUrl: 'photoUrl',
    passwordHash: 'passwordHash',
    salt: 'salt',
    isAdmin: 'isAdmin',
    isBlocked: 'isBlocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referralCode: 'referralCode',
    referredById: 'referredById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BalanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    type: 'type',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BalanceScalarFieldEnum = (typeof BalanceScalarFieldEnum)[keyof typeof BalanceScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    type: 'type',
    status: 'status',
    amount: 'amount',
    txHash: 'txHash',
    walletAddress: 'walletAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const BetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    gameType: 'gameType',
    betAmount: 'betAmount',
    payoutAmount: 'payoutAmount',
    netAmount: 'netAmount',
    payoutRatio: 'payoutRatio',
    roundId: 'roundId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type BetScalarFieldEnum = (typeof BetScalarFieldEnum)[keyof typeof BetScalarFieldEnum]


  export const BonusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    wageringMultiplier: 'wageringMultiplier',
    maxBonusAmount: 'maxBonusAmount'
  };

  export type BonusScalarFieldEnum = (typeof BonusScalarFieldEnum)[keyof typeof BonusScalarFieldEnum]


  export const UserBonusScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bonusId: 'bonusId',
    tokenId: 'tokenId',
    grantedAmount: 'grantedAmount',
    requiredWager: 'requiredWager',
    wageredAmount: 'wageredAmount',
    isActive: 'isActive',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type UserBonusScalarFieldEnum = (typeof UserBonusScalarFieldEnum)[keyof typeof UserBonusScalarFieldEnum]


  export const LeaderboardEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    metric: 'metric',
    score: 'score',
    period: 'period',
    updatedAt: 'updatedAt'
  };

  export type LeaderboardEntryScalarFieldEnum = (typeof LeaderboardEntryScalarFieldEnum)[keyof typeof LeaderboardEntryScalarFieldEnum]


  export const ReferralTransactionScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    tokenId: 'tokenId',
    eventType: 'eventType',
    amount: 'amount',
    sourceEntityId: 'sourceEntityId',
    sourceEntityType: 'sourceEntityType',
    createdAt: 'createdAt'
  };

  export type ReferralTransactionScalarFieldEnum = (typeof ReferralTransactionScalarFieldEnum)[keyof typeof ReferralTransactionScalarFieldEnum]


  export const OneTimeTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    used: 'used'
  };

  export type OneTimeTokenScalarFieldEnum = (typeof OneTimeTokenScalarFieldEnum)[keyof typeof OneTimeTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BalanceType'
   */
  export type EnumBalanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BalanceType'>
    


  /**
   * Reference to a field of type 'BalanceType[]'
   */
  export type ListEnumBalanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BalanceType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'GameType'
   */
  export type EnumGameTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameType'>
    


  /**
   * Reference to a field of type 'GameType[]'
   */
  export type ListEnumGameTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ReferralEventType'
   */
  export type EnumReferralEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralEventType'>
    


  /**
   * Reference to a field of type 'ReferralEventType[]'
   */
  export type ListEnumReferralEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralEventType[]'>
    
  /**
   * Deep Input Types
   */


  export type CryptoTokenWhereInput = {
    AND?: CryptoTokenWhereInput | CryptoTokenWhereInput[]
    OR?: CryptoTokenWhereInput[]
    NOT?: CryptoTokenWhereInput | CryptoTokenWhereInput[]
    id?: IntFilter<"CryptoToken"> | number
    symbol?: StringFilter<"CryptoToken"> | string
    name?: StringFilter<"CryptoToken"> | string
    network?: StringFilter<"CryptoToken"> | string
    decimals?: IntFilter<"CryptoToken"> | number
    createdAt?: DateTimeFilter<"CryptoToken"> | Date | string
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
    bets?: BetListRelationFilter
    leaderboard?: LeaderboardEntryListRelationFilter
    userBonuses?: UserBonusListRelationFilter
    referralCommissions?: ReferralTransactionListRelationFilter
  }

  export type CryptoTokenOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
    balances?: BalanceOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    bets?: BetOrderByRelationAggregateInput
    leaderboard?: LeaderboardEntryOrderByRelationAggregateInput
    userBonuses?: UserBonusOrderByRelationAggregateInput
    referralCommissions?: ReferralTransactionOrderByRelationAggregateInput
  }

  export type CryptoTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    symbol?: string
    AND?: CryptoTokenWhereInput | CryptoTokenWhereInput[]
    OR?: CryptoTokenWhereInput[]
    NOT?: CryptoTokenWhereInput | CryptoTokenWhereInput[]
    name?: StringFilter<"CryptoToken"> | string
    network?: StringFilter<"CryptoToken"> | string
    decimals?: IntFilter<"CryptoToken"> | number
    createdAt?: DateTimeFilter<"CryptoToken"> | Date | string
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
    bets?: BetListRelationFilter
    leaderboard?: LeaderboardEntryListRelationFilter
    userBonuses?: UserBonusListRelationFilter
    referralCommissions?: ReferralTransactionListRelationFilter
  }, "id" | "symbol">

  export type CryptoTokenOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
    _count?: CryptoTokenCountOrderByAggregateInput
    _avg?: CryptoTokenAvgOrderByAggregateInput
    _max?: CryptoTokenMaxOrderByAggregateInput
    _min?: CryptoTokenMinOrderByAggregateInput
    _sum?: CryptoTokenSumOrderByAggregateInput
  }

  export type CryptoTokenScalarWhereWithAggregatesInput = {
    AND?: CryptoTokenScalarWhereWithAggregatesInput | CryptoTokenScalarWhereWithAggregatesInput[]
    OR?: CryptoTokenScalarWhereWithAggregatesInput[]
    NOT?: CryptoTokenScalarWhereWithAggregatesInput | CryptoTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CryptoToken"> | number
    symbol?: StringWithAggregatesFilter<"CryptoToken"> | string
    name?: StringWithAggregatesFilter<"CryptoToken"> | string
    network?: StringWithAggregatesFilter<"CryptoToken"> | string
    decimals?: IntWithAggregatesFilter<"CryptoToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CryptoToken"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    telegramId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referralCode?: StringFilter<"User"> | string
    referredById?: IntNullableFilter<"User"> | number | null
    referrer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
    bets?: BetListRelationFilter
    leaderboardEntries?: LeaderboardEntryListRelationFilter
    bonuses?: UserBonusListRelationFilter
    commissions?: ReferralTransactionListRelationFilter
    referralActions?: ReferralTransactionListRelationFilter
    authTokens?: OneTimeTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    salt?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrderInput | SortOrder
    referrer?: UserOrderByWithRelationInput
    referrals?: UserOrderByRelationAggregateInput
    balances?: BalanceOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    bets?: BetOrderByRelationAggregateInput
    leaderboardEntries?: LeaderboardEntryOrderByRelationAggregateInput
    bonuses?: UserBonusOrderByRelationAggregateInput
    commissions?: ReferralTransactionOrderByRelationAggregateInput
    referralActions?: ReferralTransactionOrderByRelationAggregateInput
    authTokens?: OneTimeTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    telegramId?: string
    username?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: IntNullableFilter<"User"> | number | null
    referrer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
    bets?: BetListRelationFilter
    leaderboardEntries?: LeaderboardEntryListRelationFilter
    bonuses?: UserBonusListRelationFilter
    commissions?: ReferralTransactionListRelationFilter
    referralActions?: ReferralTransactionListRelationFilter
    authTokens?: OneTimeTokenListRelationFilter
  }, "id" | "telegramId" | "username" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    salt?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    telegramId?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    salt?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    isBlocked?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    referralCode?: StringWithAggregatesFilter<"User"> | string
    referredById?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type BalanceWhereInput = {
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    id?: IntFilter<"Balance"> | number
    userId?: IntFilter<"Balance"> | number
    tokenId?: IntFilter<"Balance"> | number
    type?: EnumBalanceTypeFilter<"Balance"> | $Enums.BalanceType
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Balance"> | Date | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type BalanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type BalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_tokenId_type?: BalanceUserIdTokenIdTypeCompoundUniqueInput
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    userId?: IntFilter<"Balance"> | number
    tokenId?: IntFilter<"Balance"> | number
    type?: EnumBalanceTypeFilter<"Balance"> | $Enums.BalanceType
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Balance"> | Date | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id" | "userId_tokenId_type">

  export type BalanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BalanceCountOrderByAggregateInput
    _avg?: BalanceAvgOrderByAggregateInput
    _max?: BalanceMaxOrderByAggregateInput
    _min?: BalanceMinOrderByAggregateInput
    _sum?: BalanceSumOrderByAggregateInput
  }

  export type BalanceScalarWhereWithAggregatesInput = {
    AND?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    OR?: BalanceScalarWhereWithAggregatesInput[]
    NOT?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Balance"> | number
    userId?: IntWithAggregatesFilter<"Balance"> | number
    tokenId?: IntWithAggregatesFilter<"Balance"> | number
    type?: EnumBalanceTypeWithAggregatesFilter<"Balance"> | $Enums.BalanceType
    amount?: DecimalWithAggregatesFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Balance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Balance"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    userId?: IntFilter<"Transaction"> | number
    tokenId?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"Transaction"> | string | null
    walletAddress?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    txHash?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: IntFilter<"Transaction"> | number
    tokenId?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    walletAddress?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id" | "txHash">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    userId?: IntWithAggregatesFilter<"Transaction"> | number
    tokenId?: IntWithAggregatesFilter<"Transaction"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    walletAddress?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type BetWhereInput = {
    AND?: BetWhereInput | BetWhereInput[]
    OR?: BetWhereInput[]
    NOT?: BetWhereInput | BetWhereInput[]
    id?: IntFilter<"Bet"> | number
    userId?: IntFilter<"Bet"> | number
    tokenId?: IntFilter<"Bet"> | number
    gameType?: EnumGameTypeFilter<"Bet"> | $Enums.GameType
    betAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFilter<"Bet"> | number
    roundId?: StringFilter<"Bet"> | string
    details?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type BetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type BetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BetWhereInput | BetWhereInput[]
    OR?: BetWhereInput[]
    NOT?: BetWhereInput | BetWhereInput[]
    userId?: IntFilter<"Bet"> | number
    tokenId?: IntFilter<"Bet"> | number
    gameType?: EnumGameTypeFilter<"Bet"> | $Enums.GameType
    betAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFilter<"Bet"> | number
    roundId?: StringFilter<"Bet"> | string
    details?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id">

  export type BetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BetCountOrderByAggregateInput
    _avg?: BetAvgOrderByAggregateInput
    _max?: BetMaxOrderByAggregateInput
    _min?: BetMinOrderByAggregateInput
    _sum?: BetSumOrderByAggregateInput
  }

  export type BetScalarWhereWithAggregatesInput = {
    AND?: BetScalarWhereWithAggregatesInput | BetScalarWhereWithAggregatesInput[]
    OR?: BetScalarWhereWithAggregatesInput[]
    NOT?: BetScalarWhereWithAggregatesInput | BetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bet"> | number
    userId?: IntWithAggregatesFilter<"Bet"> | number
    tokenId?: IntWithAggregatesFilter<"Bet"> | number
    gameType?: EnumGameTypeWithAggregatesFilter<"Bet"> | $Enums.GameType
    betAmount?: DecimalWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatWithAggregatesFilter<"Bet"> | number
    roundId?: StringWithAggregatesFilter<"Bet"> | string
    details?: JsonNullableWithAggregatesFilter<"Bet">
    createdAt?: DateTimeWithAggregatesFilter<"Bet"> | Date | string
  }

  export type BonusWhereInput = {
    AND?: BonusWhereInput | BonusWhereInput[]
    OR?: BonusWhereInput[]
    NOT?: BonusWhereInput | BonusWhereInput[]
    id?: IntFilter<"Bonus"> | number
    name?: StringFilter<"Bonus"> | string
    description?: StringFilter<"Bonus"> | string
    wageringMultiplier?: FloatFilter<"Bonus"> | number
    maxBonusAmount?: DecimalFilter<"Bonus"> | Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusListRelationFilter
  }

  export type BonusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
    userBonuses?: UserBonusOrderByRelationAggregateInput
  }

  export type BonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BonusWhereInput | BonusWhereInput[]
    OR?: BonusWhereInput[]
    NOT?: BonusWhereInput | BonusWhereInput[]
    description?: StringFilter<"Bonus"> | string
    wageringMultiplier?: FloatFilter<"Bonus"> | number
    maxBonusAmount?: DecimalFilter<"Bonus"> | Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusListRelationFilter
  }, "id" | "name">

  export type BonusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
    _count?: BonusCountOrderByAggregateInput
    _avg?: BonusAvgOrderByAggregateInput
    _max?: BonusMaxOrderByAggregateInput
    _min?: BonusMinOrderByAggregateInput
    _sum?: BonusSumOrderByAggregateInput
  }

  export type BonusScalarWhereWithAggregatesInput = {
    AND?: BonusScalarWhereWithAggregatesInput | BonusScalarWhereWithAggregatesInput[]
    OR?: BonusScalarWhereWithAggregatesInput[]
    NOT?: BonusScalarWhereWithAggregatesInput | BonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bonus"> | number
    name?: StringWithAggregatesFilter<"Bonus"> | string
    description?: StringWithAggregatesFilter<"Bonus"> | string
    wageringMultiplier?: FloatWithAggregatesFilter<"Bonus"> | number
    maxBonusAmount?: DecimalWithAggregatesFilter<"Bonus"> | Decimal | DecimalJsLike | number | string
  }

  export type UserBonusWhereInput = {
    AND?: UserBonusWhereInput | UserBonusWhereInput[]
    OR?: UserBonusWhereInput[]
    NOT?: UserBonusWhereInput | UserBonusWhereInput[]
    id?: IntFilter<"UserBonus"> | number
    userId?: IntFilter<"UserBonus"> | number
    bonusId?: IntFilter<"UserBonus"> | number
    tokenId?: IntFilter<"UserBonus"> | number
    grantedAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"UserBonus"> | boolean
    isCompleted?: BoolFilter<"UserBonus"> | boolean
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    bonus?: XOR<BonusRelationFilter, BonusWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type UserBonusOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    bonus?: BonusOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type UserBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_bonusId_tokenId?: UserBonusUserIdBonusIdTokenIdCompoundUniqueInput
    AND?: UserBonusWhereInput | UserBonusWhereInput[]
    OR?: UserBonusWhereInput[]
    NOT?: UserBonusWhereInput | UserBonusWhereInput[]
    userId?: IntFilter<"UserBonus"> | number
    bonusId?: IntFilter<"UserBonus"> | number
    tokenId?: IntFilter<"UserBonus"> | number
    grantedAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"UserBonus"> | boolean
    isCompleted?: BoolFilter<"UserBonus"> | boolean
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    bonus?: XOR<BonusRelationFilter, BonusWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id" | "userId_bonusId_tokenId">

  export type UserBonusOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: UserBonusCountOrderByAggregateInput
    _avg?: UserBonusAvgOrderByAggregateInput
    _max?: UserBonusMaxOrderByAggregateInput
    _min?: UserBonusMinOrderByAggregateInput
    _sum?: UserBonusSumOrderByAggregateInput
  }

  export type UserBonusScalarWhereWithAggregatesInput = {
    AND?: UserBonusScalarWhereWithAggregatesInput | UserBonusScalarWhereWithAggregatesInput[]
    OR?: UserBonusScalarWhereWithAggregatesInput[]
    NOT?: UserBonusScalarWhereWithAggregatesInput | UserBonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserBonus"> | number
    userId?: IntWithAggregatesFilter<"UserBonus"> | number
    bonusId?: IntWithAggregatesFilter<"UserBonus"> | number
    tokenId?: IntWithAggregatesFilter<"UserBonus"> | number
    grantedAmount?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"UserBonus"> | boolean
    isCompleted?: BoolWithAggregatesFilter<"UserBonus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserBonus"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserBonus"> | Date | string | null
  }

  export type LeaderboardEntryWhereInput = {
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    id?: IntFilter<"LeaderboardEntry"> | number
    userId?: IntFilter<"LeaderboardEntry"> | number
    tokenId?: IntNullableFilter<"LeaderboardEntry"> | number | null
    metric?: StringFilter<"LeaderboardEntry"> | string
    score?: DecimalFilter<"LeaderboardEntry"> | Decimal | DecimalJsLike | number | string
    period?: StringFilter<"LeaderboardEntry"> | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenNullableRelationFilter, CryptoTokenWhereInput> | null
  }

  export type LeaderboardEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type LeaderboardEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_metric_period_tokenId?: LeaderboardEntryUserIdMetricPeriodTokenIdCompoundUniqueInput
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    userId?: IntFilter<"LeaderboardEntry"> | number
    tokenId?: IntNullableFilter<"LeaderboardEntry"> | number | null
    metric?: StringFilter<"LeaderboardEntry"> | string
    score?: DecimalFilter<"LeaderboardEntry"> | Decimal | DecimalJsLike | number | string
    period?: StringFilter<"LeaderboardEntry"> | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenNullableRelationFilter, CryptoTokenWhereInput> | null
  }, "id" | "userId_metric_period_tokenId">

  export type LeaderboardEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaderboardEntryCountOrderByAggregateInput
    _avg?: LeaderboardEntryAvgOrderByAggregateInput
    _max?: LeaderboardEntryMaxOrderByAggregateInput
    _min?: LeaderboardEntryMinOrderByAggregateInput
    _sum?: LeaderboardEntrySumOrderByAggregateInput
  }

  export type LeaderboardEntryScalarWhereWithAggregatesInput = {
    AND?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    OR?: LeaderboardEntryScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    userId?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    tokenId?: IntNullableWithAggregatesFilter<"LeaderboardEntry"> | number | null
    metric?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    score?: DecimalWithAggregatesFilter<"LeaderboardEntry"> | Decimal | DecimalJsLike | number | string
    period?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaderboardEntry"> | Date | string
  }

  export type ReferralTransactionWhereInput = {
    AND?: ReferralTransactionWhereInput | ReferralTransactionWhereInput[]
    OR?: ReferralTransactionWhereInput[]
    NOT?: ReferralTransactionWhereInput | ReferralTransactionWhereInput[]
    id?: IntFilter<"ReferralTransaction"> | number
    referrerId?: IntFilter<"ReferralTransaction"> | number
    refereeId?: IntFilter<"ReferralTransaction"> | number
    tokenId?: IntFilter<"ReferralTransaction"> | number
    eventType?: EnumReferralEventTypeFilter<"ReferralTransaction"> | $Enums.ReferralEventType
    amount?: DecimalFilter<"ReferralTransaction"> | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFilter<"ReferralTransaction"> | number
    sourceEntityType?: StringFilter<"ReferralTransaction"> | string
    createdAt?: DateTimeFilter<"ReferralTransaction"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referee?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type ReferralTransactionOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referee?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type ReferralTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferralTransactionWhereInput | ReferralTransactionWhereInput[]
    OR?: ReferralTransactionWhereInput[]
    NOT?: ReferralTransactionWhereInput | ReferralTransactionWhereInput[]
    referrerId?: IntFilter<"ReferralTransaction"> | number
    refereeId?: IntFilter<"ReferralTransaction"> | number
    tokenId?: IntFilter<"ReferralTransaction"> | number
    eventType?: EnumReferralEventTypeFilter<"ReferralTransaction"> | $Enums.ReferralEventType
    amount?: DecimalFilter<"ReferralTransaction"> | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFilter<"ReferralTransaction"> | number
    sourceEntityType?: StringFilter<"ReferralTransaction"> | string
    createdAt?: DateTimeFilter<"ReferralTransaction"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referee?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id">

  export type ReferralTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
    _count?: ReferralTransactionCountOrderByAggregateInput
    _avg?: ReferralTransactionAvgOrderByAggregateInput
    _max?: ReferralTransactionMaxOrderByAggregateInput
    _min?: ReferralTransactionMinOrderByAggregateInput
    _sum?: ReferralTransactionSumOrderByAggregateInput
  }

  export type ReferralTransactionScalarWhereWithAggregatesInput = {
    AND?: ReferralTransactionScalarWhereWithAggregatesInput | ReferralTransactionScalarWhereWithAggregatesInput[]
    OR?: ReferralTransactionScalarWhereWithAggregatesInput[]
    NOT?: ReferralTransactionScalarWhereWithAggregatesInput | ReferralTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    referrerId?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    refereeId?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    tokenId?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    eventType?: EnumReferralEventTypeWithAggregatesFilter<"ReferralTransaction"> | $Enums.ReferralEventType
    amount?: DecimalWithAggregatesFilter<"ReferralTransaction"> | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    sourceEntityType?: StringWithAggregatesFilter<"ReferralTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReferralTransaction"> | Date | string
  }

  export type OneTimeTokenWhereInput = {
    AND?: OneTimeTokenWhereInput | OneTimeTokenWhereInput[]
    OR?: OneTimeTokenWhereInput[]
    NOT?: OneTimeTokenWhereInput | OneTimeTokenWhereInput[]
    id?: IntFilter<"OneTimeToken"> | number
    token?: StringFilter<"OneTimeToken"> | string
    userId?: IntFilter<"OneTimeToken"> | number
    createdAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    expiresAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    used?: BoolFilter<"OneTimeToken"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OneTimeTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OneTimeTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: OneTimeTokenWhereInput | OneTimeTokenWhereInput[]
    OR?: OneTimeTokenWhereInput[]
    NOT?: OneTimeTokenWhereInput | OneTimeTokenWhereInput[]
    userId?: IntFilter<"OneTimeToken"> | number
    createdAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    expiresAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    used?: BoolFilter<"OneTimeToken"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type OneTimeTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    _count?: OneTimeTokenCountOrderByAggregateInput
    _avg?: OneTimeTokenAvgOrderByAggregateInput
    _max?: OneTimeTokenMaxOrderByAggregateInput
    _min?: OneTimeTokenMinOrderByAggregateInput
    _sum?: OneTimeTokenSumOrderByAggregateInput
  }

  export type OneTimeTokenScalarWhereWithAggregatesInput = {
    AND?: OneTimeTokenScalarWhereWithAggregatesInput | OneTimeTokenScalarWhereWithAggregatesInput[]
    OR?: OneTimeTokenScalarWhereWithAggregatesInput[]
    NOT?: OneTimeTokenScalarWhereWithAggregatesInput | OneTimeTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OneTimeToken"> | number
    token?: StringWithAggregatesFilter<"OneTimeToken"> | string
    userId?: IntWithAggregatesFilter<"OneTimeToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OneTimeToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"OneTimeToken"> | Date | string
    used?: BoolWithAggregatesFilter<"OneTimeToken"> | boolean
  }

  export type CryptoTokenCreateInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenCreateManyInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
  }

  export type CryptoTokenUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
  }

  export type UserUpdateManyMutationInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BalanceCreateInput = {
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBalancesInput
    token: CryptoTokenCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceUpdateInput = {
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBalancesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceCreateManyInput = {
    id?: number
    userId: number
    tokenId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceUpdateManyMutationInput = {
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    token: CryptoTokenCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: number
    userId: number
    tokenId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetCreateInput = {
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBetsInput
    token: CryptoTokenCreateNestedOneWithoutBetsInput
  }

  export type BetUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BetUpdateInput = {
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBetsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutBetsNestedInput
  }

  export type BetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetCreateManyInput = {
    id?: number
    userId: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BetUpdateManyMutationInput = {
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusCreateInput = {
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusCreateNestedManyWithoutBonusInput
  }

  export type BonusUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutBonusInput
  }

  export type BonusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusUpdateManyWithoutBonusNestedInput
  }

  export type BonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusUncheckedUpdateManyWithoutBonusNestedInput
  }

  export type BonusCreateManyInput = {
    id?: number
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
  }

  export type BonusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserBonusCreateInput = {
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutBonusesInput
    bonus: BonusCreateNestedOneWithoutUserBonusesInput
    token: CryptoTokenCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateInput = {
    id?: number
    userId: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusUpdateInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    bonus?: BonusUpdateOneRequiredWithoutUserBonusesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusCreateManyInput = {
    id?: number
    userId: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusUpdateManyMutationInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaderboardEntryCreateInput = {
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
    token?: CryptoTokenCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardEntryUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId?: number | null
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryUpdateInput = {
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
    token?: CryptoTokenUpdateOneWithoutLeaderboardNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: NullableIntFieldUpdateOperationsInput | number | null
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryCreateManyInput = {
    id?: number
    userId: number
    tokenId?: number | null
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryUpdateManyMutationInput = {
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: NullableIntFieldUpdateOperationsInput | number | null
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionCreateInput = {
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutCommissionsInput
    referee: UserCreateNestedOneWithoutReferralActionsInput
    token: CryptoTokenCreateNestedOneWithoutReferralCommissionsInput
  }

  export type ReferralTransactionUncheckedCreateInput = {
    id?: number
    referrerId: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionUpdateInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutCommissionsNestedInput
    referee?: UserUpdateOneRequiredWithoutReferralActionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutReferralCommissionsNestedInput
  }

  export type ReferralTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionCreateManyInput = {
    id?: number
    referrerId: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionUpdateManyMutationInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneTimeTokenCreateInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
    user: UserCreateNestedOneWithoutAuthTokensInput
  }

  export type OneTimeTokenUncheckedCreateInput = {
    id?: number
    token: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type OneTimeTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAuthTokensNestedInput
  }

  export type OneTimeTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OneTimeTokenCreateManyInput = {
    id?: number
    token: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type OneTimeTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OneTimeTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BalanceListRelationFilter = {
    every?: BalanceWhereInput
    some?: BalanceWhereInput
    none?: BalanceWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type BetListRelationFilter = {
    every?: BetWhereInput
    some?: BetWhereInput
    none?: BetWhereInput
  }

  export type LeaderboardEntryListRelationFilter = {
    every?: LeaderboardEntryWhereInput
    some?: LeaderboardEntryWhereInput
    none?: LeaderboardEntryWhereInput
  }

  export type UserBonusListRelationFilter = {
    every?: UserBonusWhereInput
    some?: UserBonusWhereInput
    none?: UserBonusWhereInput
  }

  export type ReferralTransactionListRelationFilter = {
    every?: ReferralTransactionWhereInput
    some?: ReferralTransactionWhereInput
    none?: ReferralTransactionWhereInput
  }

  export type BalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoTokenCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
  }

  export type CryptoTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    decimals?: SortOrder
  }

  export type CryptoTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
  }

  export type CryptoTokenMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
  }

  export type CryptoTokenSumOrderByAggregateInput = {
    id?: SortOrder
    decimals?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type OneTimeTokenListRelationFilter = {
    every?: OneTimeTokenWhereInput
    some?: OneTimeTokenWhereInput
    none?: OneTimeTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OneTimeTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photoUrl?: SortOrder
    passwordHash?: SortOrder
    salt?: SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    referredById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photoUrl?: SortOrder
    passwordHash?: SortOrder
    salt?: SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photoUrl?: SortOrder
    passwordHash?: SortOrder
    salt?: SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    referredById?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumBalanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeFilter<$PrismaModel> | $Enums.BalanceType
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CryptoTokenRelationFilter = {
    is?: CryptoTokenWhereInput
    isNot?: CryptoTokenWhereInput
  }

  export type BalanceUserIdTokenIdTypeCompoundUniqueInput = {
    userId: number
    tokenId: number
    type: $Enums.BalanceType
  }

  export type BalanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type BalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type EnumBalanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.BalanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBalanceTypeFilter<$PrismaModel>
    _max?: NestedEnumBalanceTypeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumGameTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameTypeFilter<$PrismaModel> | $Enums.GameType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type BetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
  }

  export type BetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    createdAt?: SortOrder
  }

  export type BetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    createdAt?: SortOrder
  }

  export type BetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
  }

  export type EnumGameTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameTypeFilter<$PrismaModel>
    _max?: NestedEnumGameTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BonusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type BonusAvgOrderByAggregateInput = {
    id?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type BonusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type BonusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type BonusSumOrderByAggregateInput = {
    id?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BonusRelationFilter = {
    is?: BonusWhereInput
    isNot?: BonusWhereInput
  }

  export type UserBonusUserIdBonusIdTokenIdCompoundUniqueInput = {
    userId: number
    bonusId: number
    tokenId: number
  }

  export type UserBonusCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserBonusAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
  }

  export type UserBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserBonusMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserBonusSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CryptoTokenNullableRelationFilter = {
    is?: CryptoTokenWhereInput | null
    isNot?: CryptoTokenWhereInput | null
  }

  export type LeaderboardEntryUserIdMetricPeriodTokenIdCompoundUniqueInput = {
    userId: number
    metric: string
    period: string
    tokenId: number
  }

  export type LeaderboardEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
  }

  export type LeaderboardEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntrySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
  }

  export type EnumReferralEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralEventType | EnumReferralEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralEventTypeFilter<$PrismaModel> | $Enums.ReferralEventType
  }

  export type ReferralTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
  }

  export type ReferralTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
  }

  export type EnumReferralEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralEventType | EnumReferralEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReferralEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferralEventTypeFilter<$PrismaModel>
    _max?: NestedEnumReferralEventTypeFilter<$PrismaModel>
  }

  export type OneTimeTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type OneTimeTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OneTimeTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type OneTimeTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type OneTimeTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BalanceCreateNestedManyWithoutTokenInput = {
    create?: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput> | BalanceCreateWithoutTokenInput[] | BalanceUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutTokenInput | BalanceCreateOrConnectWithoutTokenInput[]
    createMany?: BalanceCreateManyTokenInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutTokenInput = {
    create?: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput> | TransactionCreateWithoutTokenInput[] | TransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTokenInput | TransactionCreateOrConnectWithoutTokenInput[]
    createMany?: TransactionCreateManyTokenInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BetCreateNestedManyWithoutTokenInput = {
    create?: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput> | BetCreateWithoutTokenInput[] | BetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BetCreateOrConnectWithoutTokenInput | BetCreateOrConnectWithoutTokenInput[]
    createMany?: BetCreateManyTokenInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type LeaderboardEntryCreateNestedManyWithoutTokenInput = {
    create?: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput> | LeaderboardEntryCreateWithoutTokenInput[] | LeaderboardEntryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutTokenInput | LeaderboardEntryCreateOrConnectWithoutTokenInput[]
    createMany?: LeaderboardEntryCreateManyTokenInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type UserBonusCreateNestedManyWithoutTokenInput = {
    create?: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput> | UserBonusCreateWithoutTokenInput[] | UserBonusUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutTokenInput | UserBonusCreateOrConnectWithoutTokenInput[]
    createMany?: UserBonusCreateManyTokenInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type ReferralTransactionCreateNestedManyWithoutTokenInput = {
    create?: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput> | ReferralTransactionCreateWithoutTokenInput[] | ReferralTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutTokenInput | ReferralTransactionCreateOrConnectWithoutTokenInput[]
    createMany?: ReferralTransactionCreateManyTokenInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type BalanceUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput> | BalanceCreateWithoutTokenInput[] | BalanceUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutTokenInput | BalanceCreateOrConnectWithoutTokenInput[]
    createMany?: BalanceCreateManyTokenInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput> | TransactionCreateWithoutTokenInput[] | TransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTokenInput | TransactionCreateOrConnectWithoutTokenInput[]
    createMany?: TransactionCreateManyTokenInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BetUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput> | BetCreateWithoutTokenInput[] | BetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BetCreateOrConnectWithoutTokenInput | BetCreateOrConnectWithoutTokenInput[]
    createMany?: BetCreateManyTokenInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput> | LeaderboardEntryCreateWithoutTokenInput[] | LeaderboardEntryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutTokenInput | LeaderboardEntryCreateOrConnectWithoutTokenInput[]
    createMany?: LeaderboardEntryCreateManyTokenInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type UserBonusUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput> | UserBonusCreateWithoutTokenInput[] | UserBonusUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutTokenInput | UserBonusCreateOrConnectWithoutTokenInput[]
    createMany?: UserBonusCreateManyTokenInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput> | ReferralTransactionCreateWithoutTokenInput[] | ReferralTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutTokenInput | ReferralTransactionCreateOrConnectWithoutTokenInput[]
    createMany?: ReferralTransactionCreateManyTokenInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BalanceUpdateManyWithoutTokenNestedInput = {
    create?: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput> | BalanceCreateWithoutTokenInput[] | BalanceUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutTokenInput | BalanceCreateOrConnectWithoutTokenInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutTokenInput | BalanceUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: BalanceCreateManyTokenInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutTokenInput | BalanceUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutTokenInput | BalanceUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput> | TransactionCreateWithoutTokenInput[] | TransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTokenInput | TransactionCreateOrConnectWithoutTokenInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTokenInput | TransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TransactionCreateManyTokenInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTokenInput | TransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTokenInput | TransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BetUpdateManyWithoutTokenNestedInput = {
    create?: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput> | BetCreateWithoutTokenInput[] | BetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BetCreateOrConnectWithoutTokenInput | BetCreateOrConnectWithoutTokenInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutTokenInput | BetUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: BetCreateManyTokenInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutTokenInput | BetUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: BetUpdateManyWithWhereWithoutTokenInput | BetUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type LeaderboardEntryUpdateManyWithoutTokenNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput> | LeaderboardEntryCreateWithoutTokenInput[] | LeaderboardEntryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutTokenInput | LeaderboardEntryCreateOrConnectWithoutTokenInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput | LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: LeaderboardEntryCreateManyTokenInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput | LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutTokenInput | LeaderboardEntryUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type UserBonusUpdateManyWithoutTokenNestedInput = {
    create?: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput> | UserBonusCreateWithoutTokenInput[] | UserBonusUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutTokenInput | UserBonusCreateOrConnectWithoutTokenInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutTokenInput | UserBonusUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: UserBonusCreateManyTokenInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutTokenInput | UserBonusUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutTokenInput | UserBonusUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type ReferralTransactionUpdateManyWithoutTokenNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput> | ReferralTransactionCreateWithoutTokenInput[] | ReferralTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutTokenInput | ReferralTransactionCreateOrConnectWithoutTokenInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput | ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: ReferralTransactionCreateManyTokenInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput | ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutTokenInput | ReferralTransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type BalanceUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput> | BalanceCreateWithoutTokenInput[] | BalanceUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutTokenInput | BalanceCreateOrConnectWithoutTokenInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutTokenInput | BalanceUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: BalanceCreateManyTokenInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutTokenInput | BalanceUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutTokenInput | BalanceUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput> | TransactionCreateWithoutTokenInput[] | TransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTokenInput | TransactionCreateOrConnectWithoutTokenInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTokenInput | TransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TransactionCreateManyTokenInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTokenInput | TransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTokenInput | TransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BetUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput> | BetCreateWithoutTokenInput[] | BetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BetCreateOrConnectWithoutTokenInput | BetCreateOrConnectWithoutTokenInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutTokenInput | BetUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: BetCreateManyTokenInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutTokenInput | BetUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: BetUpdateManyWithWhereWithoutTokenInput | BetUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput> | LeaderboardEntryCreateWithoutTokenInput[] | LeaderboardEntryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutTokenInput | LeaderboardEntryCreateOrConnectWithoutTokenInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput | LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: LeaderboardEntryCreateManyTokenInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput | LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutTokenInput | LeaderboardEntryUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type UserBonusUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput> | UserBonusCreateWithoutTokenInput[] | UserBonusUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutTokenInput | UserBonusCreateOrConnectWithoutTokenInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutTokenInput | UserBonusUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: UserBonusCreateManyTokenInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutTokenInput | UserBonusUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutTokenInput | UserBonusUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput> | ReferralTransactionCreateWithoutTokenInput[] | ReferralTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutTokenInput | ReferralTransactionCreateOrConnectWithoutTokenInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput | ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: ReferralTransactionCreateManyTokenInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput | ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutTokenInput | ReferralTransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReferrerInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BalanceCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BetCreateNestedManyWithoutUserInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type LeaderboardEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type UserBonusCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type ReferralTransactionCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput> | ReferralTransactionCreateWithoutReferrerInput[] | ReferralTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutReferrerInput | ReferralTransactionCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralTransactionCreateManyReferrerInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type ReferralTransactionCreateNestedManyWithoutRefereeInput = {
    create?: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput> | ReferralTransactionCreateWithoutRefereeInput[] | ReferralTransactionUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutRefereeInput | ReferralTransactionCreateOrConnectWithoutRefereeInput[]
    createMany?: ReferralTransactionCreateManyRefereeInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type OneTimeTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput> | OneTimeTokenCreateWithoutUserInput[] | OneTimeTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneTimeTokenCreateOrConnectWithoutUserInput | OneTimeTokenCreateOrConnectWithoutUserInput[]
    createMany?: OneTimeTokenCreateManyUserInputEnvelope
    connect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BalanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type UserBonusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput> | ReferralTransactionCreateWithoutReferrerInput[] | ReferralTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutReferrerInput | ReferralTransactionCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralTransactionCreateManyReferrerInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput = {
    create?: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput> | ReferralTransactionCreateWithoutRefereeInput[] | ReferralTransactionUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutRefereeInput | ReferralTransactionCreateOrConnectWithoutRefereeInput[]
    createMany?: ReferralTransactionCreateManyRefereeInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type OneTimeTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput> | OneTimeTokenCreateWithoutUserInput[] | OneTimeTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneTimeTokenCreateOrConnectWithoutUserInput | OneTimeTokenCreateOrConnectWithoutUserInput[]
    createMany?: OneTimeTokenCreateManyUserInputEnvelope
    connect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferrerInput | UserUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferrerInput | UserUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferrerInput | UserUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BalanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutUserInput | BalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutUserInput | BalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutUserInput | BalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BetUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutUserInput | BetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutUserInput | BetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetUpdateManyWithWhereWithoutUserInput | BetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type LeaderboardEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type UserBonusUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutUserInput | UserBonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutUserInput | UserBonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutUserInput | UserBonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type ReferralTransactionUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput> | ReferralTransactionCreateWithoutReferrerInput[] | ReferralTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutReferrerInput | ReferralTransactionCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput | ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralTransactionCreateManyReferrerInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput | ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutReferrerInput | ReferralTransactionUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type ReferralTransactionUpdateManyWithoutRefereeNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput> | ReferralTransactionCreateWithoutRefereeInput[] | ReferralTransactionUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutRefereeInput | ReferralTransactionCreateOrConnectWithoutRefereeInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput | ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput[]
    createMany?: ReferralTransactionCreateManyRefereeInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput | ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutRefereeInput | ReferralTransactionUpdateManyWithWhereWithoutRefereeInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type OneTimeTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput> | OneTimeTokenCreateWithoutUserInput[] | OneTimeTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneTimeTokenCreateOrConnectWithoutUserInput | OneTimeTokenCreateOrConnectWithoutUserInput[]
    upsert?: OneTimeTokenUpsertWithWhereUniqueWithoutUserInput | OneTimeTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OneTimeTokenCreateManyUserInputEnvelope
    set?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    disconnect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    delete?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    connect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    update?: OneTimeTokenUpdateWithWhereUniqueWithoutUserInput | OneTimeTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OneTimeTokenUpdateManyWithWhereWithoutUserInput | OneTimeTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OneTimeTokenScalarWhereInput | OneTimeTokenScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferrerInput | UserUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferrerInput | UserUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferrerInput | UserUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BalanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutUserInput | BalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutUserInput | BalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutUserInput | BalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutUserInput | BetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutUserInput | BetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetUpdateManyWithWhereWithoutUserInput | BetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type UserBonusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutUserInput | UserBonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutUserInput | UserBonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutUserInput | UserBonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput> | ReferralTransactionCreateWithoutReferrerInput[] | ReferralTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutReferrerInput | ReferralTransactionCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput | ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralTransactionCreateManyReferrerInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput | ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutReferrerInput | ReferralTransactionUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput> | ReferralTransactionCreateWithoutRefereeInput[] | ReferralTransactionUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutRefereeInput | ReferralTransactionCreateOrConnectWithoutRefereeInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput | ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput[]
    createMany?: ReferralTransactionCreateManyRefereeInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput | ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutRefereeInput | ReferralTransactionUpdateManyWithWhereWithoutRefereeInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput> | OneTimeTokenCreateWithoutUserInput[] | OneTimeTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneTimeTokenCreateOrConnectWithoutUserInput | OneTimeTokenCreateOrConnectWithoutUserInput[]
    upsert?: OneTimeTokenUpsertWithWhereUniqueWithoutUserInput | OneTimeTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OneTimeTokenCreateManyUserInputEnvelope
    set?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    disconnect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    delete?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    connect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    update?: OneTimeTokenUpdateWithWhereUniqueWithoutUserInput | OneTimeTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OneTimeTokenUpdateManyWithWhereWithoutUserInput | OneTimeTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OneTimeTokenScalarWhereInput | OneTimeTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBalancesInput = {
    create?: XOR<UserCreateWithoutBalancesInput, UserUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalancesInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutBalancesInput = {
    create?: XOR<CryptoTokenCreateWithoutBalancesInput, CryptoTokenUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutBalancesInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type EnumBalanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.BalanceType
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<UserCreateWithoutBalancesInput, UserUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalancesInput
    upsert?: UserUpsertWithoutBalancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBalancesInput, UserUpdateWithoutBalancesInput>, UserUncheckedUpdateWithoutBalancesInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutBalancesInput, CryptoTokenUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutBalancesInput
    upsert?: CryptoTokenUpsertWithoutBalancesInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutBalancesInput, CryptoTokenUpdateWithoutBalancesInput>, CryptoTokenUncheckedUpdateWithoutBalancesInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CryptoTokenCreateWithoutTransactionsInput, CryptoTokenUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutTransactionsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutTransactionsInput, CryptoTokenUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutTransactionsInput
    upsert?: CryptoTokenUpsertWithoutTransactionsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutTransactionsInput, CryptoTokenUpdateWithoutTransactionsInput>, CryptoTokenUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutBetsInput = {
    create?: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBetsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutBetsInput = {
    create?: XOR<CryptoTokenCreateWithoutBetsInput, CryptoTokenUncheckedCreateWithoutBetsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutBetsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type EnumGameTypeFieldUpdateOperationsInput = {
    set?: $Enums.GameType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBetsNestedInput = {
    create?: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBetsInput
    upsert?: UserUpsertWithoutBetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBetsInput, UserUpdateWithoutBetsInput>, UserUncheckedUpdateWithoutBetsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutBetsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutBetsInput, CryptoTokenUncheckedCreateWithoutBetsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutBetsInput
    upsert?: CryptoTokenUpsertWithoutBetsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutBetsInput, CryptoTokenUpdateWithoutBetsInput>, CryptoTokenUncheckedUpdateWithoutBetsInput>
  }

  export type UserBonusCreateNestedManyWithoutBonusInput = {
    create?: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput> | UserBonusCreateWithoutBonusInput[] | UserBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutBonusInput | UserBonusCreateOrConnectWithoutBonusInput[]
    createMany?: UserBonusCreateManyBonusInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type UserBonusUncheckedCreateNestedManyWithoutBonusInput = {
    create?: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput> | UserBonusCreateWithoutBonusInput[] | UserBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutBonusInput | UserBonusCreateOrConnectWithoutBonusInput[]
    createMany?: UserBonusCreateManyBonusInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type UserBonusUpdateManyWithoutBonusNestedInput = {
    create?: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput> | UserBonusCreateWithoutBonusInput[] | UserBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutBonusInput | UserBonusCreateOrConnectWithoutBonusInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutBonusInput | UserBonusUpsertWithWhereUniqueWithoutBonusInput[]
    createMany?: UserBonusCreateManyBonusInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutBonusInput | UserBonusUpdateWithWhereUniqueWithoutBonusInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutBonusInput | UserBonusUpdateManyWithWhereWithoutBonusInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type UserBonusUncheckedUpdateManyWithoutBonusNestedInput = {
    create?: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput> | UserBonusCreateWithoutBonusInput[] | UserBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutBonusInput | UserBonusCreateOrConnectWithoutBonusInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutBonusInput | UserBonusUpsertWithWhereUniqueWithoutBonusInput[]
    createMany?: UserBonusCreateManyBonusInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutBonusInput | UserBonusUpdateWithWhereUniqueWithoutBonusInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutBonusInput | UserBonusUpdateManyWithWhereWithoutBonusInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBonusesInput = {
    create?: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusesInput
    connect?: UserWhereUniqueInput
  }

  export type BonusCreateNestedOneWithoutUserBonusesInput = {
    create?: XOR<BonusCreateWithoutUserBonusesInput, BonusUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: BonusCreateOrConnectWithoutUserBonusesInput
    connect?: BonusWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutUserBonusesInput = {
    create?: XOR<CryptoTokenCreateWithoutUserBonusesInput, CryptoTokenUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutUserBonusesInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutBonusesNestedInput = {
    create?: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusesInput
    upsert?: UserUpsertWithoutBonusesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBonusesInput, UserUpdateWithoutBonusesInput>, UserUncheckedUpdateWithoutBonusesInput>
  }

  export type BonusUpdateOneRequiredWithoutUserBonusesNestedInput = {
    create?: XOR<BonusCreateWithoutUserBonusesInput, BonusUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: BonusCreateOrConnectWithoutUserBonusesInput
    upsert?: BonusUpsertWithoutUserBonusesInput
    connect?: BonusWhereUniqueInput
    update?: XOR<XOR<BonusUpdateToOneWithWhereWithoutUserBonusesInput, BonusUpdateWithoutUserBonusesInput>, BonusUncheckedUpdateWithoutUserBonusesInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutUserBonusesNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutUserBonusesInput, CryptoTokenUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutUserBonusesInput
    upsert?: CryptoTokenUpsertWithoutUserBonusesInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutUserBonusesInput, CryptoTokenUpdateWithoutUserBonusesInput>, CryptoTokenUncheckedUpdateWithoutUserBonusesInput>
  }

  export type UserCreateNestedOneWithoutLeaderboardEntriesInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutLeaderboardInput = {
    create?: XOR<CryptoTokenCreateWithoutLeaderboardInput, CryptoTokenUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutLeaderboardInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    upsert?: UserUpsertWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput, UserUpdateWithoutLeaderboardEntriesInput>, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type CryptoTokenUpdateOneWithoutLeaderboardNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutLeaderboardInput, CryptoTokenUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutLeaderboardInput
    upsert?: CryptoTokenUpsertWithoutLeaderboardInput
    disconnect?: CryptoTokenWhereInput | boolean
    delete?: CryptoTokenWhereInput | boolean
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutLeaderboardInput, CryptoTokenUpdateWithoutLeaderboardInput>, CryptoTokenUncheckedUpdateWithoutLeaderboardInput>
  }

  export type UserCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommissionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralActionsInput = {
    create?: XOR<UserCreateWithoutReferralActionsInput, UserUncheckedCreateWithoutReferralActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralActionsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutReferralCommissionsInput = {
    create?: XOR<CryptoTokenCreateWithoutReferralCommissionsInput, CryptoTokenUncheckedCreateWithoutReferralCommissionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutReferralCommissionsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type EnumReferralEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReferralEventType
  }

  export type UserUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommissionsInput
    upsert?: UserUpsertWithoutCommissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommissionsInput, UserUpdateWithoutCommissionsInput>, UserUncheckedUpdateWithoutCommissionsInput>
  }

  export type UserUpdateOneRequiredWithoutReferralActionsNestedInput = {
    create?: XOR<UserCreateWithoutReferralActionsInput, UserUncheckedCreateWithoutReferralActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralActionsInput
    upsert?: UserUpsertWithoutReferralActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralActionsInput, UserUpdateWithoutReferralActionsInput>, UserUncheckedUpdateWithoutReferralActionsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutReferralCommissionsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutReferralCommissionsInput, CryptoTokenUncheckedCreateWithoutReferralCommissionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutReferralCommissionsInput
    upsert?: CryptoTokenUpsertWithoutReferralCommissionsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutReferralCommissionsInput, CryptoTokenUpdateWithoutReferralCommissionsInput>, CryptoTokenUncheckedUpdateWithoutReferralCommissionsInput>
  }

  export type UserCreateNestedOneWithoutAuthTokensInput = {
    create?: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthTokensNestedInput = {
    create?: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthTokensInput
    upsert?: UserUpsertWithoutAuthTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthTokensInput, UserUpdateWithoutAuthTokensInput>, UserUncheckedUpdateWithoutAuthTokensInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBalanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeFilter<$PrismaModel> | $Enums.BalanceType
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.BalanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBalanceTypeFilter<$PrismaModel>
    _max?: NestedEnumBalanceTypeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumGameTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameTypeFilter<$PrismaModel> | $Enums.GameType
  }

  export type NestedEnumGameTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameTypeFilter<$PrismaModel>
    _max?: NestedEnumGameTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReferralEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralEventType | EnumReferralEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralEventTypeFilter<$PrismaModel> | $Enums.ReferralEventType
  }

  export type NestedEnumReferralEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralEventType | EnumReferralEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReferralEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferralEventTypeFilter<$PrismaModel>
    _max?: NestedEnumReferralEventTypeFilter<$PrismaModel>
  }

  export type BalanceCreateWithoutTokenInput = {
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceCreateOrConnectWithoutTokenInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput>
  }

  export type BalanceCreateManyTokenInputEnvelope = {
    data: BalanceCreateManyTokenInput | BalanceCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutTokenInput = {
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutTokenInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput>
  }

  export type TransactionCreateManyTokenInputEnvelope = {
    data: TransactionCreateManyTokenInput | TransactionCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type BetCreateWithoutTokenInput = {
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBetsInput
  }

  export type BetUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BetCreateOrConnectWithoutTokenInput = {
    where: BetWhereUniqueInput
    create: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput>
  }

  export type BetCreateManyTokenInputEnvelope = {
    data: BetCreateManyTokenInput | BetCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardEntryCreateWithoutTokenInput = {
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type LeaderboardEntryUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryCreateOrConnectWithoutTokenInput = {
    where: LeaderboardEntryWhereUniqueInput
    create: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput>
  }

  export type LeaderboardEntryCreateManyTokenInputEnvelope = {
    data: LeaderboardEntryCreateManyTokenInput | LeaderboardEntryCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type UserBonusCreateWithoutTokenInput = {
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutBonusesInput
    bonus: BonusCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    bonusId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusCreateOrConnectWithoutTokenInput = {
    where: UserBonusWhereUniqueInput
    create: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput>
  }

  export type UserBonusCreateManyTokenInputEnvelope = {
    data: UserBonusCreateManyTokenInput | UserBonusCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type ReferralTransactionCreateWithoutTokenInput = {
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutCommissionsInput
    referee: UserCreateNestedOneWithoutReferralActionsInput
  }

  export type ReferralTransactionUncheckedCreateWithoutTokenInput = {
    id?: number
    referrerId: number
    refereeId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionCreateOrConnectWithoutTokenInput = {
    where: ReferralTransactionWhereUniqueInput
    create: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput>
  }

  export type ReferralTransactionCreateManyTokenInputEnvelope = {
    data: ReferralTransactionCreateManyTokenInput | ReferralTransactionCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type BalanceUpsertWithWhereUniqueWithoutTokenInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutTokenInput, BalanceUncheckedUpdateWithoutTokenInput>
    create: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutTokenInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutTokenInput, BalanceUncheckedUpdateWithoutTokenInput>
  }

  export type BalanceUpdateManyWithWhereWithoutTokenInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutTokenInput>
  }

  export type BalanceScalarWhereInput = {
    AND?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    OR?: BalanceScalarWhereInput[]
    NOT?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    id?: IntFilter<"Balance"> | number
    userId?: IntFilter<"Balance"> | number
    tokenId?: IntFilter<"Balance"> | number
    type?: EnumBalanceTypeFilter<"Balance"> | $Enums.BalanceType
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Balance"> | Date | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutTokenInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTokenInput, TransactionUncheckedUpdateWithoutTokenInput>
    create: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTokenInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTokenInput, TransactionUncheckedUpdateWithoutTokenInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTokenInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTokenInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    userId?: IntFilter<"Transaction"> | number
    tokenId?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"Transaction"> | string | null
    walletAddress?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type BetUpsertWithWhereUniqueWithoutTokenInput = {
    where: BetWhereUniqueInput
    update: XOR<BetUpdateWithoutTokenInput, BetUncheckedUpdateWithoutTokenInput>
    create: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput>
  }

  export type BetUpdateWithWhereUniqueWithoutTokenInput = {
    where: BetWhereUniqueInput
    data: XOR<BetUpdateWithoutTokenInput, BetUncheckedUpdateWithoutTokenInput>
  }

  export type BetUpdateManyWithWhereWithoutTokenInput = {
    where: BetScalarWhereInput
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyWithoutTokenInput>
  }

  export type BetScalarWhereInput = {
    AND?: BetScalarWhereInput | BetScalarWhereInput[]
    OR?: BetScalarWhereInput[]
    NOT?: BetScalarWhereInput | BetScalarWhereInput[]
    id?: IntFilter<"Bet"> | number
    userId?: IntFilter<"Bet"> | number
    tokenId?: IntFilter<"Bet"> | number
    gameType?: EnumGameTypeFilter<"Bet"> | $Enums.GameType
    betAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFilter<"Bet"> | number
    roundId?: StringFilter<"Bet"> | string
    details?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
  }

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput = {
    where: LeaderboardEntryWhereUniqueInput
    update: XOR<LeaderboardEntryUpdateWithoutTokenInput, LeaderboardEntryUncheckedUpdateWithoutTokenInput>
    create: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput>
  }

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput = {
    where: LeaderboardEntryWhereUniqueInput
    data: XOR<LeaderboardEntryUpdateWithoutTokenInput, LeaderboardEntryUncheckedUpdateWithoutTokenInput>
  }

  export type LeaderboardEntryUpdateManyWithWhereWithoutTokenInput = {
    where: LeaderboardEntryScalarWhereInput
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyWithoutTokenInput>
  }

  export type LeaderboardEntryScalarWhereInput = {
    AND?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    OR?: LeaderboardEntryScalarWhereInput[]
    NOT?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    id?: IntFilter<"LeaderboardEntry"> | number
    userId?: IntFilter<"LeaderboardEntry"> | number
    tokenId?: IntNullableFilter<"LeaderboardEntry"> | number | null
    metric?: StringFilter<"LeaderboardEntry"> | string
    score?: DecimalFilter<"LeaderboardEntry"> | Decimal | DecimalJsLike | number | string
    period?: StringFilter<"LeaderboardEntry"> | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
  }

  export type UserBonusUpsertWithWhereUniqueWithoutTokenInput = {
    where: UserBonusWhereUniqueInput
    update: XOR<UserBonusUpdateWithoutTokenInput, UserBonusUncheckedUpdateWithoutTokenInput>
    create: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput>
  }

  export type UserBonusUpdateWithWhereUniqueWithoutTokenInput = {
    where: UserBonusWhereUniqueInput
    data: XOR<UserBonusUpdateWithoutTokenInput, UserBonusUncheckedUpdateWithoutTokenInput>
  }

  export type UserBonusUpdateManyWithWhereWithoutTokenInput = {
    where: UserBonusScalarWhereInput
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyWithoutTokenInput>
  }

  export type UserBonusScalarWhereInput = {
    AND?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
    OR?: UserBonusScalarWhereInput[]
    NOT?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
    id?: IntFilter<"UserBonus"> | number
    userId?: IntFilter<"UserBonus"> | number
    bonusId?: IntFilter<"UserBonus"> | number
    tokenId?: IntFilter<"UserBonus"> | number
    grantedAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"UserBonus"> | boolean
    isCompleted?: BoolFilter<"UserBonus"> | boolean
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
  }

  export type ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput = {
    where: ReferralTransactionWhereUniqueInput
    update: XOR<ReferralTransactionUpdateWithoutTokenInput, ReferralTransactionUncheckedUpdateWithoutTokenInput>
    create: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput>
  }

  export type ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput = {
    where: ReferralTransactionWhereUniqueInput
    data: XOR<ReferralTransactionUpdateWithoutTokenInput, ReferralTransactionUncheckedUpdateWithoutTokenInput>
  }

  export type ReferralTransactionUpdateManyWithWhereWithoutTokenInput = {
    where: ReferralTransactionScalarWhereInput
    data: XOR<ReferralTransactionUpdateManyMutationInput, ReferralTransactionUncheckedUpdateManyWithoutTokenInput>
  }

  export type ReferralTransactionScalarWhereInput = {
    AND?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
    OR?: ReferralTransactionScalarWhereInput[]
    NOT?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
    id?: IntFilter<"ReferralTransaction"> | number
    referrerId?: IntFilter<"ReferralTransaction"> | number
    refereeId?: IntFilter<"ReferralTransaction"> | number
    tokenId?: IntFilter<"ReferralTransaction"> | number
    eventType?: EnumReferralEventTypeFilter<"ReferralTransaction"> | $Enums.ReferralEventType
    amount?: DecimalFilter<"ReferralTransaction"> | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFilter<"ReferralTransaction"> | number
    sourceEntityType?: StringFilter<"ReferralTransaction"> | string
    createdAt?: DateTimeFilter<"ReferralTransaction"> | Date | string
  }

  export type UserCreateWithoutReferralsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferrerInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferrerInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferrerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput>
  }

  export type UserCreateManyReferrerInputEnvelope = {
    data: UserCreateManyReferrerInput | UserCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type BalanceCreateWithoutUserInput = {
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: CryptoTokenCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceCreateOrConnectWithoutUserInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput>
  }

  export type BalanceCreateManyUserInputEnvelope = {
    data: BalanceCreateManyUserInput | BalanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    token: CryptoTokenCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BetCreateWithoutUserInput = {
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    token: CryptoTokenCreateNestedOneWithoutBetsInput
  }

  export type BetUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BetCreateOrConnectWithoutUserInput = {
    where: BetWhereUniqueInput
    create: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput>
  }

  export type BetCreateManyUserInputEnvelope = {
    data: BetCreateManyUserInput | BetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardEntryCreateWithoutUserInput = {
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
    token?: CryptoTokenCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardEntryUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId?: number | null
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryCreateOrConnectWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryCreateManyUserInputEnvelope = {
    data: LeaderboardEntryCreateManyUserInput | LeaderboardEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBonusCreateWithoutUserInput = {
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    bonus: BonusCreateNestedOneWithoutUserBonusesInput
    token: CryptoTokenCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateWithoutUserInput = {
    id?: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusCreateOrConnectWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    create: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput>
  }

  export type UserBonusCreateManyUserInputEnvelope = {
    data: UserBonusCreateManyUserInput | UserBonusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralTransactionCreateWithoutReferrerInput = {
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
    referee: UserCreateNestedOneWithoutReferralActionsInput
    token: CryptoTokenCreateNestedOneWithoutReferralCommissionsInput
  }

  export type ReferralTransactionUncheckedCreateWithoutReferrerInput = {
    id?: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionCreateOrConnectWithoutReferrerInput = {
    where: ReferralTransactionWhereUniqueInput
    create: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralTransactionCreateManyReferrerInputEnvelope = {
    data: ReferralTransactionCreateManyReferrerInput | ReferralTransactionCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralTransactionCreateWithoutRefereeInput = {
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutCommissionsInput
    token: CryptoTokenCreateNestedOneWithoutReferralCommissionsInput
  }

  export type ReferralTransactionUncheckedCreateWithoutRefereeInput = {
    id?: number
    referrerId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionCreateOrConnectWithoutRefereeInput = {
    where: ReferralTransactionWhereUniqueInput
    create: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralTransactionCreateManyRefereeInputEnvelope = {
    data: ReferralTransactionCreateManyRefereeInput | ReferralTransactionCreateManyRefereeInput[]
    skipDuplicates?: boolean
  }

  export type OneTimeTokenCreateWithoutUserInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type OneTimeTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type OneTimeTokenCreateOrConnectWithoutUserInput = {
    where: OneTimeTokenWhereUniqueInput
    create: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput>
  }

  export type OneTimeTokenCreateManyUserInputEnvelope = {
    data: OneTimeTokenCreateManyUserInput | OneTimeTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReferrerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferrerInput, UserUncheckedUpdateWithoutReferrerInput>
    create: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferrerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferrerInput, UserUncheckedUpdateWithoutReferrerInput>
  }

  export type UserUpdateManyWithWhereWithoutReferrerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferrerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    telegramId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referralCode?: StringFilter<"User"> | string
    referredById?: IntNullableFilter<"User"> | number | null
  }

  export type BalanceUpsertWithWhereUniqueWithoutUserInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutUserInput, BalanceUncheckedUpdateWithoutUserInput>
    create: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutUserInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutUserInput, BalanceUncheckedUpdateWithoutUserInput>
  }

  export type BalanceUpdateManyWithWhereWithoutUserInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type BetUpsertWithWhereUniqueWithoutUserInput = {
    where: BetWhereUniqueInput
    update: XOR<BetUpdateWithoutUserInput, BetUncheckedUpdateWithoutUserInput>
    create: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput>
  }

  export type BetUpdateWithWhereUniqueWithoutUserInput = {
    where: BetWhereUniqueInput
    data: XOR<BetUpdateWithoutUserInput, BetUncheckedUpdateWithoutUserInput>
  }

  export type BetUpdateManyWithWhereWithoutUserInput = {
    where: BetScalarWhereInput
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    update: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    data: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardEntryScalarWhereInput
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBonusUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    update: XOR<UserBonusUpdateWithoutUserInput, UserBonusUncheckedUpdateWithoutUserInput>
    create: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput>
  }

  export type UserBonusUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    data: XOR<UserBonusUpdateWithoutUserInput, UserBonusUncheckedUpdateWithoutUserInput>
  }

  export type UserBonusUpdateManyWithWhereWithoutUserInput = {
    where: UserBonusScalarWhereInput
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralTransactionWhereUniqueInput
    update: XOR<ReferralTransactionUpdateWithoutReferrerInput, ReferralTransactionUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralTransactionWhereUniqueInput
    data: XOR<ReferralTransactionUpdateWithoutReferrerInput, ReferralTransactionUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralTransactionUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralTransactionScalarWhereInput
    data: XOR<ReferralTransactionUpdateManyMutationInput, ReferralTransactionUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput = {
    where: ReferralTransactionWhereUniqueInput
    update: XOR<ReferralTransactionUpdateWithoutRefereeInput, ReferralTransactionUncheckedUpdateWithoutRefereeInput>
    create: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput = {
    where: ReferralTransactionWhereUniqueInput
    data: XOR<ReferralTransactionUpdateWithoutRefereeInput, ReferralTransactionUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralTransactionUpdateManyWithWhereWithoutRefereeInput = {
    where: ReferralTransactionScalarWhereInput
    data: XOR<ReferralTransactionUpdateManyMutationInput, ReferralTransactionUncheckedUpdateManyWithoutRefereeInput>
  }

  export type OneTimeTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: OneTimeTokenWhereUniqueInput
    update: XOR<OneTimeTokenUpdateWithoutUserInput, OneTimeTokenUncheckedUpdateWithoutUserInput>
    create: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput>
  }

  export type OneTimeTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: OneTimeTokenWhereUniqueInput
    data: XOR<OneTimeTokenUpdateWithoutUserInput, OneTimeTokenUncheckedUpdateWithoutUserInput>
  }

  export type OneTimeTokenUpdateManyWithWhereWithoutUserInput = {
    where: OneTimeTokenScalarWhereInput
    data: XOR<OneTimeTokenUpdateManyMutationInput, OneTimeTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type OneTimeTokenScalarWhereInput = {
    AND?: OneTimeTokenScalarWhereInput | OneTimeTokenScalarWhereInput[]
    OR?: OneTimeTokenScalarWhereInput[]
    NOT?: OneTimeTokenScalarWhereInput | OneTimeTokenScalarWhereInput[]
    id?: IntFilter<"OneTimeToken"> | number
    token?: StringFilter<"OneTimeToken"> | string
    userId?: IntFilter<"OneTimeToken"> | number
    createdAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    expiresAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    used?: BoolFilter<"OneTimeToken"> | boolean
  }

  export type UserCreateWithoutBalancesInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBalancesInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBalancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBalancesInput, UserUncheckedCreateWithoutBalancesInput>
  }

  export type CryptoTokenCreateWithoutBalancesInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutBalancesInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutBalancesInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutBalancesInput, CryptoTokenUncheckedCreateWithoutBalancesInput>
  }

  export type UserUpsertWithoutBalancesInput = {
    update: XOR<UserUpdateWithoutBalancesInput, UserUncheckedUpdateWithoutBalancesInput>
    create: XOR<UserCreateWithoutBalancesInput, UserUncheckedCreateWithoutBalancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBalancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBalancesInput, UserUncheckedUpdateWithoutBalancesInput>
  }

  export type UserUpdateWithoutBalancesInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBalancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutBalancesInput = {
    update: XOR<CryptoTokenUpdateWithoutBalancesInput, CryptoTokenUncheckedUpdateWithoutBalancesInput>
    create: XOR<CryptoTokenCreateWithoutBalancesInput, CryptoTokenUncheckedCreateWithoutBalancesInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutBalancesInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutBalancesInput, CryptoTokenUncheckedUpdateWithoutBalancesInput>
  }

  export type CryptoTokenUpdateWithoutBalancesInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutBalancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutTransactionsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type CryptoTokenCreateWithoutTransactionsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutTransactionsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutTransactionsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutTransactionsInput, CryptoTokenUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutTransactionsInput = {
    update: XOR<CryptoTokenUpdateWithoutTransactionsInput, CryptoTokenUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CryptoTokenCreateWithoutTransactionsInput, CryptoTokenUncheckedCreateWithoutTransactionsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutTransactionsInput, CryptoTokenUncheckedUpdateWithoutTransactionsInput>
  }

  export type CryptoTokenUpdateWithoutTransactionsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutBetsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBetsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
  }

  export type CryptoTokenCreateWithoutBetsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutBetsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutBetsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutBetsInput, CryptoTokenUncheckedCreateWithoutBetsInput>
  }

  export type UserUpsertWithoutBetsInput = {
    update: XOR<UserUpdateWithoutBetsInput, UserUncheckedUpdateWithoutBetsInput>
    create: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBetsInput, UserUncheckedUpdateWithoutBetsInput>
  }

  export type UserUpdateWithoutBetsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutBetsInput = {
    update: XOR<CryptoTokenUpdateWithoutBetsInput, CryptoTokenUncheckedUpdateWithoutBetsInput>
    create: XOR<CryptoTokenCreateWithoutBetsInput, CryptoTokenUncheckedCreateWithoutBetsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutBetsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutBetsInput, CryptoTokenUncheckedUpdateWithoutBetsInput>
  }

  export type CryptoTokenUpdateWithoutBetsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserBonusCreateWithoutBonusInput = {
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutBonusesInput
    token: CryptoTokenCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateWithoutBonusInput = {
    id?: number
    userId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusCreateOrConnectWithoutBonusInput = {
    where: UserBonusWhereUniqueInput
    create: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput>
  }

  export type UserBonusCreateManyBonusInputEnvelope = {
    data: UserBonusCreateManyBonusInput | UserBonusCreateManyBonusInput[]
    skipDuplicates?: boolean
  }

  export type UserBonusUpsertWithWhereUniqueWithoutBonusInput = {
    where: UserBonusWhereUniqueInput
    update: XOR<UserBonusUpdateWithoutBonusInput, UserBonusUncheckedUpdateWithoutBonusInput>
    create: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput>
  }

  export type UserBonusUpdateWithWhereUniqueWithoutBonusInput = {
    where: UserBonusWhereUniqueInput
    data: XOR<UserBonusUpdateWithoutBonusInput, UserBonusUncheckedUpdateWithoutBonusInput>
  }

  export type UserBonusUpdateManyWithWhereWithoutBonusInput = {
    where: UserBonusScalarWhereInput
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyWithoutBonusInput>
  }

  export type UserCreateWithoutBonusesInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBonusesInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBonusesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
  }

  export type BonusCreateWithoutUserBonusesInput = {
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
  }

  export type BonusUncheckedCreateWithoutUserBonusesInput = {
    id?: number
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
  }

  export type BonusCreateOrConnectWithoutUserBonusesInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutUserBonusesInput, BonusUncheckedCreateWithoutUserBonusesInput>
  }

  export type CryptoTokenCreateWithoutUserBonusesInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutUserBonusesInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutUserBonusesInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutUserBonusesInput, CryptoTokenUncheckedCreateWithoutUserBonusesInput>
  }

  export type UserUpsertWithoutBonusesInput = {
    update: XOR<UserUpdateWithoutBonusesInput, UserUncheckedUpdateWithoutBonusesInput>
    create: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBonusesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBonusesInput, UserUncheckedUpdateWithoutBonusesInput>
  }

  export type UserUpdateWithoutBonusesInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BonusUpsertWithoutUserBonusesInput = {
    update: XOR<BonusUpdateWithoutUserBonusesInput, BonusUncheckedUpdateWithoutUserBonusesInput>
    create: XOR<BonusCreateWithoutUserBonusesInput, BonusUncheckedCreateWithoutUserBonusesInput>
    where?: BonusWhereInput
  }

  export type BonusUpdateToOneWithWhereWithoutUserBonusesInput = {
    where?: BonusWhereInput
    data: XOR<BonusUpdateWithoutUserBonusesInput, BonusUncheckedUpdateWithoutUserBonusesInput>
  }

  export type BonusUpdateWithoutUserBonusesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BonusUncheckedUpdateWithoutUserBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CryptoTokenUpsertWithoutUserBonusesInput = {
    update: XOR<CryptoTokenUpdateWithoutUserBonusesInput, CryptoTokenUncheckedUpdateWithoutUserBonusesInput>
    create: XOR<CryptoTokenCreateWithoutUserBonusesInput, CryptoTokenUncheckedCreateWithoutUserBonusesInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutUserBonusesInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutUserBonusesInput, CryptoTokenUncheckedUpdateWithoutUserBonusesInput>
  }

  export type CryptoTokenUpdateWithoutUserBonusesInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutUserBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutLeaderboardEntriesInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaderboardEntriesInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaderboardEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
  }

  export type CryptoTokenCreateWithoutLeaderboardInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutLeaderboardInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutLeaderboardInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutLeaderboardInput, CryptoTokenUncheckedCreateWithoutLeaderboardInput>
  }

  export type UserUpsertWithoutLeaderboardEntriesInput = {
    update: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type UserUpdateWithoutLeaderboardEntriesInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutLeaderboardInput = {
    update: XOR<CryptoTokenUpdateWithoutLeaderboardInput, CryptoTokenUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<CryptoTokenCreateWithoutLeaderboardInput, CryptoTokenUncheckedCreateWithoutLeaderboardInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutLeaderboardInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutLeaderboardInput, CryptoTokenUncheckedUpdateWithoutLeaderboardInput>
  }

  export type CryptoTokenUpdateWithoutLeaderboardInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutLeaderboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutCommissionsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommissionsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
  }

  export type UserCreateWithoutReferralActionsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralActionsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralActionsInput, UserUncheckedCreateWithoutReferralActionsInput>
  }

  export type CryptoTokenCreateWithoutReferralCommissionsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutReferralCommissionsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutReferralCommissionsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutReferralCommissionsInput, CryptoTokenUncheckedCreateWithoutReferralCommissionsInput>
  }

  export type UserUpsertWithoutCommissionsInput = {
    update: XOR<UserUpdateWithoutCommissionsInput, UserUncheckedUpdateWithoutCommissionsInput>
    create: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommissionsInput, UserUncheckedUpdateWithoutCommissionsInput>
  }

  export type UserUpdateWithoutCommissionsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferralActionsInput = {
    update: XOR<UserUpdateWithoutReferralActionsInput, UserUncheckedUpdateWithoutReferralActionsInput>
    create: XOR<UserCreateWithoutReferralActionsInput, UserUncheckedCreateWithoutReferralActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralActionsInput, UserUncheckedUpdateWithoutReferralActionsInput>
  }

  export type UserUpdateWithoutReferralActionsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutReferralCommissionsInput = {
    update: XOR<CryptoTokenUpdateWithoutReferralCommissionsInput, CryptoTokenUncheckedUpdateWithoutReferralCommissionsInput>
    create: XOR<CryptoTokenCreateWithoutReferralCommissionsInput, CryptoTokenUncheckedCreateWithoutReferralCommissionsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutReferralCommissionsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutReferralCommissionsInput, CryptoTokenUncheckedUpdateWithoutReferralCommissionsInput>
  }

  export type CryptoTokenUpdateWithoutReferralCommissionsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutReferralCommissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutAuthTokensInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutAuthTokensInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutAuthTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
  }

  export type UserUpsertWithoutAuthTokensInput = {
    update: XOR<UserUpdateWithoutAuthTokensInput, UserUncheckedUpdateWithoutAuthTokensInput>
    create: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthTokensInput, UserUncheckedUpdateWithoutAuthTokensInput>
  }

  export type UserUpdateWithoutAuthTokensInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
  }

  export type BalanceCreateManyTokenInput = {
    id?: number
    userId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyTokenInput = {
    id?: number
    userId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetCreateManyTokenInput = {
    id?: number
    userId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeaderboardEntryCreateManyTokenInput = {
    id?: number
    userId: number
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type UserBonusCreateManyTokenInput = {
    id?: number
    userId: number
    bonusId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ReferralTransactionCreateManyTokenInput = {
    id?: number
    referrerId: number
    refereeId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type BalanceUpdateWithoutTokenInput = {
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutTokenInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUpdateWithoutTokenInput = {
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBetsNestedInput
  }

  export type BetUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUpdateWithoutTokenInput = {
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusUpdateWithoutTokenInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    bonus?: BonusUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralTransactionUpdateWithoutTokenInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutCommissionsNestedInput
    referee?: UserUpdateOneRequiredWithoutReferralActionsNestedInput
  }

  export type ReferralTransactionUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyReferrerInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
  }

  export type BalanceCreateManyUserInput = {
    id?: number
    tokenId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    tokenId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetCreateManyUserInput = {
    id?: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeaderboardEntryCreateManyUserInput = {
    id?: number
    tokenId?: number | null
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type UserBonusCreateManyUserInput = {
    id?: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ReferralTransactionCreateManyReferrerInput = {
    id?: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionCreateManyRefereeInput = {
    id?: number
    referrerId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type OneTimeTokenCreateManyUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type UserUpdateWithoutReferrerInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type BalanceUpdateWithoutUserInput = {
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUpdateWithoutUserInput = {
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneRequiredWithoutBetsNestedInput
  }

  export type BetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUpdateWithoutUserInput = {
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneWithoutLeaderboardNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: NullableIntFieldUpdateOperationsInput | number | null
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: NullableIntFieldUpdateOperationsInput | number | null
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusUpdateWithoutUserInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bonus?: BonusUpdateOneRequiredWithoutUserBonusesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralTransactionUpdateWithoutReferrerInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referee?: UserUpdateOneRequiredWithoutReferralActionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutReferralCommissionsNestedInput
  }

  export type ReferralTransactionUncheckedUpdateWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUpdateWithoutRefereeInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutCommissionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutReferralCommissionsNestedInput
  }

  export type ReferralTransactionUncheckedUpdateWithoutRefereeInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutRefereeInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneTimeTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OneTimeTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OneTimeTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserBonusCreateManyBonusInput = {
    id?: number
    userId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusUpdateWithoutBonusInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusUncheckedUpdateManyWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CryptoTokenCountOutputTypeDefaultArgs instead
     */
    export type CryptoTokenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoTokenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BonusCountOutputTypeDefaultArgs instead
     */
    export type BonusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BonusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoTokenDefaultArgs instead
     */
    export type CryptoTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BalanceDefaultArgs instead
     */
    export type BalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BalanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BetDefaultArgs instead
     */
    export type BetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BonusDefaultArgs instead
     */
    export type BonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BonusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBonusDefaultArgs instead
     */
    export type UserBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBonusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardEntryDefaultArgs instead
     */
    export type LeaderboardEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralTransactionDefaultArgs instead
     */
    export type ReferralTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OneTimeTokenDefaultArgs instead
     */
    export type OneTimeTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OneTimeTokenDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}