
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CryptoToken
 * 
 */
export type CryptoToken = $Result.DefaultSelection<Prisma.$CryptoTokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Balance
 * 
 */
export type Balance = $Result.DefaultSelection<Prisma.$BalancePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Bet
 * 
 */
export type Bet = $Result.DefaultSelection<Prisma.$BetPayload>
/**
 * Model Bonus
 * 
 */
export type Bonus = $Result.DefaultSelection<Prisma.$BonusPayload>
/**
 * Model UserBonus
 * 
 */
export type UserBonus = $Result.DefaultSelection<Prisma.$UserBonusPayload>
/**
 * Model LeaderboardEntry
 * 
 */
export type LeaderboardEntry = $Result.DefaultSelection<Prisma.$LeaderboardEntryPayload>
/**
 * Model ReferralTransaction
 * 
 */
export type ReferralTransaction = $Result.DefaultSelection<Prisma.$ReferralTransactionPayload>
/**
 * Model OneTimeToken
 * 
 */
export type OneTimeToken = $Result.DefaultSelection<Prisma.$OneTimeTokenPayload>
/**
 * Model CrashRound
 * 
 */
export type CrashRound = $Result.DefaultSelection<Prisma.$CrashRoundPayload>
/**
 * Model CrashBet
 * 
 */
export type CrashBet = $Result.DefaultSelection<Prisma.$CrashBetPayload>
/**
 * Model CrashTransaction
 * 
 */
export type CrashTransaction = $Result.DefaultSelection<Prisma.$CrashTransactionPayload>
/**
 * Model MinesweeperDifficulty
 * 
 */
export type MinesweeperDifficulty = $Result.DefaultSelection<Prisma.$MinesweeperDifficultyPayload>
/**
 * Model MinesweeperGame
 * 
 */
export type MinesweeperGame = $Result.DefaultSelection<Prisma.$MinesweeperGamePayload>
/**
 * Model MinesweeperBet
 * 
 */
export type MinesweeperBet = $Result.DefaultSelection<Prisma.$MinesweeperBetPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BalanceType: {
  MAIN: 'MAIN',
  BONUS: 'BONUS'
};

export type BalanceType = (typeof BalanceType)[keyof typeof BalanceType]


export const TransactionType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAW: 'WITHDRAW',
  BONUS: 'BONUS',
  REFUND: 'REFUND',
  TRANSFER: 'TRANSFER'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const GameType: {
  SLOT: 'SLOT',
  ROULETTE: 'ROULETTE',
  BLACKJACK: 'BLACKJACK',
  CRASH: 'CRASH',
  LIVE_DEALER: 'LIVE_DEALER',
  MINESWEEPER: 'MINESWEEPER'
};

export type GameType = (typeof GameType)[keyof typeof GameType]


export const ReferralEventType: {
  BET_COMMISSION: 'BET_COMMISSION',
  DEPOSIT_BONUS: 'DEPOSIT_BONUS'
};

export type ReferralEventType = (typeof ReferralEventType)[keyof typeof ReferralEventType]

}

export type BalanceType = $Enums.BalanceType

export const BalanceType: typeof $Enums.BalanceType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type GameType = $Enums.GameType

export const GameType: typeof $Enums.GameType

export type ReferralEventType = $Enums.ReferralEventType

export const ReferralEventType: typeof $Enums.ReferralEventType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CryptoTokens
 * const cryptoTokens = await prisma.cryptoToken.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CryptoTokens
   * const cryptoTokens = await prisma.cryptoToken.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.cryptoToken`: Exposes CRUD operations for the **CryptoToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoTokens
    * const cryptoTokens = await prisma.cryptoToken.findMany()
    * ```
    */
  get cryptoToken(): Prisma.CryptoTokenDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.balance`: Exposes CRUD operations for the **Balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balance.findMany()
    * ```
    */
  get balance(): Prisma.BalanceDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.bet`: Exposes CRUD operations for the **Bet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bets
    * const bets = await prisma.bet.findMany()
    * ```
    */
  get bet(): Prisma.BetDelegate<ExtArgs>;

  /**
   * `prisma.bonus`: Exposes CRUD operations for the **Bonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bonuses
    * const bonuses = await prisma.bonus.findMany()
    * ```
    */
  get bonus(): Prisma.BonusDelegate<ExtArgs>;

  /**
   * `prisma.userBonus`: Exposes CRUD operations for the **UserBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBonuses
    * const userBonuses = await prisma.userBonus.findMany()
    * ```
    */
  get userBonus(): Prisma.UserBonusDelegate<ExtArgs>;

  /**
   * `prisma.leaderboardEntry`: Exposes CRUD operations for the **LeaderboardEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardEntries
    * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
    * ```
    */
  get leaderboardEntry(): Prisma.LeaderboardEntryDelegate<ExtArgs>;

  /**
   * `prisma.referralTransaction`: Exposes CRUD operations for the **ReferralTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralTransactions
    * const referralTransactions = await prisma.referralTransaction.findMany()
    * ```
    */
  get referralTransaction(): Prisma.ReferralTransactionDelegate<ExtArgs>;

  /**
   * `prisma.oneTimeToken`: Exposes CRUD operations for the **OneTimeToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OneTimeTokens
    * const oneTimeTokens = await prisma.oneTimeToken.findMany()
    * ```
    */
  get oneTimeToken(): Prisma.OneTimeTokenDelegate<ExtArgs>;

  /**
   * `prisma.crashRound`: Exposes CRUD operations for the **CrashRound** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrashRounds
    * const crashRounds = await prisma.crashRound.findMany()
    * ```
    */
  get crashRound(): Prisma.CrashRoundDelegate<ExtArgs>;

  /**
   * `prisma.crashBet`: Exposes CRUD operations for the **CrashBet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrashBets
    * const crashBets = await prisma.crashBet.findMany()
    * ```
    */
  get crashBet(): Prisma.CrashBetDelegate<ExtArgs>;

  /**
   * `prisma.crashTransaction`: Exposes CRUD operations for the **CrashTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrashTransactions
    * const crashTransactions = await prisma.crashTransaction.findMany()
    * ```
    */
  get crashTransaction(): Prisma.CrashTransactionDelegate<ExtArgs>;

  /**
   * `prisma.minesweeperDifficulty`: Exposes CRUD operations for the **MinesweeperDifficulty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MinesweeperDifficulties
    * const minesweeperDifficulties = await prisma.minesweeperDifficulty.findMany()
    * ```
    */
  get minesweeperDifficulty(): Prisma.MinesweeperDifficultyDelegate<ExtArgs>;

  /**
   * `prisma.minesweeperGame`: Exposes CRUD operations for the **MinesweeperGame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MinesweeperGames
    * const minesweeperGames = await prisma.minesweeperGame.findMany()
    * ```
    */
  get minesweeperGame(): Prisma.MinesweeperGameDelegate<ExtArgs>;

  /**
   * `prisma.minesweeperBet`: Exposes CRUD operations for the **MinesweeperBet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MinesweeperBets
    * const minesweeperBets = await prisma.minesweeperBet.findMany()
    * ```
    */
  get minesweeperBet(): Prisma.MinesweeperBetDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CryptoToken: 'CryptoToken',
    User: 'User',
    Balance: 'Balance',
    Transaction: 'Transaction',
    Bet: 'Bet',
    Bonus: 'Bonus',
    UserBonus: 'UserBonus',
    LeaderboardEntry: 'LeaderboardEntry',
    ReferralTransaction: 'ReferralTransaction',
    OneTimeToken: 'OneTimeToken',
    CrashRound: 'CrashRound',
    CrashBet: 'CrashBet',
    CrashTransaction: 'CrashTransaction',
    MinesweeperDifficulty: 'MinesweeperDifficulty',
    MinesweeperGame: 'MinesweeperGame',
    MinesweeperBet: 'MinesweeperBet'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "cryptoToken" | "user" | "balance" | "transaction" | "bet" | "bonus" | "userBonus" | "leaderboardEntry" | "referralTransaction" | "oneTimeToken" | "crashRound" | "crashBet" | "crashTransaction" | "minesweeperDifficulty" | "minesweeperGame" | "minesweeperBet"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CryptoToken: {
        payload: Prisma.$CryptoTokenPayload<ExtArgs>
        fields: Prisma.CryptoTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          findFirst: {
            args: Prisma.CryptoTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          findMany: {
            args: Prisma.CryptoTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>[]
          }
          create: {
            args: Prisma.CryptoTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          createMany: {
            args: Prisma.CryptoTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>[]
          }
          delete: {
            args: Prisma.CryptoTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          update: {
            args: Prisma.CryptoTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          deleteMany: {
            args: Prisma.CryptoTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CryptoTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTokenPayload>
          }
          aggregate: {
            args: Prisma.CryptoTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoToken>
          }
          groupBy: {
            args: Prisma.CryptoTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoTokenCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoTokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Balance: {
        payload: Prisma.$BalancePayload<ExtArgs>
        fields: Prisma.BalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findFirst: {
            args: Prisma.BalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findMany: {
            args: Prisma.BalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          create: {
            args: Prisma.BalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          createMany: {
            args: Prisma.BalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          delete: {
            args: Prisma.BalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          update: {
            args: Prisma.BalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          deleteMany: {
            args: Prisma.BalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          aggregate: {
            args: Prisma.BalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalance>
          }
          groupBy: {
            args: Prisma.BalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Bet: {
        payload: Prisma.$BetPayload<ExtArgs>
        fields: Prisma.BetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          findFirst: {
            args: Prisma.BetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          findMany: {
            args: Prisma.BetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>[]
          }
          create: {
            args: Prisma.BetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          createMany: {
            args: Prisma.BetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>[]
          }
          delete: {
            args: Prisma.BetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          update: {
            args: Prisma.BetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          deleteMany: {
            args: Prisma.BetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetPayload>
          }
          aggregate: {
            args: Prisma.BetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBet>
          }
          groupBy: {
            args: Prisma.BetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetCountArgs<ExtArgs>
            result: $Utils.Optional<BetCountAggregateOutputType> | number
          }
        }
      }
      Bonus: {
        payload: Prisma.$BonusPayload<ExtArgs>
        fields: Prisma.BonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          findFirst: {
            args: Prisma.BonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          findMany: {
            args: Prisma.BonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          create: {
            args: Prisma.BonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          createMany: {
            args: Prisma.BonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          delete: {
            args: Prisma.BonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          update: {
            args: Prisma.BonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          deleteMany: {
            args: Prisma.BonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          aggregate: {
            args: Prisma.BonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBonus>
          }
          groupBy: {
            args: Prisma.BonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BonusCountArgs<ExtArgs>
            result: $Utils.Optional<BonusCountAggregateOutputType> | number
          }
        }
      }
      UserBonus: {
        payload: Prisma.$UserBonusPayload<ExtArgs>
        fields: Prisma.UserBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          findFirst: {
            args: Prisma.UserBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          findMany: {
            args: Prisma.UserBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>[]
          }
          create: {
            args: Prisma.UserBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          createMany: {
            args: Prisma.UserBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>[]
          }
          delete: {
            args: Prisma.UserBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          update: {
            args: Prisma.UserBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          deleteMany: {
            args: Prisma.UserBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBonusPayload>
          }
          aggregate: {
            args: Prisma.UserBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBonus>
          }
          groupBy: {
            args: Prisma.UserBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBonusCountArgs<ExtArgs>
            result: $Utils.Optional<UserBonusCountAggregateOutputType> | number
          }
        }
      }
      LeaderboardEntry: {
        payload: Prisma.$LeaderboardEntryPayload<ExtArgs>
        fields: Prisma.LeaderboardEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          findMany: {
            args: Prisma.LeaderboardEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          create: {
            args: Prisma.LeaderboardEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          createMany: {
            args: Prisma.LeaderboardEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
          }
          delete: {
            args: Prisma.LeaderboardEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          update: {
            args: Prisma.LeaderboardEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboardEntry>
          }
          groupBy: {
            args: Prisma.LeaderboardEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardEntryCountAggregateOutputType> | number
          }
        }
      }
      ReferralTransaction: {
        payload: Prisma.$ReferralTransactionPayload<ExtArgs>
        fields: Prisma.ReferralTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          findFirst: {
            args: Prisma.ReferralTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          findMany: {
            args: Prisma.ReferralTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>[]
          }
          create: {
            args: Prisma.ReferralTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          createMany: {
            args: Prisma.ReferralTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>[]
          }
          delete: {
            args: Prisma.ReferralTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          update: {
            args: Prisma.ReferralTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          deleteMany: {
            args: Prisma.ReferralTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralTransactionPayload>
          }
          aggregate: {
            args: Prisma.ReferralTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralTransaction>
          }
          groupBy: {
            args: Prisma.ReferralTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralTransactionCountAggregateOutputType> | number
          }
        }
      }
      OneTimeToken: {
        payload: Prisma.$OneTimeTokenPayload<ExtArgs>
        fields: Prisma.OneTimeTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OneTimeTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OneTimeTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          findFirst: {
            args: Prisma.OneTimeTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OneTimeTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          findMany: {
            args: Prisma.OneTimeTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>[]
          }
          create: {
            args: Prisma.OneTimeTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          createMany: {
            args: Prisma.OneTimeTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OneTimeTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>[]
          }
          delete: {
            args: Prisma.OneTimeTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          update: {
            args: Prisma.OneTimeTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          deleteMany: {
            args: Prisma.OneTimeTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OneTimeTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OneTimeTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneTimeTokenPayload>
          }
          aggregate: {
            args: Prisma.OneTimeTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOneTimeToken>
          }
          groupBy: {
            args: Prisma.OneTimeTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<OneTimeTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OneTimeTokenCountArgs<ExtArgs>
            result: $Utils.Optional<OneTimeTokenCountAggregateOutputType> | number
          }
        }
      }
      CrashRound: {
        payload: Prisma.$CrashRoundPayload<ExtArgs>
        fields: Prisma.CrashRoundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrashRoundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrashRoundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload>
          }
          findFirst: {
            args: Prisma.CrashRoundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrashRoundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload>
          }
          findMany: {
            args: Prisma.CrashRoundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload>[]
          }
          create: {
            args: Prisma.CrashRoundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload>
          }
          createMany: {
            args: Prisma.CrashRoundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrashRoundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload>[]
          }
          delete: {
            args: Prisma.CrashRoundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload>
          }
          update: {
            args: Prisma.CrashRoundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload>
          }
          deleteMany: {
            args: Prisma.CrashRoundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrashRoundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrashRoundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashRoundPayload>
          }
          aggregate: {
            args: Prisma.CrashRoundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrashRound>
          }
          groupBy: {
            args: Prisma.CrashRoundGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrashRoundGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrashRoundCountArgs<ExtArgs>
            result: $Utils.Optional<CrashRoundCountAggregateOutputType> | number
          }
        }
      }
      CrashBet: {
        payload: Prisma.$CrashBetPayload<ExtArgs>
        fields: Prisma.CrashBetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrashBetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrashBetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload>
          }
          findFirst: {
            args: Prisma.CrashBetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrashBetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload>
          }
          findMany: {
            args: Prisma.CrashBetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload>[]
          }
          create: {
            args: Prisma.CrashBetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload>
          }
          createMany: {
            args: Prisma.CrashBetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrashBetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload>[]
          }
          delete: {
            args: Prisma.CrashBetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload>
          }
          update: {
            args: Prisma.CrashBetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload>
          }
          deleteMany: {
            args: Prisma.CrashBetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrashBetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrashBetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashBetPayload>
          }
          aggregate: {
            args: Prisma.CrashBetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrashBet>
          }
          groupBy: {
            args: Prisma.CrashBetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrashBetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrashBetCountArgs<ExtArgs>
            result: $Utils.Optional<CrashBetCountAggregateOutputType> | number
          }
        }
      }
      CrashTransaction: {
        payload: Prisma.$CrashTransactionPayload<ExtArgs>
        fields: Prisma.CrashTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrashTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrashTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload>
          }
          findFirst: {
            args: Prisma.CrashTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrashTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload>
          }
          findMany: {
            args: Prisma.CrashTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload>[]
          }
          create: {
            args: Prisma.CrashTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload>
          }
          createMany: {
            args: Prisma.CrashTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrashTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload>[]
          }
          delete: {
            args: Prisma.CrashTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload>
          }
          update: {
            args: Prisma.CrashTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CrashTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrashTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CrashTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrashTransactionPayload>
          }
          aggregate: {
            args: Prisma.CrashTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrashTransaction>
          }
          groupBy: {
            args: Prisma.CrashTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrashTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrashTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CrashTransactionCountAggregateOutputType> | number
          }
        }
      }
      MinesweeperDifficulty: {
        payload: Prisma.$MinesweeperDifficultyPayload<ExtArgs>
        fields: Prisma.MinesweeperDifficultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MinesweeperDifficultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MinesweeperDifficultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload>
          }
          findFirst: {
            args: Prisma.MinesweeperDifficultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MinesweeperDifficultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload>
          }
          findMany: {
            args: Prisma.MinesweeperDifficultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload>[]
          }
          create: {
            args: Prisma.MinesweeperDifficultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload>
          }
          createMany: {
            args: Prisma.MinesweeperDifficultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MinesweeperDifficultyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload>[]
          }
          delete: {
            args: Prisma.MinesweeperDifficultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload>
          }
          update: {
            args: Prisma.MinesweeperDifficultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload>
          }
          deleteMany: {
            args: Prisma.MinesweeperDifficultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MinesweeperDifficultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MinesweeperDifficultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperDifficultyPayload>
          }
          aggregate: {
            args: Prisma.MinesweeperDifficultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMinesweeperDifficulty>
          }
          groupBy: {
            args: Prisma.MinesweeperDifficultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<MinesweeperDifficultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.MinesweeperDifficultyCountArgs<ExtArgs>
            result: $Utils.Optional<MinesweeperDifficultyCountAggregateOutputType> | number
          }
        }
      }
      MinesweeperGame: {
        payload: Prisma.$MinesweeperGamePayload<ExtArgs>
        fields: Prisma.MinesweeperGameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MinesweeperGameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MinesweeperGameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload>
          }
          findFirst: {
            args: Prisma.MinesweeperGameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MinesweeperGameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload>
          }
          findMany: {
            args: Prisma.MinesweeperGameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload>[]
          }
          create: {
            args: Prisma.MinesweeperGameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload>
          }
          createMany: {
            args: Prisma.MinesweeperGameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MinesweeperGameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload>[]
          }
          delete: {
            args: Prisma.MinesweeperGameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload>
          }
          update: {
            args: Prisma.MinesweeperGameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload>
          }
          deleteMany: {
            args: Prisma.MinesweeperGameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MinesweeperGameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MinesweeperGameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperGamePayload>
          }
          aggregate: {
            args: Prisma.MinesweeperGameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMinesweeperGame>
          }
          groupBy: {
            args: Prisma.MinesweeperGameGroupByArgs<ExtArgs>
            result: $Utils.Optional<MinesweeperGameGroupByOutputType>[]
          }
          count: {
            args: Prisma.MinesweeperGameCountArgs<ExtArgs>
            result: $Utils.Optional<MinesweeperGameCountAggregateOutputType> | number
          }
        }
      }
      MinesweeperBet: {
        payload: Prisma.$MinesweeperBetPayload<ExtArgs>
        fields: Prisma.MinesweeperBetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MinesweeperBetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MinesweeperBetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload>
          }
          findFirst: {
            args: Prisma.MinesweeperBetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MinesweeperBetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload>
          }
          findMany: {
            args: Prisma.MinesweeperBetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload>[]
          }
          create: {
            args: Prisma.MinesweeperBetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload>
          }
          createMany: {
            args: Prisma.MinesweeperBetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MinesweeperBetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload>[]
          }
          delete: {
            args: Prisma.MinesweeperBetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload>
          }
          update: {
            args: Prisma.MinesweeperBetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload>
          }
          deleteMany: {
            args: Prisma.MinesweeperBetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MinesweeperBetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MinesweeperBetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinesweeperBetPayload>
          }
          aggregate: {
            args: Prisma.MinesweeperBetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMinesweeperBet>
          }
          groupBy: {
            args: Prisma.MinesweeperBetGroupByArgs<ExtArgs>
            result: $Utils.Optional<MinesweeperBetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MinesweeperBetCountArgs<ExtArgs>
            result: $Utils.Optional<MinesweeperBetCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CryptoTokenCountOutputType
   */

  export type CryptoTokenCountOutputType = {
    crashBets: number
    crashTransactions: number
    minesweeperGames: number
    minesweeperBets: number
    balances: number
    transactions: number
    bets: number
    leaderboard: number
    userBonuses: number
    referralCommissions: number
  }

  export type CryptoTokenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crashBets?: boolean | CryptoTokenCountOutputTypeCountCrashBetsArgs
    crashTransactions?: boolean | CryptoTokenCountOutputTypeCountCrashTransactionsArgs
    minesweeperGames?: boolean | CryptoTokenCountOutputTypeCountMinesweeperGamesArgs
    minesweeperBets?: boolean | CryptoTokenCountOutputTypeCountMinesweeperBetsArgs
    balances?: boolean | CryptoTokenCountOutputTypeCountBalancesArgs
    transactions?: boolean | CryptoTokenCountOutputTypeCountTransactionsArgs
    bets?: boolean | CryptoTokenCountOutputTypeCountBetsArgs
    leaderboard?: boolean | CryptoTokenCountOutputTypeCountLeaderboardArgs
    userBonuses?: boolean | CryptoTokenCountOutputTypeCountUserBonusesArgs
    referralCommissions?: boolean | CryptoTokenCountOutputTypeCountReferralCommissionsArgs
  }

  // Custom InputTypes
  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTokenCountOutputType
     */
    select?: CryptoTokenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountCrashBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashBetWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountCrashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashTransactionWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountMinesweeperGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinesweeperGameWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountMinesweeperBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinesweeperBetWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountUserBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
  }

  /**
   * CryptoTokenCountOutputType without action
   */
  export type CryptoTokenCountOutputTypeCountReferralCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralTransactionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    referrals: number
    crashBets: number
    crashTransactions: number
    minesweeperGames: number
    minesweeperBets: number
    balances: number
    transactions: number
    bets: number
    leaderboardEntries: number
    bonuses: number
    commissions: number
    referralActions: number
    authTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    crashBets?: boolean | UserCountOutputTypeCountCrashBetsArgs
    crashTransactions?: boolean | UserCountOutputTypeCountCrashTransactionsArgs
    minesweeperGames?: boolean | UserCountOutputTypeCountMinesweeperGamesArgs
    minesweeperBets?: boolean | UserCountOutputTypeCountMinesweeperBetsArgs
    balances?: boolean | UserCountOutputTypeCountBalancesArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    bets?: boolean | UserCountOutputTypeCountBetsArgs
    leaderboardEntries?: boolean | UserCountOutputTypeCountLeaderboardEntriesArgs
    bonuses?: boolean | UserCountOutputTypeCountBonusesArgs
    commissions?: boolean | UserCountOutputTypeCountCommissionsArgs
    referralActions?: boolean | UserCountOutputTypeCountReferralActionsArgs
    authTokens?: boolean | UserCountOutputTypeCountAuthTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrashBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashBetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMinesweeperGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinesweeperGameWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMinesweeperBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinesweeperBetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneTimeTokenWhereInput
  }


  /**
   * Count Type BonusCountOutputType
   */

  export type BonusCountOutputType = {
    userBonuses: number
  }

  export type BonusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBonuses?: boolean | BonusCountOutputTypeCountUserBonusesArgs
  }

  // Custom InputTypes
  /**
   * BonusCountOutputType without action
   */
  export type BonusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonusCountOutputType
     */
    select?: BonusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BonusCountOutputType without action
   */
  export type BonusCountOutputTypeCountUserBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
  }


  /**
   * Count Type CrashRoundCountOutputType
   */

  export type CrashRoundCountOutputType = {
    bets: number
  }

  export type CrashRoundCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bets?: boolean | CrashRoundCountOutputTypeCountBetsArgs
  }

  // Custom InputTypes
  /**
   * CrashRoundCountOutputType without action
   */
  export type CrashRoundCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRoundCountOutputType
     */
    select?: CrashRoundCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrashRoundCountOutputType without action
   */
  export type CrashRoundCountOutputTypeCountBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashBetWhereInput
  }


  /**
   * Count Type CrashBetCountOutputType
   */

  export type CrashBetCountOutputType = {
    transactions: number
  }

  export type CrashBetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CrashBetCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CrashBetCountOutputType without action
   */
  export type CrashBetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBetCountOutputType
     */
    select?: CrashBetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrashBetCountOutputType without action
   */
  export type CrashBetCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashTransactionWhereInput
  }


  /**
   * Count Type MinesweeperDifficultyCountOutputType
   */

  export type MinesweeperDifficultyCountOutputType = {
    games: number
  }

  export type MinesweeperDifficultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | MinesweeperDifficultyCountOutputTypeCountGamesArgs
  }

  // Custom InputTypes
  /**
   * MinesweeperDifficultyCountOutputType without action
   */
  export type MinesweeperDifficultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficultyCountOutputType
     */
    select?: MinesweeperDifficultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MinesweeperDifficultyCountOutputType without action
   */
  export type MinesweeperDifficultyCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinesweeperGameWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CryptoToken
   */

  export type AggregateCryptoToken = {
    _count: CryptoTokenCountAggregateOutputType | null
    _avg: CryptoTokenAvgAggregateOutputType | null
    _sum: CryptoTokenSumAggregateOutputType | null
    _min: CryptoTokenMinAggregateOutputType | null
    _max: CryptoTokenMaxAggregateOutputType | null
  }

  export type CryptoTokenAvgAggregateOutputType = {
    id: number | null
    decimals: number | null
  }

  export type CryptoTokenSumAggregateOutputType = {
    id: number | null
    decimals: number | null
  }

  export type CryptoTokenMinAggregateOutputType = {
    id: number | null
    symbol: string | null
    name: string | null
    network: string | null
    decimals: number | null
    createdAt: Date | null
  }

  export type CryptoTokenMaxAggregateOutputType = {
    id: number | null
    symbol: string | null
    name: string | null
    network: string | null
    decimals: number | null
    createdAt: Date | null
  }

  export type CryptoTokenCountAggregateOutputType = {
    id: number
    symbol: number
    name: number
    network: number
    decimals: number
    createdAt: number
    _all: number
  }


  export type CryptoTokenAvgAggregateInputType = {
    id?: true
    decimals?: true
  }

  export type CryptoTokenSumAggregateInputType = {
    id?: true
    decimals?: true
  }

  export type CryptoTokenMinAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    network?: true
    decimals?: true
    createdAt?: true
  }

  export type CryptoTokenMaxAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    network?: true
    decimals?: true
    createdAt?: true
  }

  export type CryptoTokenCountAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    network?: true
    decimals?: true
    createdAt?: true
    _all?: true
  }

  export type CryptoTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoToken to aggregate.
     */
    where?: CryptoTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTokens to fetch.
     */
    orderBy?: CryptoTokenOrderByWithRelationInput | CryptoTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoTokens
    **/
    _count?: true | CryptoTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoTokenMaxAggregateInputType
  }

  export type GetCryptoTokenAggregateType<T extends CryptoTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoToken[P]>
      : GetScalarType<T[P], AggregateCryptoToken[P]>
  }




  export type CryptoTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoTokenWhereInput
    orderBy?: CryptoTokenOrderByWithAggregationInput | CryptoTokenOrderByWithAggregationInput[]
    by: CryptoTokenScalarFieldEnum[] | CryptoTokenScalarFieldEnum
    having?: CryptoTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoTokenCountAggregateInputType | true
    _avg?: CryptoTokenAvgAggregateInputType
    _sum?: CryptoTokenSumAggregateInputType
    _min?: CryptoTokenMinAggregateInputType
    _max?: CryptoTokenMaxAggregateInputType
  }

  export type CryptoTokenGroupByOutputType = {
    id: number
    symbol: string
    name: string
    network: string
    decimals: number
    createdAt: Date
    _count: CryptoTokenCountAggregateOutputType | null
    _avg: CryptoTokenAvgAggregateOutputType | null
    _sum: CryptoTokenSumAggregateOutputType | null
    _min: CryptoTokenMinAggregateOutputType | null
    _max: CryptoTokenMaxAggregateOutputType | null
  }

  type GetCryptoTokenGroupByPayload<T extends CryptoTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoTokenGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoTokenGroupByOutputType[P]>
        }
      >
    >


  export type CryptoTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    network?: boolean
    decimals?: boolean
    createdAt?: boolean
    crashBets?: boolean | CryptoToken$crashBetsArgs<ExtArgs>
    crashTransactions?: boolean | CryptoToken$crashTransactionsArgs<ExtArgs>
    minesweeperGames?: boolean | CryptoToken$minesweeperGamesArgs<ExtArgs>
    minesweeperBets?: boolean | CryptoToken$minesweeperBetsArgs<ExtArgs>
    balances?: boolean | CryptoToken$balancesArgs<ExtArgs>
    transactions?: boolean | CryptoToken$transactionsArgs<ExtArgs>
    bets?: boolean | CryptoToken$betsArgs<ExtArgs>
    leaderboard?: boolean | CryptoToken$leaderboardArgs<ExtArgs>
    userBonuses?: boolean | CryptoToken$userBonusesArgs<ExtArgs>
    referralCommissions?: boolean | CryptoToken$referralCommissionsArgs<ExtArgs>
    _count?: boolean | CryptoTokenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoToken"]>

  export type CryptoTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    network?: boolean
    decimals?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cryptoToken"]>

  export type CryptoTokenSelectScalar = {
    id?: boolean
    symbol?: boolean
    name?: boolean
    network?: boolean
    decimals?: boolean
    createdAt?: boolean
  }

  export type CryptoTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crashBets?: boolean | CryptoToken$crashBetsArgs<ExtArgs>
    crashTransactions?: boolean | CryptoToken$crashTransactionsArgs<ExtArgs>
    minesweeperGames?: boolean | CryptoToken$minesweeperGamesArgs<ExtArgs>
    minesweeperBets?: boolean | CryptoToken$minesweeperBetsArgs<ExtArgs>
    balances?: boolean | CryptoToken$balancesArgs<ExtArgs>
    transactions?: boolean | CryptoToken$transactionsArgs<ExtArgs>
    bets?: boolean | CryptoToken$betsArgs<ExtArgs>
    leaderboard?: boolean | CryptoToken$leaderboardArgs<ExtArgs>
    userBonuses?: boolean | CryptoToken$userBonusesArgs<ExtArgs>
    referralCommissions?: boolean | CryptoToken$referralCommissionsArgs<ExtArgs>
    _count?: boolean | CryptoTokenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CryptoTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CryptoTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoToken"
    objects: {
      crashBets: Prisma.$CrashBetPayload<ExtArgs>[]
      crashTransactions: Prisma.$CrashTransactionPayload<ExtArgs>[]
      minesweeperGames: Prisma.$MinesweeperGamePayload<ExtArgs>[]
      minesweeperBets: Prisma.$MinesweeperBetPayload<ExtArgs>[]
      balances: Prisma.$BalancePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      bets: Prisma.$BetPayload<ExtArgs>[]
      leaderboard: Prisma.$LeaderboardEntryPayload<ExtArgs>[]
      userBonuses: Prisma.$UserBonusPayload<ExtArgs>[]
      referralCommissions: Prisma.$ReferralTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol: string
      name: string
      network: string
      decimals: number
      createdAt: Date
    }, ExtArgs["result"]["cryptoToken"]>
    composites: {}
  }

  type CryptoTokenGetPayload<S extends boolean | null | undefined | CryptoTokenDefaultArgs> = $Result.GetResult<Prisma.$CryptoTokenPayload, S>

  type CryptoTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CryptoTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CryptoTokenCountAggregateInputType | true
    }

  export interface CryptoTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoToken'], meta: { name: 'CryptoToken' } }
    /**
     * Find zero or one CryptoToken that matches the filter.
     * @param {CryptoTokenFindUniqueArgs} args - Arguments to find a CryptoToken
     * @example
     * // Get one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoTokenFindUniqueArgs>(args: SelectSubset<T, CryptoTokenFindUniqueArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CryptoToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CryptoTokenFindUniqueOrThrowArgs} args - Arguments to find a CryptoToken
     * @example
     * // Get one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CryptoToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenFindFirstArgs} args - Arguments to find a CryptoToken
     * @example
     * // Get one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoTokenFindFirstArgs>(args?: SelectSubset<T, CryptoTokenFindFirstArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CryptoToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenFindFirstOrThrowArgs} args - Arguments to find a CryptoToken
     * @example
     * // Get one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CryptoTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoTokens
     * const cryptoTokens = await prisma.cryptoToken.findMany()
     * 
     * // Get first 10 CryptoTokens
     * const cryptoTokens = await prisma.cryptoToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoTokenWithIdOnly = await prisma.cryptoToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoTokenFindManyArgs>(args?: SelectSubset<T, CryptoTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CryptoToken.
     * @param {CryptoTokenCreateArgs} args - Arguments to create a CryptoToken.
     * @example
     * // Create one CryptoToken
     * const CryptoToken = await prisma.cryptoToken.create({
     *   data: {
     *     // ... data to create a CryptoToken
     *   }
     * })
     * 
     */
    create<T extends CryptoTokenCreateArgs>(args: SelectSubset<T, CryptoTokenCreateArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CryptoTokens.
     * @param {CryptoTokenCreateManyArgs} args - Arguments to create many CryptoTokens.
     * @example
     * // Create many CryptoTokens
     * const cryptoToken = await prisma.cryptoToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoTokenCreateManyArgs>(args?: SelectSubset<T, CryptoTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoTokens and returns the data saved in the database.
     * @param {CryptoTokenCreateManyAndReturnArgs} args - Arguments to create many CryptoTokens.
     * @example
     * // Create many CryptoTokens
     * const cryptoToken = await prisma.cryptoToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoTokens and only return the `id`
     * const cryptoTokenWithIdOnly = await prisma.cryptoToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CryptoToken.
     * @param {CryptoTokenDeleteArgs} args - Arguments to delete one CryptoToken.
     * @example
     * // Delete one CryptoToken
     * const CryptoToken = await prisma.cryptoToken.delete({
     *   where: {
     *     // ... filter to delete one CryptoToken
     *   }
     * })
     * 
     */
    delete<T extends CryptoTokenDeleteArgs>(args: SelectSubset<T, CryptoTokenDeleteArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CryptoToken.
     * @param {CryptoTokenUpdateArgs} args - Arguments to update one CryptoToken.
     * @example
     * // Update one CryptoToken
     * const cryptoToken = await prisma.cryptoToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoTokenUpdateArgs>(args: SelectSubset<T, CryptoTokenUpdateArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CryptoTokens.
     * @param {CryptoTokenDeleteManyArgs} args - Arguments to filter CryptoTokens to delete.
     * @example
     * // Delete a few CryptoTokens
     * const { count } = await prisma.cryptoToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoTokenDeleteManyArgs>(args?: SelectSubset<T, CryptoTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoTokens
     * const cryptoToken = await prisma.cryptoToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoTokenUpdateManyArgs>(args: SelectSubset<T, CryptoTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoToken.
     * @param {CryptoTokenUpsertArgs} args - Arguments to update or create a CryptoToken.
     * @example
     * // Update or create a CryptoToken
     * const cryptoToken = await prisma.cryptoToken.upsert({
     *   create: {
     *     // ... data to create a CryptoToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoToken we want to update
     *   }
     * })
     */
    upsert<T extends CryptoTokenUpsertArgs>(args: SelectSubset<T, CryptoTokenUpsertArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CryptoTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenCountArgs} args - Arguments to filter CryptoTokens to count.
     * @example
     * // Count the number of CryptoTokens
     * const count = await prisma.cryptoToken.count({
     *   where: {
     *     // ... the filter for the CryptoTokens we want to count
     *   }
     * })
    **/
    count<T extends CryptoTokenCountArgs>(
      args?: Subset<T, CryptoTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoTokenAggregateArgs>(args: Subset<T, CryptoTokenAggregateArgs>): Prisma.PrismaPromise<GetCryptoTokenAggregateType<T>>

    /**
     * Group by CryptoToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoTokenGroupByArgs['orderBy'] }
        : { orderBy?: CryptoTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoToken model
   */
  readonly fields: CryptoTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    crashBets<T extends CryptoToken$crashBetsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$crashBetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findMany"> | Null>
    crashTransactions<T extends CryptoToken$crashTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$crashTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    minesweeperGames<T extends CryptoToken$minesweeperGamesArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$minesweeperGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "findMany"> | Null>
    minesweeperBets<T extends CryptoToken$minesweeperBetsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$minesweeperBetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "findMany"> | Null>
    balances<T extends CryptoToken$balancesArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends CryptoToken$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    bets<T extends CryptoToken$betsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$betsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findMany"> | Null>
    leaderboard<T extends CryptoToken$leaderboardArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$leaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany"> | Null>
    userBonuses<T extends CryptoToken$userBonusesArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$userBonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany"> | Null>
    referralCommissions<T extends CryptoToken$referralCommissionsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoToken$referralCommissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoToken model
   */ 
  interface CryptoTokenFieldRefs {
    readonly id: FieldRef<"CryptoToken", 'Int'>
    readonly symbol: FieldRef<"CryptoToken", 'String'>
    readonly name: FieldRef<"CryptoToken", 'String'>
    readonly network: FieldRef<"CryptoToken", 'String'>
    readonly decimals: FieldRef<"CryptoToken", 'Int'>
    readonly createdAt: FieldRef<"CryptoToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoToken findUnique
   */
  export type CryptoTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoToken to fetch.
     */
    where: CryptoTokenWhereUniqueInput
  }

  /**
   * CryptoToken findUniqueOrThrow
   */
  export type CryptoTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoToken to fetch.
     */
    where: CryptoTokenWhereUniqueInput
  }

  /**
   * CryptoToken findFirst
   */
  export type CryptoTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoToken to fetch.
     */
    where?: CryptoTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTokens to fetch.
     */
    orderBy?: CryptoTokenOrderByWithRelationInput | CryptoTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoTokens.
     */
    cursor?: CryptoTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoTokens.
     */
    distinct?: CryptoTokenScalarFieldEnum | CryptoTokenScalarFieldEnum[]
  }

  /**
   * CryptoToken findFirstOrThrow
   */
  export type CryptoTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoToken to fetch.
     */
    where?: CryptoTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTokens to fetch.
     */
    orderBy?: CryptoTokenOrderByWithRelationInput | CryptoTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoTokens.
     */
    cursor?: CryptoTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoTokens.
     */
    distinct?: CryptoTokenScalarFieldEnum | CryptoTokenScalarFieldEnum[]
  }

  /**
   * CryptoToken findMany
   */
  export type CryptoTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTokens to fetch.
     */
    where?: CryptoTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTokens to fetch.
     */
    orderBy?: CryptoTokenOrderByWithRelationInput | CryptoTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoTokens.
     */
    cursor?: CryptoTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTokens.
     */
    skip?: number
    distinct?: CryptoTokenScalarFieldEnum | CryptoTokenScalarFieldEnum[]
  }

  /**
   * CryptoToken create
   */
  export type CryptoTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoToken.
     */
    data: XOR<CryptoTokenCreateInput, CryptoTokenUncheckedCreateInput>
  }

  /**
   * CryptoToken createMany
   */
  export type CryptoTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoTokens.
     */
    data: CryptoTokenCreateManyInput | CryptoTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoToken createManyAndReturn
   */
  export type CryptoTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CryptoTokens.
     */
    data: CryptoTokenCreateManyInput | CryptoTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoToken update
   */
  export type CryptoTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoToken.
     */
    data: XOR<CryptoTokenUpdateInput, CryptoTokenUncheckedUpdateInput>
    /**
     * Choose, which CryptoToken to update.
     */
    where: CryptoTokenWhereUniqueInput
  }

  /**
   * CryptoToken updateMany
   */
  export type CryptoTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoTokens.
     */
    data: XOR<CryptoTokenUpdateManyMutationInput, CryptoTokenUncheckedUpdateManyInput>
    /**
     * Filter which CryptoTokens to update
     */
    where?: CryptoTokenWhereInput
  }

  /**
   * CryptoToken upsert
   */
  export type CryptoTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoToken to update in case it exists.
     */
    where: CryptoTokenWhereUniqueInput
    /**
     * In case the CryptoToken found by the `where` argument doesn't exist, create a new CryptoToken with this data.
     */
    create: XOR<CryptoTokenCreateInput, CryptoTokenUncheckedCreateInput>
    /**
     * In case the CryptoToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoTokenUpdateInput, CryptoTokenUncheckedUpdateInput>
  }

  /**
   * CryptoToken delete
   */
  export type CryptoTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    /**
     * Filter which CryptoToken to delete.
     */
    where: CryptoTokenWhereUniqueInput
  }

  /**
   * CryptoToken deleteMany
   */
  export type CryptoTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoTokens to delete
     */
    where?: CryptoTokenWhereInput
  }

  /**
   * CryptoToken.crashBets
   */
  export type CryptoToken$crashBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    where?: CrashBetWhereInput
    orderBy?: CrashBetOrderByWithRelationInput | CrashBetOrderByWithRelationInput[]
    cursor?: CrashBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrashBetScalarFieldEnum | CrashBetScalarFieldEnum[]
  }

  /**
   * CryptoToken.crashTransactions
   */
  export type CryptoToken$crashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    where?: CrashTransactionWhereInput
    orderBy?: CrashTransactionOrderByWithRelationInput | CrashTransactionOrderByWithRelationInput[]
    cursor?: CrashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrashTransactionScalarFieldEnum | CrashTransactionScalarFieldEnum[]
  }

  /**
   * CryptoToken.minesweeperGames
   */
  export type CryptoToken$minesweeperGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    where?: MinesweeperGameWhereInput
    orderBy?: MinesweeperGameOrderByWithRelationInput | MinesweeperGameOrderByWithRelationInput[]
    cursor?: MinesweeperGameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinesweeperGameScalarFieldEnum | MinesweeperGameScalarFieldEnum[]
  }

  /**
   * CryptoToken.minesweeperBets
   */
  export type CryptoToken$minesweeperBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    where?: MinesweeperBetWhereInput
    orderBy?: MinesweeperBetOrderByWithRelationInput | MinesweeperBetOrderByWithRelationInput[]
    cursor?: MinesweeperBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinesweeperBetScalarFieldEnum | MinesweeperBetScalarFieldEnum[]
  }

  /**
   * CryptoToken.balances
   */
  export type CryptoToken$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    cursor?: BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * CryptoToken.transactions
   */
  export type CryptoToken$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * CryptoToken.bets
   */
  export type CryptoToken$betsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    where?: BetWhereInput
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    cursor?: BetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * CryptoToken.leaderboard
   */
  export type CryptoToken$leaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    cursor?: LeaderboardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * CryptoToken.userBonuses
   */
  export type CryptoToken$userBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    cursor?: UserBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * CryptoToken.referralCommissions
   */
  export type CryptoToken$referralCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    where?: ReferralTransactionWhereInput
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    cursor?: ReferralTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * CryptoToken without action
   */
  export type CryptoTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    referredById: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    referredById: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    photoUrl: string | null
    passwordHash: string | null
    salt: string | null
    isAdmin: boolean | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredById: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    telegramId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    photoUrl: string | null
    passwordHash: string | null
    salt: string | null
    isAdmin: boolean | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredById: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    telegramId: number
    username: number
    firstName: number
    lastName: number
    photoUrl: number
    passwordHash: number
    salt: number
    isAdmin: number
    isBlocked: number
    createdAt: number
    updatedAt: number
    referralCode: number
    referredById: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    referredById?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    referredById?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    photoUrl?: true
    passwordHash?: true
    salt?: true
    isAdmin?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    photoUrl?: true
    passwordHash?: true
    salt?: true
    isAdmin?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    telegramId?: true
    username?: true
    firstName?: true
    lastName?: true
    photoUrl?: true
    passwordHash?: true
    salt?: true
    isAdmin?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    telegramId: string
    username: string | null
    firstName: string | null
    lastName: string | null
    photoUrl: string | null
    passwordHash: string | null
    salt: string | null
    isAdmin: boolean
    isBlocked: boolean
    createdAt: Date
    updatedAt: Date
    referralCode: string
    referredById: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    photoUrl?: boolean
    passwordHash?: boolean
    salt?: boolean
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredById?: boolean
    referrer?: boolean | User$referrerArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    crashBets?: boolean | User$crashBetsArgs<ExtArgs>
    crashTransactions?: boolean | User$crashTransactionsArgs<ExtArgs>
    minesweeperGames?: boolean | User$minesweeperGamesArgs<ExtArgs>
    minesweeperBets?: boolean | User$minesweeperBetsArgs<ExtArgs>
    balances?: boolean | User$balancesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    bets?: boolean | User$betsArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    bonuses?: boolean | User$bonusesArgs<ExtArgs>
    commissions?: boolean | User$commissionsArgs<ExtArgs>
    referralActions?: boolean | User$referralActionsArgs<ExtArgs>
    authTokens?: boolean | User$authTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    photoUrl?: boolean
    passwordHash?: boolean
    salt?: boolean
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredById?: boolean
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    telegramId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    photoUrl?: boolean
    passwordHash?: boolean
    salt?: boolean
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredById?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | User$referrerArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    crashBets?: boolean | User$crashBetsArgs<ExtArgs>
    crashTransactions?: boolean | User$crashTransactionsArgs<ExtArgs>
    minesweeperGames?: boolean | User$minesweeperGamesArgs<ExtArgs>
    minesweeperBets?: boolean | User$minesweeperBetsArgs<ExtArgs>
    balances?: boolean | User$balancesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    bets?: boolean | User$betsArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    bonuses?: boolean | User$bonusesArgs<ExtArgs>
    commissions?: boolean | User$commissionsArgs<ExtArgs>
    referralActions?: boolean | User$referralActionsArgs<ExtArgs>
    authTokens?: boolean | User$authTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs> | null
      referrals: Prisma.$UserPayload<ExtArgs>[]
      crashBets: Prisma.$CrashBetPayload<ExtArgs>[]
      crashTransactions: Prisma.$CrashTransactionPayload<ExtArgs>[]
      minesweeperGames: Prisma.$MinesweeperGamePayload<ExtArgs>[]
      minesweeperBets: Prisma.$MinesweeperBetPayload<ExtArgs>[]
      balances: Prisma.$BalancePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      bets: Prisma.$BetPayload<ExtArgs>[]
      leaderboardEntries: Prisma.$LeaderboardEntryPayload<ExtArgs>[]
      bonuses: Prisma.$UserBonusPayload<ExtArgs>[]
      commissions: Prisma.$ReferralTransactionPayload<ExtArgs>[]
      referralActions: Prisma.$ReferralTransactionPayload<ExtArgs>[]
      authTokens: Prisma.$OneTimeTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telegramId: string
      username: string | null
      firstName: string | null
      lastName: string | null
      photoUrl: string | null
      passwordHash: string | null
      salt: string | null
      isAdmin: boolean
      isBlocked: boolean
      createdAt: Date
      updatedAt: Date
      referralCode: string
      referredById: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends User$referrerArgs<ExtArgs> = {}>(args?: Subset<T, User$referrerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    crashBets<T extends User$crashBetsArgs<ExtArgs> = {}>(args?: Subset<T, User$crashBetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findMany"> | Null>
    crashTransactions<T extends User$crashTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$crashTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    minesweeperGames<T extends User$minesweeperGamesArgs<ExtArgs> = {}>(args?: Subset<T, User$minesweeperGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "findMany"> | Null>
    minesweeperBets<T extends User$minesweeperBetsArgs<ExtArgs> = {}>(args?: Subset<T, User$minesweeperBetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "findMany"> | Null>
    balances<T extends User$balancesArgs<ExtArgs> = {}>(args?: Subset<T, User$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    bets<T extends User$betsArgs<ExtArgs> = {}>(args?: Subset<T, User$betsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findMany"> | Null>
    leaderboardEntries<T extends User$leaderboardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany"> | Null>
    bonuses<T extends User$bonusesArgs<ExtArgs> = {}>(args?: Subset<T, User$bonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany"> | Null>
    commissions<T extends User$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    referralActions<T extends User$referralActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    authTokens<T extends User$authTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$authTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly telegramId: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly photoUrl: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly salt: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly isBlocked: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly referredById: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.referrer
   */
  export type User$referrerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.crashBets
   */
  export type User$crashBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    where?: CrashBetWhereInput
    orderBy?: CrashBetOrderByWithRelationInput | CrashBetOrderByWithRelationInput[]
    cursor?: CrashBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrashBetScalarFieldEnum | CrashBetScalarFieldEnum[]
  }

  /**
   * User.crashTransactions
   */
  export type User$crashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    where?: CrashTransactionWhereInput
    orderBy?: CrashTransactionOrderByWithRelationInput | CrashTransactionOrderByWithRelationInput[]
    cursor?: CrashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrashTransactionScalarFieldEnum | CrashTransactionScalarFieldEnum[]
  }

  /**
   * User.minesweeperGames
   */
  export type User$minesweeperGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    where?: MinesweeperGameWhereInput
    orderBy?: MinesweeperGameOrderByWithRelationInput | MinesweeperGameOrderByWithRelationInput[]
    cursor?: MinesweeperGameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinesweeperGameScalarFieldEnum | MinesweeperGameScalarFieldEnum[]
  }

  /**
   * User.minesweeperBets
   */
  export type User$minesweeperBetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    where?: MinesweeperBetWhereInput
    orderBy?: MinesweeperBetOrderByWithRelationInput | MinesweeperBetOrderByWithRelationInput[]
    cursor?: MinesweeperBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinesweeperBetScalarFieldEnum | MinesweeperBetScalarFieldEnum[]
  }

  /**
   * User.balances
   */
  export type User$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    cursor?: BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.bets
   */
  export type User$betsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    where?: BetWhereInput
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    cursor?: BetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * User.leaderboardEntries
   */
  export type User$leaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    cursor?: LeaderboardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * User.bonuses
   */
  export type User$bonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    cursor?: UserBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * User.commissions
   */
  export type User$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    where?: ReferralTransactionWhereInput
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    cursor?: ReferralTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * User.referralActions
   */
  export type User$referralActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    where?: ReferralTransactionWhereInput
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    cursor?: ReferralTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * User.authTokens
   */
  export type User$authTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    where?: OneTimeTokenWhereInput
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    cursor?: OneTimeTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OneTimeTokenScalarFieldEnum | OneTimeTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Balance
   */

  export type AggregateBalance = {
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  export type BalanceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type BalanceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type BalanceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    type: $Enums.BalanceType | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalanceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    type: $Enums.BalanceType | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalanceCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    type: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BalanceAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    amount?: true
  }

  export type BalanceSumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    amount?: true
  }

  export type BalanceMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalanceMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalanceCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balance to aggregate.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceMaxAggregateInputType
  }

  export type GetBalanceAggregateType<T extends BalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance[P]>
      : GetScalarType<T[P], AggregateBalance[P]>
  }




  export type BalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithAggregationInput | BalanceOrderByWithAggregationInput[]
    by: BalanceScalarFieldEnum[] | BalanceScalarFieldEnum
    having?: BalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceCountAggregateInputType | true
    _avg?: BalanceAvgAggregateInputType
    _sum?: BalanceSumAggregateInputType
    _min?: BalanceMinAggregateInputType
    _max?: BalanceMaxAggregateInputType
  }

  export type BalanceGroupByOutputType = {
    id: number
    userId: number
    tokenId: number
    type: $Enums.BalanceType
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  type GetBalanceGroupByPayload<T extends BalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceGroupByOutputType[P]>
        }
      >
    >


  export type BalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type BalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $BalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Balance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number
      type: $Enums.BalanceType
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["balance"]>
    composites: {}
  }

  type BalanceGetPayload<S extends boolean | null | undefined | BalanceDefaultArgs> = $Result.GetResult<Prisma.$BalancePayload, S>

  type BalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BalanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BalanceCountAggregateInputType | true
    }

  export interface BalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balance'], meta: { name: 'Balance' } }
    /**
     * Find zero or one Balance that matches the filter.
     * @param {BalanceFindUniqueArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceFindUniqueArgs>(args: SelectSubset<T, BalanceFindUniqueArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Balance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BalanceFindUniqueOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceFindFirstArgs>(args?: SelectSubset<T, BalanceFindFirstArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balance.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceWithIdOnly = await prisma.balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceFindManyArgs>(args?: SelectSubset<T, BalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Balance.
     * @param {BalanceCreateArgs} args - Arguments to create a Balance.
     * @example
     * // Create one Balance
     * const Balance = await prisma.balance.create({
     *   data: {
     *     // ... data to create a Balance
     *   }
     * })
     * 
     */
    create<T extends BalanceCreateArgs>(args: SelectSubset<T, BalanceCreateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Balances.
     * @param {BalanceCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceCreateManyArgs>(args?: SelectSubset<T, BalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balances and returns the data saved in the database.
     * @param {BalanceCreateManyAndReturnArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Balance.
     * @param {BalanceDeleteArgs} args - Arguments to delete one Balance.
     * @example
     * // Delete one Balance
     * const Balance = await prisma.balance.delete({
     *   where: {
     *     // ... filter to delete one Balance
     *   }
     * })
     * 
     */
    delete<T extends BalanceDeleteArgs>(args: SelectSubset<T, BalanceDeleteArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Balance.
     * @param {BalanceUpdateArgs} args - Arguments to update one Balance.
     * @example
     * // Update one Balance
     * const balance = await prisma.balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceUpdateArgs>(args: SelectSubset<T, BalanceUpdateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Balances.
     * @param {BalanceDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceDeleteManyArgs>(args?: SelectSubset<T, BalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceUpdateManyArgs>(args: SelectSubset<T, BalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Balance.
     * @param {BalanceUpsertArgs} args - Arguments to update or create a Balance.
     * @example
     * // Update or create a Balance
     * const balance = await prisma.balance.upsert({
     *   create: {
     *     // ... data to create a Balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance we want to update
     *   }
     * })
     */
    upsert<T extends BalanceUpsertArgs>(args: SelectSubset<T, BalanceUpsertArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balance.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalanceCountArgs>(
      args?: Subset<T, BalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceAggregateArgs>(args: Subset<T, BalanceAggregateArgs>): Prisma.PrismaPromise<GetBalanceAggregateType<T>>

    /**
     * Group by Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceGroupByArgs['orderBy'] }
        : { orderBy?: BalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Balance model
   */
  readonly fields: BalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Balance model
   */ 
  interface BalanceFieldRefs {
    readonly id: FieldRef<"Balance", 'Int'>
    readonly userId: FieldRef<"Balance", 'Int'>
    readonly tokenId: FieldRef<"Balance", 'Int'>
    readonly type: FieldRef<"Balance", 'BalanceType'>
    readonly amount: FieldRef<"Balance", 'Decimal'>
    readonly createdAt: FieldRef<"Balance", 'DateTime'>
    readonly updatedAt: FieldRef<"Balance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Balance findUnique
   */
  export type BalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findUniqueOrThrow
   */
  export type BalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findFirst
   */
  export type BalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findFirstOrThrow
   */
  export type BalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findMany
   */
  export type BalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance create
   */
  export type BalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Balance.
     */
    data: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
  }

  /**
   * Balance createMany
   */
  export type BalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Balance createManyAndReturn
   */
  export type BalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance update
   */
  export type BalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Balance.
     */
    data: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
    /**
     * Choose, which Balance to update.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance updateMany
   */
  export type BalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
  }

  /**
   * Balance upsert
   */
  export type BalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Balance to update in case it exists.
     */
    where: BalanceWhereUniqueInput
    /**
     * In case the Balance found by the `where` argument doesn't exist, create a new Balance with this data.
     */
    create: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
    /**
     * In case the Balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
  }

  /**
   * Balance delete
   */
  export type BalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter which Balance to delete.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance deleteMany
   */
  export type BalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to delete
     */
    where?: BalanceWhereInput
  }

  /**
   * Balance without action
   */
  export type BalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    type: $Enums.TransactionType | null
    status: $Enums.TransactionStatus | null
    amount: Decimal | null
    txHash: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    type: $Enums.TransactionType | null
    status: $Enums.TransactionStatus | null
    amount: Decimal | null
    txHash: string | null
    walletAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    type: number
    status: number
    amount: number
    txHash: number
    walletAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    status?: true
    amount?: true
    txHash?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    status?: true
    amount?: true
    txHash?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    type?: true
    status?: true
    amount?: true
    txHash?: true
    walletAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    userId: number
    tokenId: number
    type: $Enums.TransactionType
    status: $Enums.TransactionStatus
    amount: Decimal
    txHash: string | null
    walletAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    txHash?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    txHash?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    txHash?: boolean
    walletAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number
      type: $Enums.TransactionType
      status: $Enums.TransactionStatus
      amount: Prisma.Decimal
      txHash: string | null
      walletAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly userId: FieldRef<"Transaction", 'Int'>
    readonly tokenId: FieldRef<"Transaction", 'Int'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly txHash: FieldRef<"Transaction", 'String'>
    readonly walletAddress: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Bet
   */

  export type AggregateBet = {
    _count: BetCountAggregateOutputType | null
    _avg: BetAvgAggregateOutputType | null
    _sum: BetSumAggregateOutputType | null
    _min: BetMinAggregateOutputType | null
    _max: BetMaxAggregateOutputType | null
  }

  export type BetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    betAmount: Decimal | null
    payoutAmount: Decimal | null
    netAmount: Decimal | null
    payoutRatio: number | null
  }

  export type BetSumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    betAmount: Decimal | null
    payoutAmount: Decimal | null
    netAmount: Decimal | null
    payoutRatio: number | null
  }

  export type BetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    gameType: $Enums.GameType | null
    betAmount: Decimal | null
    payoutAmount: Decimal | null
    netAmount: Decimal | null
    payoutRatio: number | null
    roundId: string | null
    createdAt: Date | null
  }

  export type BetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    gameType: $Enums.GameType | null
    betAmount: Decimal | null
    payoutAmount: Decimal | null
    netAmount: Decimal | null
    payoutRatio: number | null
    roundId: string | null
    createdAt: Date | null
  }

  export type BetCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    gameType: number
    betAmount: number
    payoutAmount: number
    netAmount: number
    payoutRatio: number
    roundId: number
    details: number
    createdAt: number
    _all: number
  }


  export type BetAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
  }

  export type BetSumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
  }

  export type BetMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameType?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
    roundId?: true
    createdAt?: true
  }

  export type BetMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameType?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
    roundId?: true
    createdAt?: true
  }

  export type BetCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameType?: true
    betAmount?: true
    payoutAmount?: true
    netAmount?: true
    payoutRatio?: true
    roundId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type BetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bet to aggregate.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bets
    **/
    _count?: true | BetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetMaxAggregateInputType
  }

  export type GetBetAggregateType<T extends BetAggregateArgs> = {
        [P in keyof T & keyof AggregateBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBet[P]>
      : GetScalarType<T[P], AggregateBet[P]>
  }




  export type BetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetWhereInput
    orderBy?: BetOrderByWithAggregationInput | BetOrderByWithAggregationInput[]
    by: BetScalarFieldEnum[] | BetScalarFieldEnum
    having?: BetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetCountAggregateInputType | true
    _avg?: BetAvgAggregateInputType
    _sum?: BetSumAggregateInputType
    _min?: BetMinAggregateInputType
    _max?: BetMaxAggregateInputType
  }

  export type BetGroupByOutputType = {
    id: number
    userId: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal
    payoutAmount: Decimal
    netAmount: Decimal
    payoutRatio: number
    roundId: string
    details: JsonValue | null
    createdAt: Date
    _count: BetCountAggregateOutputType | null
    _avg: BetAvgAggregateOutputType | null
    _sum: BetSumAggregateOutputType | null
    _min: BetMinAggregateOutputType | null
    _max: BetMaxAggregateOutputType | null
  }

  type GetBetGroupByPayload<T extends BetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetGroupByOutputType[P]>
            : GetScalarType<T[P], BetGroupByOutputType[P]>
        }
      >
    >


  export type BetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameType?: boolean
    betAmount?: boolean
    payoutAmount?: boolean
    netAmount?: boolean
    payoutRatio?: boolean
    roundId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bet"]>

  export type BetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameType?: boolean
    betAmount?: boolean
    payoutAmount?: boolean
    netAmount?: boolean
    payoutRatio?: boolean
    roundId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bet"]>

  export type BetSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameType?: boolean
    betAmount?: boolean
    payoutAmount?: boolean
    netAmount?: boolean
    payoutRatio?: boolean
    roundId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type BetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type BetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $BetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number
      gameType: $Enums.GameType
      betAmount: Prisma.Decimal
      payoutAmount: Prisma.Decimal
      netAmount: Prisma.Decimal
      payoutRatio: number
      roundId: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["bet"]>
    composites: {}
  }

  type BetGetPayload<S extends boolean | null | undefined | BetDefaultArgs> = $Result.GetResult<Prisma.$BetPayload, S>

  type BetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BetCountAggregateInputType | true
    }

  export interface BetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bet'], meta: { name: 'Bet' } }
    /**
     * Find zero or one Bet that matches the filter.
     * @param {BetFindUniqueArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetFindUniqueArgs>(args: SelectSubset<T, BetFindUniqueArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BetFindUniqueOrThrowArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetFindUniqueOrThrowArgs>(args: SelectSubset<T, BetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindFirstArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetFindFirstArgs>(args?: SelectSubset<T, BetFindFirstArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindFirstOrThrowArgs} args - Arguments to find a Bet
     * @example
     * // Get one Bet
     * const bet = await prisma.bet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetFindFirstOrThrowArgs>(args?: SelectSubset<T, BetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bets
     * const bets = await prisma.bet.findMany()
     * 
     * // Get first 10 Bets
     * const bets = await prisma.bet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betWithIdOnly = await prisma.bet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetFindManyArgs>(args?: SelectSubset<T, BetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bet.
     * @param {BetCreateArgs} args - Arguments to create a Bet.
     * @example
     * // Create one Bet
     * const Bet = await prisma.bet.create({
     *   data: {
     *     // ... data to create a Bet
     *   }
     * })
     * 
     */
    create<T extends BetCreateArgs>(args: SelectSubset<T, BetCreateArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bets.
     * @param {BetCreateManyArgs} args - Arguments to create many Bets.
     * @example
     * // Create many Bets
     * const bet = await prisma.bet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetCreateManyArgs>(args?: SelectSubset<T, BetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bets and returns the data saved in the database.
     * @param {BetCreateManyAndReturnArgs} args - Arguments to create many Bets.
     * @example
     * // Create many Bets
     * const bet = await prisma.bet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bets and only return the `id`
     * const betWithIdOnly = await prisma.bet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetCreateManyAndReturnArgs>(args?: SelectSubset<T, BetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bet.
     * @param {BetDeleteArgs} args - Arguments to delete one Bet.
     * @example
     * // Delete one Bet
     * const Bet = await prisma.bet.delete({
     *   where: {
     *     // ... filter to delete one Bet
     *   }
     * })
     * 
     */
    delete<T extends BetDeleteArgs>(args: SelectSubset<T, BetDeleteArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bet.
     * @param {BetUpdateArgs} args - Arguments to update one Bet.
     * @example
     * // Update one Bet
     * const bet = await prisma.bet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetUpdateArgs>(args: SelectSubset<T, BetUpdateArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bets.
     * @param {BetDeleteManyArgs} args - Arguments to filter Bets to delete.
     * @example
     * // Delete a few Bets
     * const { count } = await prisma.bet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetDeleteManyArgs>(args?: SelectSubset<T, BetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bets
     * const bet = await prisma.bet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetUpdateManyArgs>(args: SelectSubset<T, BetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bet.
     * @param {BetUpsertArgs} args - Arguments to update or create a Bet.
     * @example
     * // Update or create a Bet
     * const bet = await prisma.bet.upsert({
     *   create: {
     *     // ... data to create a Bet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bet we want to update
     *   }
     * })
     */
    upsert<T extends BetUpsertArgs>(args: SelectSubset<T, BetUpsertArgs<ExtArgs>>): Prisma__BetClient<$Result.GetResult<Prisma.$BetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetCountArgs} args - Arguments to filter Bets to count.
     * @example
     * // Count the number of Bets
     * const count = await prisma.bet.count({
     *   where: {
     *     // ... the filter for the Bets we want to count
     *   }
     * })
    **/
    count<T extends BetCountArgs>(
      args?: Subset<T, BetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetAggregateArgs>(args: Subset<T, BetAggregateArgs>): Prisma.PrismaPromise<GetBetAggregateType<T>>

    /**
     * Group by Bet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetGroupByArgs['orderBy'] }
        : { orderBy?: BetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bet model
   */
  readonly fields: BetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bet model
   */ 
  interface BetFieldRefs {
    readonly id: FieldRef<"Bet", 'Int'>
    readonly userId: FieldRef<"Bet", 'Int'>
    readonly tokenId: FieldRef<"Bet", 'Int'>
    readonly gameType: FieldRef<"Bet", 'GameType'>
    readonly betAmount: FieldRef<"Bet", 'Decimal'>
    readonly payoutAmount: FieldRef<"Bet", 'Decimal'>
    readonly netAmount: FieldRef<"Bet", 'Decimal'>
    readonly payoutRatio: FieldRef<"Bet", 'Float'>
    readonly roundId: FieldRef<"Bet", 'String'>
    readonly details: FieldRef<"Bet", 'Json'>
    readonly createdAt: FieldRef<"Bet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bet findUnique
   */
  export type BetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet findUniqueOrThrow
   */
  export type BetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet findFirst
   */
  export type BetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bets.
     */
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet findFirstOrThrow
   */
  export type BetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bet to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bets.
     */
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet findMany
   */
  export type BetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter, which Bets to fetch.
     */
    where?: BetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bets to fetch.
     */
    orderBy?: BetOrderByWithRelationInput | BetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bets.
     */
    cursor?: BetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bets.
     */
    skip?: number
    distinct?: BetScalarFieldEnum | BetScalarFieldEnum[]
  }

  /**
   * Bet create
   */
  export type BetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The data needed to create a Bet.
     */
    data: XOR<BetCreateInput, BetUncheckedCreateInput>
  }

  /**
   * Bet createMany
   */
  export type BetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bets.
     */
    data: BetCreateManyInput | BetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bet createManyAndReturn
   */
  export type BetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bets.
     */
    data: BetCreateManyInput | BetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bet update
   */
  export type BetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The data needed to update a Bet.
     */
    data: XOR<BetUpdateInput, BetUncheckedUpdateInput>
    /**
     * Choose, which Bet to update.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet updateMany
   */
  export type BetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bets.
     */
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyInput>
    /**
     * Filter which Bets to update
     */
    where?: BetWhereInput
  }

  /**
   * Bet upsert
   */
  export type BetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * The filter to search for the Bet to update in case it exists.
     */
    where: BetWhereUniqueInput
    /**
     * In case the Bet found by the `where` argument doesn't exist, create a new Bet with this data.
     */
    create: XOR<BetCreateInput, BetUncheckedCreateInput>
    /**
     * In case the Bet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetUpdateInput, BetUncheckedUpdateInput>
  }

  /**
   * Bet delete
   */
  export type BetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
    /**
     * Filter which Bet to delete.
     */
    where: BetWhereUniqueInput
  }

  /**
   * Bet deleteMany
   */
  export type BetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bets to delete
     */
    where?: BetWhereInput
  }

  /**
   * Bet without action
   */
  export type BetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bet
     */
    select?: BetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetInclude<ExtArgs> | null
  }


  /**
   * Model Bonus
   */

  export type AggregateBonus = {
    _count: BonusCountAggregateOutputType | null
    _avg: BonusAvgAggregateOutputType | null
    _sum: BonusSumAggregateOutputType | null
    _min: BonusMinAggregateOutputType | null
    _max: BonusMaxAggregateOutputType | null
  }

  export type BonusAvgAggregateOutputType = {
    id: number | null
    wageringMultiplier: number | null
    maxBonusAmount: Decimal | null
  }

  export type BonusSumAggregateOutputType = {
    id: number | null
    wageringMultiplier: number | null
    maxBonusAmount: Decimal | null
  }

  export type BonusMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    wageringMultiplier: number | null
    maxBonusAmount: Decimal | null
  }

  export type BonusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    wageringMultiplier: number | null
    maxBonusAmount: Decimal | null
  }

  export type BonusCountAggregateOutputType = {
    id: number
    name: number
    description: number
    wageringMultiplier: number
    maxBonusAmount: number
    _all: number
  }


  export type BonusAvgAggregateInputType = {
    id?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
  }

  export type BonusSumAggregateInputType = {
    id?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
  }

  export type BonusMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
  }

  export type BonusMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
  }

  export type BonusCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    wageringMultiplier?: true
    maxBonusAmount?: true
    _all?: true
  }

  export type BonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonus to aggregate.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bonuses
    **/
    _count?: true | BonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BonusMaxAggregateInputType
  }

  export type GetBonusAggregateType<T extends BonusAggregateArgs> = {
        [P in keyof T & keyof AggregateBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBonus[P]>
      : GetScalarType<T[P], AggregateBonus[P]>
  }




  export type BonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithAggregationInput | BonusOrderByWithAggregationInput[]
    by: BonusScalarFieldEnum[] | BonusScalarFieldEnum
    having?: BonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BonusCountAggregateInputType | true
    _avg?: BonusAvgAggregateInputType
    _sum?: BonusSumAggregateInputType
    _min?: BonusMinAggregateInputType
    _max?: BonusMaxAggregateInputType
  }

  export type BonusGroupByOutputType = {
    id: number
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal
    _count: BonusCountAggregateOutputType | null
    _avg: BonusAvgAggregateOutputType | null
    _sum: BonusSumAggregateOutputType | null
    _min: BonusMinAggregateOutputType | null
    _max: BonusMaxAggregateOutputType | null
  }

  type GetBonusGroupByPayload<T extends BonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BonusGroupByOutputType[P]>
            : GetScalarType<T[P], BonusGroupByOutputType[P]>
        }
      >
    >


  export type BonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    wageringMultiplier?: boolean
    maxBonusAmount?: boolean
    userBonuses?: boolean | Bonus$userBonusesArgs<ExtArgs>
    _count?: boolean | BonusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    wageringMultiplier?: boolean
    maxBonusAmount?: boolean
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    wageringMultiplier?: boolean
    maxBonusAmount?: boolean
  }

  export type BonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userBonuses?: boolean | Bonus$userBonusesArgs<ExtArgs>
    _count?: boolean | BonusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bonus"
    objects: {
      userBonuses: Prisma.$UserBonusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      wageringMultiplier: number
      maxBonusAmount: Prisma.Decimal
    }, ExtArgs["result"]["bonus"]>
    composites: {}
  }

  type BonusGetPayload<S extends boolean | null | undefined | BonusDefaultArgs> = $Result.GetResult<Prisma.$BonusPayload, S>

  type BonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BonusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BonusCountAggregateInputType | true
    }

  export interface BonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bonus'], meta: { name: 'Bonus' } }
    /**
     * Find zero or one Bonus that matches the filter.
     * @param {BonusFindUniqueArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BonusFindUniqueArgs>(args: SelectSubset<T, BonusFindUniqueArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bonus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BonusFindUniqueOrThrowArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BonusFindUniqueOrThrowArgs>(args: SelectSubset<T, BonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindFirstArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BonusFindFirstArgs>(args?: SelectSubset<T, BonusFindFirstArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindFirstOrThrowArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BonusFindFirstOrThrowArgs>(args?: SelectSubset<T, BonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bonuses
     * const bonuses = await prisma.bonus.findMany()
     * 
     * // Get first 10 Bonuses
     * const bonuses = await prisma.bonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bonusWithIdOnly = await prisma.bonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BonusFindManyArgs>(args?: SelectSubset<T, BonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bonus.
     * @param {BonusCreateArgs} args - Arguments to create a Bonus.
     * @example
     * // Create one Bonus
     * const Bonus = await prisma.bonus.create({
     *   data: {
     *     // ... data to create a Bonus
     *   }
     * })
     * 
     */
    create<T extends BonusCreateArgs>(args: SelectSubset<T, BonusCreateArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bonuses.
     * @param {BonusCreateManyArgs} args - Arguments to create many Bonuses.
     * @example
     * // Create many Bonuses
     * const bonus = await prisma.bonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BonusCreateManyArgs>(args?: SelectSubset<T, BonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bonuses and returns the data saved in the database.
     * @param {BonusCreateManyAndReturnArgs} args - Arguments to create many Bonuses.
     * @example
     * // Create many Bonuses
     * const bonus = await prisma.bonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bonuses and only return the `id`
     * const bonusWithIdOnly = await prisma.bonus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BonusCreateManyAndReturnArgs>(args?: SelectSubset<T, BonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bonus.
     * @param {BonusDeleteArgs} args - Arguments to delete one Bonus.
     * @example
     * // Delete one Bonus
     * const Bonus = await prisma.bonus.delete({
     *   where: {
     *     // ... filter to delete one Bonus
     *   }
     * })
     * 
     */
    delete<T extends BonusDeleteArgs>(args: SelectSubset<T, BonusDeleteArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bonus.
     * @param {BonusUpdateArgs} args - Arguments to update one Bonus.
     * @example
     * // Update one Bonus
     * const bonus = await prisma.bonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BonusUpdateArgs>(args: SelectSubset<T, BonusUpdateArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bonuses.
     * @param {BonusDeleteManyArgs} args - Arguments to filter Bonuses to delete.
     * @example
     * // Delete a few Bonuses
     * const { count } = await prisma.bonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BonusDeleteManyArgs>(args?: SelectSubset<T, BonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bonuses
     * const bonus = await prisma.bonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BonusUpdateManyArgs>(args: SelectSubset<T, BonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bonus.
     * @param {BonusUpsertArgs} args - Arguments to update or create a Bonus.
     * @example
     * // Update or create a Bonus
     * const bonus = await prisma.bonus.upsert({
     *   create: {
     *     // ... data to create a Bonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bonus we want to update
     *   }
     * })
     */
    upsert<T extends BonusUpsertArgs>(args: SelectSubset<T, BonusUpsertArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusCountArgs} args - Arguments to filter Bonuses to count.
     * @example
     * // Count the number of Bonuses
     * const count = await prisma.bonus.count({
     *   where: {
     *     // ... the filter for the Bonuses we want to count
     *   }
     * })
    **/
    count<T extends BonusCountArgs>(
      args?: Subset<T, BonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BonusAggregateArgs>(args: Subset<T, BonusAggregateArgs>): Prisma.PrismaPromise<GetBonusAggregateType<T>>

    /**
     * Group by Bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BonusGroupByArgs['orderBy'] }
        : { orderBy?: BonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bonus model
   */
  readonly fields: BonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userBonuses<T extends Bonus$userBonusesArgs<ExtArgs> = {}>(args?: Subset<T, Bonus$userBonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bonus model
   */ 
  interface BonusFieldRefs {
    readonly id: FieldRef<"Bonus", 'Int'>
    readonly name: FieldRef<"Bonus", 'String'>
    readonly description: FieldRef<"Bonus", 'String'>
    readonly wageringMultiplier: FieldRef<"Bonus", 'Float'>
    readonly maxBonusAmount: FieldRef<"Bonus", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Bonus findUnique
   */
  export type BonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus findUniqueOrThrow
   */
  export type BonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus findFirst
   */
  export type BonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonuses.
     */
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus findFirstOrThrow
   */
  export type BonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonuses.
     */
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus findMany
   */
  export type BonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonuses to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus create
   */
  export type BonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The data needed to create a Bonus.
     */
    data: XOR<BonusCreateInput, BonusUncheckedCreateInput>
  }

  /**
   * Bonus createMany
   */
  export type BonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bonuses.
     */
    data: BonusCreateManyInput | BonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bonus createManyAndReturn
   */
  export type BonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bonuses.
     */
    data: BonusCreateManyInput | BonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bonus update
   */
  export type BonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The data needed to update a Bonus.
     */
    data: XOR<BonusUpdateInput, BonusUncheckedUpdateInput>
    /**
     * Choose, which Bonus to update.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus updateMany
   */
  export type BonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bonuses.
     */
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyInput>
    /**
     * Filter which Bonuses to update
     */
    where?: BonusWhereInput
  }

  /**
   * Bonus upsert
   */
  export type BonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The filter to search for the Bonus to update in case it exists.
     */
    where: BonusWhereUniqueInput
    /**
     * In case the Bonus found by the `where` argument doesn't exist, create a new Bonus with this data.
     */
    create: XOR<BonusCreateInput, BonusUncheckedCreateInput>
    /**
     * In case the Bonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BonusUpdateInput, BonusUncheckedUpdateInput>
  }

  /**
   * Bonus delete
   */
  export type BonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter which Bonus to delete.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus deleteMany
   */
  export type BonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonuses to delete
     */
    where?: BonusWhereInput
  }

  /**
   * Bonus.userBonuses
   */
  export type Bonus$userBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    cursor?: UserBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * Bonus without action
   */
  export type BonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
  }


  /**
   * Model UserBonus
   */

  export type AggregateUserBonus = {
    _count: UserBonusCountAggregateOutputType | null
    _avg: UserBonusAvgAggregateOutputType | null
    _sum: UserBonusSumAggregateOutputType | null
    _min: UserBonusMinAggregateOutputType | null
    _max: UserBonusMaxAggregateOutputType | null
  }

  export type UserBonusAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    bonusId: number | null
    tokenId: number | null
    grantedAmount: Decimal | null
    requiredWager: Decimal | null
    wageredAmount: Decimal | null
  }

  export type UserBonusSumAggregateOutputType = {
    id: number | null
    userId: number | null
    bonusId: number | null
    tokenId: number | null
    grantedAmount: Decimal | null
    requiredWager: Decimal | null
    wageredAmount: Decimal | null
  }

  export type UserBonusMinAggregateOutputType = {
    id: number | null
    userId: number | null
    bonusId: number | null
    tokenId: number | null
    grantedAmount: Decimal | null
    requiredWager: Decimal | null
    wageredAmount: Decimal | null
    isActive: boolean | null
    isCompleted: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type UserBonusMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    bonusId: number | null
    tokenId: number | null
    grantedAmount: Decimal | null
    requiredWager: Decimal | null
    wageredAmount: Decimal | null
    isActive: boolean | null
    isCompleted: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type UserBonusCountAggregateOutputType = {
    id: number
    userId: number
    bonusId: number
    tokenId: number
    grantedAmount: number
    requiredWager: number
    wageredAmount: number
    isActive: number
    isCompleted: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type UserBonusAvgAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
  }

  export type UserBonusSumAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
  }

  export type UserBonusMinAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
    isActive?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
  }

  export type UserBonusMaxAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
    isActive?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
  }

  export type UserBonusCountAggregateInputType = {
    id?: true
    userId?: true
    bonusId?: true
    tokenId?: true
    grantedAmount?: true
    requiredWager?: true
    wageredAmount?: true
    isActive?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type UserBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBonus to aggregate.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBonuses
    **/
    _count?: true | UserBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBonusMaxAggregateInputType
  }

  export type GetUserBonusAggregateType<T extends UserBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBonus[P]>
      : GetScalarType<T[P], AggregateUserBonus[P]>
  }




  export type UserBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBonusWhereInput
    orderBy?: UserBonusOrderByWithAggregationInput | UserBonusOrderByWithAggregationInput[]
    by: UserBonusScalarFieldEnum[] | UserBonusScalarFieldEnum
    having?: UserBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBonusCountAggregateInputType | true
    _avg?: UserBonusAvgAggregateInputType
    _sum?: UserBonusSumAggregateInputType
    _min?: UserBonusMinAggregateInputType
    _max?: UserBonusMaxAggregateInputType
  }

  export type UserBonusGroupByOutputType = {
    id: number
    userId: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal
    requiredWager: Decimal
    wageredAmount: Decimal
    isActive: boolean
    isCompleted: boolean
    createdAt: Date
    expiresAt: Date | null
    _count: UserBonusCountAggregateOutputType | null
    _avg: UserBonusAvgAggregateOutputType | null
    _sum: UserBonusSumAggregateOutputType | null
    _min: UserBonusMinAggregateOutputType | null
    _max: UserBonusMaxAggregateOutputType | null
  }

  type GetUserBonusGroupByPayload<T extends UserBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBonusGroupByOutputType[P]>
            : GetScalarType<T[P], UserBonusGroupByOutputType[P]>
        }
      >
    >


  export type UserBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bonusId?: boolean
    tokenId?: boolean
    grantedAmount?: boolean
    requiredWager?: boolean
    wageredAmount?: boolean
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBonus"]>

  export type UserBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bonusId?: boolean
    tokenId?: boolean
    grantedAmount?: boolean
    requiredWager?: boolean
    wageredAmount?: boolean
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBonus"]>

  export type UserBonusSelectScalar = {
    id?: boolean
    userId?: boolean
    bonusId?: boolean
    tokenId?: boolean
    grantedAmount?: boolean
    requiredWager?: boolean
    wageredAmount?: boolean
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type UserBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type UserBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $UserBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBonus"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bonus: Prisma.$BonusPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      bonusId: number
      tokenId: number
      grantedAmount: Prisma.Decimal
      requiredWager: Prisma.Decimal
      wageredAmount: Prisma.Decimal
      isActive: boolean
      isCompleted: boolean
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["userBonus"]>
    composites: {}
  }

  type UserBonusGetPayload<S extends boolean | null | undefined | UserBonusDefaultArgs> = $Result.GetResult<Prisma.$UserBonusPayload, S>

  type UserBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBonusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBonusCountAggregateInputType | true
    }

  export interface UserBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBonus'], meta: { name: 'UserBonus' } }
    /**
     * Find zero or one UserBonus that matches the filter.
     * @param {UserBonusFindUniqueArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBonusFindUniqueArgs>(args: SelectSubset<T, UserBonusFindUniqueArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBonus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBonusFindUniqueOrThrowArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindFirstArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBonusFindFirstArgs>(args?: SelectSubset<T, UserBonusFindFirstArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindFirstOrThrowArgs} args - Arguments to find a UserBonus
     * @example
     * // Get one UserBonus
     * const userBonus = await prisma.userBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBonuses
     * const userBonuses = await prisma.userBonus.findMany()
     * 
     * // Get first 10 UserBonuses
     * const userBonuses = await prisma.userBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBonusWithIdOnly = await prisma.userBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBonusFindManyArgs>(args?: SelectSubset<T, UserBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBonus.
     * @param {UserBonusCreateArgs} args - Arguments to create a UserBonus.
     * @example
     * // Create one UserBonus
     * const UserBonus = await prisma.userBonus.create({
     *   data: {
     *     // ... data to create a UserBonus
     *   }
     * })
     * 
     */
    create<T extends UserBonusCreateArgs>(args: SelectSubset<T, UserBonusCreateArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBonuses.
     * @param {UserBonusCreateManyArgs} args - Arguments to create many UserBonuses.
     * @example
     * // Create many UserBonuses
     * const userBonus = await prisma.userBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBonusCreateManyArgs>(args?: SelectSubset<T, UserBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBonuses and returns the data saved in the database.
     * @param {UserBonusCreateManyAndReturnArgs} args - Arguments to create many UserBonuses.
     * @example
     * // Create many UserBonuses
     * const userBonus = await prisma.userBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBonuses and only return the `id`
     * const userBonusWithIdOnly = await prisma.userBonus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBonus.
     * @param {UserBonusDeleteArgs} args - Arguments to delete one UserBonus.
     * @example
     * // Delete one UserBonus
     * const UserBonus = await prisma.userBonus.delete({
     *   where: {
     *     // ... filter to delete one UserBonus
     *   }
     * })
     * 
     */
    delete<T extends UserBonusDeleteArgs>(args: SelectSubset<T, UserBonusDeleteArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBonus.
     * @param {UserBonusUpdateArgs} args - Arguments to update one UserBonus.
     * @example
     * // Update one UserBonus
     * const userBonus = await prisma.userBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBonusUpdateArgs>(args: SelectSubset<T, UserBonusUpdateArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBonuses.
     * @param {UserBonusDeleteManyArgs} args - Arguments to filter UserBonuses to delete.
     * @example
     * // Delete a few UserBonuses
     * const { count } = await prisma.userBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBonusDeleteManyArgs>(args?: SelectSubset<T, UserBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBonuses
     * const userBonus = await prisma.userBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBonusUpdateManyArgs>(args: SelectSubset<T, UserBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBonus.
     * @param {UserBonusUpsertArgs} args - Arguments to update or create a UserBonus.
     * @example
     * // Update or create a UserBonus
     * const userBonus = await prisma.userBonus.upsert({
     *   create: {
     *     // ... data to create a UserBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBonus we want to update
     *   }
     * })
     */
    upsert<T extends UserBonusUpsertArgs>(args: SelectSubset<T, UserBonusUpsertArgs<ExtArgs>>): Prisma__UserBonusClient<$Result.GetResult<Prisma.$UserBonusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusCountArgs} args - Arguments to filter UserBonuses to count.
     * @example
     * // Count the number of UserBonuses
     * const count = await prisma.userBonus.count({
     *   where: {
     *     // ... the filter for the UserBonuses we want to count
     *   }
     * })
    **/
    count<T extends UserBonusCountArgs>(
      args?: Subset<T, UserBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBonusAggregateArgs>(args: Subset<T, UserBonusAggregateArgs>): Prisma.PrismaPromise<GetUserBonusAggregateType<T>>

    /**
     * Group by UserBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBonusGroupByArgs['orderBy'] }
        : { orderBy?: UserBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBonus model
   */
  readonly fields: UserBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bonus<T extends BonusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BonusDefaultArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBonus model
   */ 
  interface UserBonusFieldRefs {
    readonly id: FieldRef<"UserBonus", 'Int'>
    readonly userId: FieldRef<"UserBonus", 'Int'>
    readonly bonusId: FieldRef<"UserBonus", 'Int'>
    readonly tokenId: FieldRef<"UserBonus", 'Int'>
    readonly grantedAmount: FieldRef<"UserBonus", 'Decimal'>
    readonly requiredWager: FieldRef<"UserBonus", 'Decimal'>
    readonly wageredAmount: FieldRef<"UserBonus", 'Decimal'>
    readonly isActive: FieldRef<"UserBonus", 'Boolean'>
    readonly isCompleted: FieldRef<"UserBonus", 'Boolean'>
    readonly createdAt: FieldRef<"UserBonus", 'DateTime'>
    readonly expiresAt: FieldRef<"UserBonus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBonus findUnique
   */
  export type UserBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus findUniqueOrThrow
   */
  export type UserBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus findFirst
   */
  export type UserBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBonuses.
     */
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus findFirstOrThrow
   */
  export type UserBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonus to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBonuses.
     */
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus findMany
   */
  export type UserBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserBonuses to fetch.
     */
    where?: UserBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBonuses to fetch.
     */
    orderBy?: UserBonusOrderByWithRelationInput | UserBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBonuses.
     */
    cursor?: UserBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBonuses.
     */
    skip?: number
    distinct?: UserBonusScalarFieldEnum | UserBonusScalarFieldEnum[]
  }

  /**
   * UserBonus create
   */
  export type UserBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBonus.
     */
    data: XOR<UserBonusCreateInput, UserBonusUncheckedCreateInput>
  }

  /**
   * UserBonus createMany
   */
  export type UserBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBonuses.
     */
    data: UserBonusCreateManyInput | UserBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBonus createManyAndReturn
   */
  export type UserBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBonuses.
     */
    data: UserBonusCreateManyInput | UserBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBonus update
   */
  export type UserBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBonus.
     */
    data: XOR<UserBonusUpdateInput, UserBonusUncheckedUpdateInput>
    /**
     * Choose, which UserBonus to update.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus updateMany
   */
  export type UserBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBonuses.
     */
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyInput>
    /**
     * Filter which UserBonuses to update
     */
    where?: UserBonusWhereInput
  }

  /**
   * UserBonus upsert
   */
  export type UserBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBonus to update in case it exists.
     */
    where: UserBonusWhereUniqueInput
    /**
     * In case the UserBonus found by the `where` argument doesn't exist, create a new UserBonus with this data.
     */
    create: XOR<UserBonusCreateInput, UserBonusUncheckedCreateInput>
    /**
     * In case the UserBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBonusUpdateInput, UserBonusUncheckedUpdateInput>
  }

  /**
   * UserBonus delete
   */
  export type UserBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
    /**
     * Filter which UserBonus to delete.
     */
    where: UserBonusWhereUniqueInput
  }

  /**
   * UserBonus deleteMany
   */
  export type UserBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBonuses to delete
     */
    where?: UserBonusWhereInput
  }

  /**
   * UserBonus without action
   */
  export type UserBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBonus
     */
    select?: UserBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBonusInclude<ExtArgs> | null
  }


  /**
   * Model LeaderboardEntry
   */

  export type AggregateLeaderboardEntry = {
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  export type LeaderboardEntryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    score: Decimal | null
  }

  export type LeaderboardEntrySumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    score: Decimal | null
  }

  export type LeaderboardEntryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    metric: string | null
    score: Decimal | null
    period: string | null
    updatedAt: Date | null
  }

  export type LeaderboardEntryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    metric: string | null
    score: Decimal | null
    period: string | null
    updatedAt: Date | null
  }

  export type LeaderboardEntryCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    metric: number
    score: number
    period: number
    updatedAt: number
    _all: number
  }


  export type LeaderboardEntryAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    score?: true
  }

  export type LeaderboardEntrySumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    score?: true
  }

  export type LeaderboardEntryMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    metric?: true
    score?: true
    period?: true
    updatedAt?: true
  }

  export type LeaderboardEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    metric?: true
    score?: true
    period?: true
    updatedAt?: true
  }

  export type LeaderboardEntryCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    metric?: true
    score?: true
    period?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaderboardEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntry to aggregate.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderboardEntries
    **/
    _count?: true | LeaderboardEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type GetLeaderboardEntryAggregateType<T extends LeaderboardEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboardEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
      : GetScalarType<T[P], AggregateLeaderboardEntry[P]>
  }




  export type LeaderboardEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardEntryWhereInput
    orderBy?: LeaderboardEntryOrderByWithAggregationInput | LeaderboardEntryOrderByWithAggregationInput[]
    by: LeaderboardEntryScalarFieldEnum[] | LeaderboardEntryScalarFieldEnum
    having?: LeaderboardEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardEntryCountAggregateInputType | true
    _avg?: LeaderboardEntryAvgAggregateInputType
    _sum?: LeaderboardEntrySumAggregateInputType
    _min?: LeaderboardEntryMinAggregateInputType
    _max?: LeaderboardEntryMaxAggregateInputType
  }

  export type LeaderboardEntryGroupByOutputType = {
    id: number
    userId: number
    tokenId: number | null
    metric: string
    score: Decimal
    period: string
    updatedAt: Date
    _count: LeaderboardEntryCountAggregateOutputType | null
    _avg: LeaderboardEntryAvgAggregateOutputType | null
    _sum: LeaderboardEntrySumAggregateOutputType | null
    _min: LeaderboardEntryMinAggregateOutputType | null
    _max: LeaderboardEntryMaxAggregateOutputType | null
  }

  type GetLeaderboardEntryGroupByPayload<T extends LeaderboardEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardEntryGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    metric?: boolean
    score?: boolean
    period?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | LeaderboardEntry$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    metric?: boolean
    score?: boolean
    period?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | LeaderboardEntry$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardEntry"]>

  export type LeaderboardEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    metric?: boolean
    score?: boolean
    period?: boolean
    updatedAt?: boolean
  }

  export type LeaderboardEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | LeaderboardEntry$tokenArgs<ExtArgs>
  }
  export type LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | LeaderboardEntry$tokenArgs<ExtArgs>
  }

  export type $LeaderboardEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderboardEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number | null
      metric: string
      score: Prisma.Decimal
      period: string
      updatedAt: Date
    }, ExtArgs["result"]["leaderboardEntry"]>
    composites: {}
  }

  type LeaderboardEntryGetPayload<S extends boolean | null | undefined | LeaderboardEntryDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardEntryPayload, S>

  type LeaderboardEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaderboardEntryCountAggregateInputType | true
    }

  export interface LeaderboardEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardEntry'], meta: { name: 'LeaderboardEntry' } }
    /**
     * Find zero or one LeaderboardEntry that matches the filter.
     * @param {LeaderboardEntryFindUniqueArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardEntryFindUniqueArgs>(args: SelectSubset<T, LeaderboardEntryFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaderboardEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaderboardEntryFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaderboardEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardEntryFindFirstArgs>(args?: SelectSubset<T, LeaderboardEntryFindFirstArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaderboardEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindFirstOrThrowArgs} args - Arguments to find a LeaderboardEntry
     * @example
     * // Get one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaderboardEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany()
     * 
     * // Get first 10 LeaderboardEntries
     * const leaderboardEntries = await prisma.leaderboardEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaderboardEntryFindManyArgs>(args?: SelectSubset<T, LeaderboardEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaderboardEntry.
     * @param {LeaderboardEntryCreateArgs} args - Arguments to create a LeaderboardEntry.
     * @example
     * // Create one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.create({
     *   data: {
     *     // ... data to create a LeaderboardEntry
     *   }
     * })
     * 
     */
    create<T extends LeaderboardEntryCreateArgs>(args: SelectSubset<T, LeaderboardEntryCreateArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaderboardEntries.
     * @param {LeaderboardEntryCreateManyArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardEntryCreateManyArgs>(args?: SelectSubset<T, LeaderboardEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaderboardEntries and returns the data saved in the database.
     * @param {LeaderboardEntryCreateManyAndReturnArgs} args - Arguments to create many LeaderboardEntries.
     * @example
     * // Create many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaderboardEntries and only return the `id`
     * const leaderboardEntryWithIdOnly = await prisma.leaderboardEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderboardEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderboardEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaderboardEntry.
     * @param {LeaderboardEntryDeleteArgs} args - Arguments to delete one LeaderboardEntry.
     * @example
     * // Delete one LeaderboardEntry
     * const LeaderboardEntry = await prisma.leaderboardEntry.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardEntry
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardEntryDeleteArgs>(args: SelectSubset<T, LeaderboardEntryDeleteArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaderboardEntry.
     * @param {LeaderboardEntryUpdateArgs} args - Arguments to update one LeaderboardEntry.
     * @example
     * // Update one LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardEntryUpdateArgs>(args: SelectSubset<T, LeaderboardEntryUpdateArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaderboardEntries.
     * @param {LeaderboardEntryDeleteManyArgs} args - Arguments to filter LeaderboardEntries to delete.
     * @example
     * // Delete a few LeaderboardEntries
     * const { count } = await prisma.leaderboardEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardEntryDeleteManyArgs>(args?: SelectSubset<T, LeaderboardEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardEntries
     * const leaderboardEntry = await prisma.leaderboardEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardEntryUpdateManyArgs>(args: SelectSubset<T, LeaderboardEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaderboardEntry.
     * @param {LeaderboardEntryUpsertArgs} args - Arguments to update or create a LeaderboardEntry.
     * @example
     * // Update or create a LeaderboardEntry
     * const leaderboardEntry = await prisma.leaderboardEntry.upsert({
     *   create: {
     *     // ... data to create a LeaderboardEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardEntry we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardEntryUpsertArgs>(args: SelectSubset<T, LeaderboardEntryUpsertArgs<ExtArgs>>): Prisma__LeaderboardEntryClient<$Result.GetResult<Prisma.$LeaderboardEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaderboardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryCountArgs} args - Arguments to filter LeaderboardEntries to count.
     * @example
     * // Count the number of LeaderboardEntries
     * const count = await prisma.leaderboardEntry.count({
     *   where: {
     *     // ... the filter for the LeaderboardEntries we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardEntryCountArgs>(
      args?: Subset<T, LeaderboardEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardEntryAggregateArgs>(args: Subset<T, LeaderboardEntryAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardEntryAggregateType<T>>

    /**
     * Group by LeaderboardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardEntryGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderboardEntry model
   */
  readonly fields: LeaderboardEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends LeaderboardEntry$tokenArgs<ExtArgs> = {}>(args?: Subset<T, LeaderboardEntry$tokenArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaderboardEntry model
   */ 
  interface LeaderboardEntryFieldRefs {
    readonly id: FieldRef<"LeaderboardEntry", 'Int'>
    readonly userId: FieldRef<"LeaderboardEntry", 'Int'>
    readonly tokenId: FieldRef<"LeaderboardEntry", 'Int'>
    readonly metric: FieldRef<"LeaderboardEntry", 'String'>
    readonly score: FieldRef<"LeaderboardEntry", 'Decimal'>
    readonly period: FieldRef<"LeaderboardEntry", 'String'>
    readonly updatedAt: FieldRef<"LeaderboardEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaderboardEntry findUnique
   */
  export type LeaderboardEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry findUniqueOrThrow
   */
  export type LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry findFirst
   */
  export type LeaderboardEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry findFirstOrThrow
   */
  export type LeaderboardEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntry to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardEntries.
     */
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry findMany
   */
  export type LeaderboardEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardEntries to fetch.
     */
    where?: LeaderboardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardEntries to fetch.
     */
    orderBy?: LeaderboardEntryOrderByWithRelationInput | LeaderboardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderboardEntries.
     */
    cursor?: LeaderboardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardEntries.
     */
    skip?: number
    distinct?: LeaderboardEntryScalarFieldEnum | LeaderboardEntryScalarFieldEnum[]
  }

  /**
   * LeaderboardEntry create
   */
  export type LeaderboardEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
  }

  /**
   * LeaderboardEntry createMany
   */
  export type LeaderboardEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaderboardEntry createManyAndReturn
   */
  export type LeaderboardEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaderboardEntries.
     */
    data: LeaderboardEntryCreateManyInput | LeaderboardEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaderboardEntry update
   */
  export type LeaderboardEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaderboardEntry.
     */
    data: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
    /**
     * Choose, which LeaderboardEntry to update.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry updateMany
   */
  export type LeaderboardEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderboardEntries.
     */
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardEntries to update
     */
    where?: LeaderboardEntryWhereInput
  }

  /**
   * LeaderboardEntry upsert
   */
  export type LeaderboardEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaderboardEntry to update in case it exists.
     */
    where: LeaderboardEntryWhereUniqueInput
    /**
     * In case the LeaderboardEntry found by the `where` argument doesn't exist, create a new LeaderboardEntry with this data.
     */
    create: XOR<LeaderboardEntryCreateInput, LeaderboardEntryUncheckedCreateInput>
    /**
     * In case the LeaderboardEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardEntryUpdateInput, LeaderboardEntryUncheckedUpdateInput>
  }

  /**
   * LeaderboardEntry delete
   */
  export type LeaderboardEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
    /**
     * Filter which LeaderboardEntry to delete.
     */
    where: LeaderboardEntryWhereUniqueInput
  }

  /**
   * LeaderboardEntry deleteMany
   */
  export type LeaderboardEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardEntries to delete
     */
    where?: LeaderboardEntryWhereInput
  }

  /**
   * LeaderboardEntry.token
   */
  export type LeaderboardEntry$tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoToken
     */
    select?: CryptoTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTokenInclude<ExtArgs> | null
    where?: CryptoTokenWhereInput
  }

  /**
   * LeaderboardEntry without action
   */
  export type LeaderboardEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardEntry
     */
    select?: LeaderboardEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardEntryInclude<ExtArgs> | null
  }


  /**
   * Model ReferralTransaction
   */

  export type AggregateReferralTransaction = {
    _count: ReferralTransactionCountAggregateOutputType | null
    _avg: ReferralTransactionAvgAggregateOutputType | null
    _sum: ReferralTransactionSumAggregateOutputType | null
    _min: ReferralTransactionMinAggregateOutputType | null
    _max: ReferralTransactionMaxAggregateOutputType | null
  }

  export type ReferralTransactionAvgAggregateOutputType = {
    id: number | null
    referrerId: number | null
    refereeId: number | null
    tokenId: number | null
    amount: Decimal | null
    sourceEntityId: number | null
  }

  export type ReferralTransactionSumAggregateOutputType = {
    id: number | null
    referrerId: number | null
    refereeId: number | null
    tokenId: number | null
    amount: Decimal | null
    sourceEntityId: number | null
  }

  export type ReferralTransactionMinAggregateOutputType = {
    id: number | null
    referrerId: number | null
    refereeId: number | null
    tokenId: number | null
    eventType: $Enums.ReferralEventType | null
    amount: Decimal | null
    sourceEntityId: number | null
    sourceEntityType: string | null
    createdAt: Date | null
  }

  export type ReferralTransactionMaxAggregateOutputType = {
    id: number | null
    referrerId: number | null
    refereeId: number | null
    tokenId: number | null
    eventType: $Enums.ReferralEventType | null
    amount: Decimal | null
    sourceEntityId: number | null
    sourceEntityType: string | null
    createdAt: Date | null
  }

  export type ReferralTransactionCountAggregateOutputType = {
    id: number
    referrerId: number
    refereeId: number
    tokenId: number
    eventType: number
    amount: number
    sourceEntityId: number
    sourceEntityType: number
    createdAt: number
    _all: number
  }


  export type ReferralTransactionAvgAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    amount?: true
    sourceEntityId?: true
  }

  export type ReferralTransactionSumAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    amount?: true
    sourceEntityId?: true
  }

  export type ReferralTransactionMinAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    eventType?: true
    amount?: true
    sourceEntityId?: true
    sourceEntityType?: true
    createdAt?: true
  }

  export type ReferralTransactionMaxAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    eventType?: true
    amount?: true
    sourceEntityId?: true
    sourceEntityType?: true
    createdAt?: true
  }

  export type ReferralTransactionCountAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    tokenId?: true
    eventType?: true
    amount?: true
    sourceEntityId?: true
    sourceEntityType?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralTransaction to aggregate.
     */
    where?: ReferralTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralTransactions to fetch.
     */
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralTransactions
    **/
    _count?: true | ReferralTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralTransactionMaxAggregateInputType
  }

  export type GetReferralTransactionAggregateType<T extends ReferralTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralTransaction[P]>
      : GetScalarType<T[P], AggregateReferralTransaction[P]>
  }




  export type ReferralTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralTransactionWhereInput
    orderBy?: ReferralTransactionOrderByWithAggregationInput | ReferralTransactionOrderByWithAggregationInput[]
    by: ReferralTransactionScalarFieldEnum[] | ReferralTransactionScalarFieldEnum
    having?: ReferralTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralTransactionCountAggregateInputType | true
    _avg?: ReferralTransactionAvgAggregateInputType
    _sum?: ReferralTransactionSumAggregateInputType
    _min?: ReferralTransactionMinAggregateInputType
    _max?: ReferralTransactionMaxAggregateInputType
  }

  export type ReferralTransactionGroupByOutputType = {
    id: number
    referrerId: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal
    sourceEntityId: number
    sourceEntityType: string
    createdAt: Date
    _count: ReferralTransactionCountAggregateOutputType | null
    _avg: ReferralTransactionAvgAggregateOutputType | null
    _sum: ReferralTransactionSumAggregateOutputType | null
    _min: ReferralTransactionMinAggregateOutputType | null
    _max: ReferralTransactionMaxAggregateOutputType | null
  }

  type GetReferralTransactionGroupByPayload<T extends ReferralTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralTransactionGroupByOutputType[P]>
        }
      >
    >


  export type ReferralTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    tokenId?: boolean
    eventType?: boolean
    amount?: boolean
    sourceEntityId?: boolean
    sourceEntityType?: boolean
    createdAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralTransaction"]>

  export type ReferralTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    tokenId?: boolean
    eventType?: boolean
    amount?: boolean
    sourceEntityId?: boolean
    sourceEntityType?: boolean
    createdAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralTransaction"]>

  export type ReferralTransactionSelectScalar = {
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    tokenId?: boolean
    eventType?: boolean
    amount?: boolean
    sourceEntityId?: boolean
    sourceEntityType?: boolean
    createdAt?: boolean
  }

  export type ReferralTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type ReferralTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $ReferralTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralTransaction"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referee: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      referrerId: number
      refereeId: number
      tokenId: number
      eventType: $Enums.ReferralEventType
      amount: Prisma.Decimal
      sourceEntityId: number
      sourceEntityType: string
      createdAt: Date
    }, ExtArgs["result"]["referralTransaction"]>
    composites: {}
  }

  type ReferralTransactionGetPayload<S extends boolean | null | undefined | ReferralTransactionDefaultArgs> = $Result.GetResult<Prisma.$ReferralTransactionPayload, S>

  type ReferralTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralTransactionCountAggregateInputType | true
    }

  export interface ReferralTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralTransaction'], meta: { name: 'ReferralTransaction' } }
    /**
     * Find zero or one ReferralTransaction that matches the filter.
     * @param {ReferralTransactionFindUniqueArgs} args - Arguments to find a ReferralTransaction
     * @example
     * // Get one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralTransactionFindUniqueArgs>(args: SelectSubset<T, ReferralTransactionFindUniqueArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralTransactionFindUniqueOrThrowArgs} args - Arguments to find a ReferralTransaction
     * @example
     * // Get one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionFindFirstArgs} args - Arguments to find a ReferralTransaction
     * @example
     * // Get one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralTransactionFindFirstArgs>(args?: SelectSubset<T, ReferralTransactionFindFirstArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionFindFirstOrThrowArgs} args - Arguments to find a ReferralTransaction
     * @example
     * // Get one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralTransactions
     * const referralTransactions = await prisma.referralTransaction.findMany()
     * 
     * // Get first 10 ReferralTransactions
     * const referralTransactions = await prisma.referralTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralTransactionWithIdOnly = await prisma.referralTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralTransactionFindManyArgs>(args?: SelectSubset<T, ReferralTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralTransaction.
     * @param {ReferralTransactionCreateArgs} args - Arguments to create a ReferralTransaction.
     * @example
     * // Create one ReferralTransaction
     * const ReferralTransaction = await prisma.referralTransaction.create({
     *   data: {
     *     // ... data to create a ReferralTransaction
     *   }
     * })
     * 
     */
    create<T extends ReferralTransactionCreateArgs>(args: SelectSubset<T, ReferralTransactionCreateArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralTransactions.
     * @param {ReferralTransactionCreateManyArgs} args - Arguments to create many ReferralTransactions.
     * @example
     * // Create many ReferralTransactions
     * const referralTransaction = await prisma.referralTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralTransactionCreateManyArgs>(args?: SelectSubset<T, ReferralTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralTransactions and returns the data saved in the database.
     * @param {ReferralTransactionCreateManyAndReturnArgs} args - Arguments to create many ReferralTransactions.
     * @example
     * // Create many ReferralTransactions
     * const referralTransaction = await prisma.referralTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralTransactions and only return the `id`
     * const referralTransactionWithIdOnly = await prisma.referralTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralTransaction.
     * @param {ReferralTransactionDeleteArgs} args - Arguments to delete one ReferralTransaction.
     * @example
     * // Delete one ReferralTransaction
     * const ReferralTransaction = await prisma.referralTransaction.delete({
     *   where: {
     *     // ... filter to delete one ReferralTransaction
     *   }
     * })
     * 
     */
    delete<T extends ReferralTransactionDeleteArgs>(args: SelectSubset<T, ReferralTransactionDeleteArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralTransaction.
     * @param {ReferralTransactionUpdateArgs} args - Arguments to update one ReferralTransaction.
     * @example
     * // Update one ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralTransactionUpdateArgs>(args: SelectSubset<T, ReferralTransactionUpdateArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralTransactions.
     * @param {ReferralTransactionDeleteManyArgs} args - Arguments to filter ReferralTransactions to delete.
     * @example
     * // Delete a few ReferralTransactions
     * const { count } = await prisma.referralTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralTransactionDeleteManyArgs>(args?: SelectSubset<T, ReferralTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralTransactions
     * const referralTransaction = await prisma.referralTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralTransactionUpdateManyArgs>(args: SelectSubset<T, ReferralTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralTransaction.
     * @param {ReferralTransactionUpsertArgs} args - Arguments to update or create a ReferralTransaction.
     * @example
     * // Update or create a ReferralTransaction
     * const referralTransaction = await prisma.referralTransaction.upsert({
     *   create: {
     *     // ... data to create a ReferralTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralTransaction we want to update
     *   }
     * })
     */
    upsert<T extends ReferralTransactionUpsertArgs>(args: SelectSubset<T, ReferralTransactionUpsertArgs<ExtArgs>>): Prisma__ReferralTransactionClient<$Result.GetResult<Prisma.$ReferralTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionCountArgs} args - Arguments to filter ReferralTransactions to count.
     * @example
     * // Count the number of ReferralTransactions
     * const count = await prisma.referralTransaction.count({
     *   where: {
     *     // ... the filter for the ReferralTransactions we want to count
     *   }
     * })
    **/
    count<T extends ReferralTransactionCountArgs>(
      args?: Subset<T, ReferralTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralTransactionAggregateArgs>(args: Subset<T, ReferralTransactionAggregateArgs>): Prisma.PrismaPromise<GetReferralTransactionAggregateType<T>>

    /**
     * Group by ReferralTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralTransactionGroupByArgs['orderBy'] }
        : { orderBy?: ReferralTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralTransaction model
   */
  readonly fields: ReferralTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralTransaction model
   */ 
  interface ReferralTransactionFieldRefs {
    readonly id: FieldRef<"ReferralTransaction", 'Int'>
    readonly referrerId: FieldRef<"ReferralTransaction", 'Int'>
    readonly refereeId: FieldRef<"ReferralTransaction", 'Int'>
    readonly tokenId: FieldRef<"ReferralTransaction", 'Int'>
    readonly eventType: FieldRef<"ReferralTransaction", 'ReferralEventType'>
    readonly amount: FieldRef<"ReferralTransaction", 'Decimal'>
    readonly sourceEntityId: FieldRef<"ReferralTransaction", 'Int'>
    readonly sourceEntityType: FieldRef<"ReferralTransaction", 'String'>
    readonly createdAt: FieldRef<"ReferralTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralTransaction findUnique
   */
  export type ReferralTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransaction to fetch.
     */
    where: ReferralTransactionWhereUniqueInput
  }

  /**
   * ReferralTransaction findUniqueOrThrow
   */
  export type ReferralTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransaction to fetch.
     */
    where: ReferralTransactionWhereUniqueInput
  }

  /**
   * ReferralTransaction findFirst
   */
  export type ReferralTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransaction to fetch.
     */
    where?: ReferralTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralTransactions to fetch.
     */
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralTransactions.
     */
    cursor?: ReferralTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralTransactions.
     */
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * ReferralTransaction findFirstOrThrow
   */
  export type ReferralTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransaction to fetch.
     */
    where?: ReferralTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralTransactions to fetch.
     */
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralTransactions.
     */
    cursor?: ReferralTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralTransactions.
     */
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * ReferralTransaction findMany
   */
  export type ReferralTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ReferralTransactions to fetch.
     */
    where?: ReferralTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralTransactions to fetch.
     */
    orderBy?: ReferralTransactionOrderByWithRelationInput | ReferralTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralTransactions.
     */
    cursor?: ReferralTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralTransactions.
     */
    skip?: number
    distinct?: ReferralTransactionScalarFieldEnum | ReferralTransactionScalarFieldEnum[]
  }

  /**
   * ReferralTransaction create
   */
  export type ReferralTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralTransaction.
     */
    data: XOR<ReferralTransactionCreateInput, ReferralTransactionUncheckedCreateInput>
  }

  /**
   * ReferralTransaction createMany
   */
  export type ReferralTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralTransactions.
     */
    data: ReferralTransactionCreateManyInput | ReferralTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralTransaction createManyAndReturn
   */
  export type ReferralTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralTransactions.
     */
    data: ReferralTransactionCreateManyInput | ReferralTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralTransaction update
   */
  export type ReferralTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralTransaction.
     */
    data: XOR<ReferralTransactionUpdateInput, ReferralTransactionUncheckedUpdateInput>
    /**
     * Choose, which ReferralTransaction to update.
     */
    where: ReferralTransactionWhereUniqueInput
  }

  /**
   * ReferralTransaction updateMany
   */
  export type ReferralTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralTransactions.
     */
    data: XOR<ReferralTransactionUpdateManyMutationInput, ReferralTransactionUncheckedUpdateManyInput>
    /**
     * Filter which ReferralTransactions to update
     */
    where?: ReferralTransactionWhereInput
  }

  /**
   * ReferralTransaction upsert
   */
  export type ReferralTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralTransaction to update in case it exists.
     */
    where: ReferralTransactionWhereUniqueInput
    /**
     * In case the ReferralTransaction found by the `where` argument doesn't exist, create a new ReferralTransaction with this data.
     */
    create: XOR<ReferralTransactionCreateInput, ReferralTransactionUncheckedCreateInput>
    /**
     * In case the ReferralTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralTransactionUpdateInput, ReferralTransactionUncheckedUpdateInput>
  }

  /**
   * ReferralTransaction delete
   */
  export type ReferralTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
    /**
     * Filter which ReferralTransaction to delete.
     */
    where: ReferralTransactionWhereUniqueInput
  }

  /**
   * ReferralTransaction deleteMany
   */
  export type ReferralTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralTransactions to delete
     */
    where?: ReferralTransactionWhereInput
  }

  /**
   * ReferralTransaction without action
   */
  export type ReferralTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralTransaction
     */
    select?: ReferralTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralTransactionInclude<ExtArgs> | null
  }


  /**
   * Model OneTimeToken
   */

  export type AggregateOneTimeToken = {
    _count: OneTimeTokenCountAggregateOutputType | null
    _avg: OneTimeTokenAvgAggregateOutputType | null
    _sum: OneTimeTokenSumAggregateOutputType | null
    _min: OneTimeTokenMinAggregateOutputType | null
    _max: OneTimeTokenMaxAggregateOutputType | null
  }

  export type OneTimeTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OneTimeTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OneTimeTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    createdAt: Date | null
    expiresAt: Date | null
    used: boolean | null
  }

  export type OneTimeTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    createdAt: Date | null
    expiresAt: Date | null
    used: boolean | null
  }

  export type OneTimeTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    createdAt: number
    expiresAt: number
    used: number
    _all: number
  }


  export type OneTimeTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OneTimeTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OneTimeTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    used?: true
  }

  export type OneTimeTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    used?: true
  }

  export type OneTimeTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    used?: true
    _all?: true
  }

  export type OneTimeTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneTimeToken to aggregate.
     */
    where?: OneTimeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeTokens to fetch.
     */
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OneTimeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OneTimeTokens
    **/
    _count?: true | OneTimeTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OneTimeTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OneTimeTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OneTimeTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OneTimeTokenMaxAggregateInputType
  }

  export type GetOneTimeTokenAggregateType<T extends OneTimeTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOneTimeToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOneTimeToken[P]>
      : GetScalarType<T[P], AggregateOneTimeToken[P]>
  }




  export type OneTimeTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneTimeTokenWhereInput
    orderBy?: OneTimeTokenOrderByWithAggregationInput | OneTimeTokenOrderByWithAggregationInput[]
    by: OneTimeTokenScalarFieldEnum[] | OneTimeTokenScalarFieldEnum
    having?: OneTimeTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OneTimeTokenCountAggregateInputType | true
    _avg?: OneTimeTokenAvgAggregateInputType
    _sum?: OneTimeTokenSumAggregateInputType
    _min?: OneTimeTokenMinAggregateInputType
    _max?: OneTimeTokenMaxAggregateInputType
  }

  export type OneTimeTokenGroupByOutputType = {
    id: number
    token: string
    userId: number
    createdAt: Date
    expiresAt: Date
    used: boolean
    _count: OneTimeTokenCountAggregateOutputType | null
    _avg: OneTimeTokenAvgAggregateOutputType | null
    _sum: OneTimeTokenSumAggregateOutputType | null
    _min: OneTimeTokenMinAggregateOutputType | null
    _max: OneTimeTokenMaxAggregateOutputType | null
  }

  type GetOneTimeTokenGroupByPayload<T extends OneTimeTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OneTimeTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OneTimeTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OneTimeTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OneTimeTokenGroupByOutputType[P]>
        }
      >
    >


  export type OneTimeTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneTimeToken"]>

  export type OneTimeTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneTimeToken"]>

  export type OneTimeTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    used?: boolean
  }

  export type OneTimeTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OneTimeTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OneTimeTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OneTimeToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      userId: number
      createdAt: Date
      expiresAt: Date
      used: boolean
    }, ExtArgs["result"]["oneTimeToken"]>
    composites: {}
  }

  type OneTimeTokenGetPayload<S extends boolean | null | undefined | OneTimeTokenDefaultArgs> = $Result.GetResult<Prisma.$OneTimeTokenPayload, S>

  type OneTimeTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OneTimeTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OneTimeTokenCountAggregateInputType | true
    }

  export interface OneTimeTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OneTimeToken'], meta: { name: 'OneTimeToken' } }
    /**
     * Find zero or one OneTimeToken that matches the filter.
     * @param {OneTimeTokenFindUniqueArgs} args - Arguments to find a OneTimeToken
     * @example
     * // Get one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OneTimeTokenFindUniqueArgs>(args: SelectSubset<T, OneTimeTokenFindUniqueArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OneTimeToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OneTimeTokenFindUniqueOrThrowArgs} args - Arguments to find a OneTimeToken
     * @example
     * // Get one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OneTimeTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, OneTimeTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OneTimeToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenFindFirstArgs} args - Arguments to find a OneTimeToken
     * @example
     * // Get one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OneTimeTokenFindFirstArgs>(args?: SelectSubset<T, OneTimeTokenFindFirstArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OneTimeToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenFindFirstOrThrowArgs} args - Arguments to find a OneTimeToken
     * @example
     * // Get one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OneTimeTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, OneTimeTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OneTimeTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OneTimeTokens
     * const oneTimeTokens = await prisma.oneTimeToken.findMany()
     * 
     * // Get first 10 OneTimeTokens
     * const oneTimeTokens = await prisma.oneTimeToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oneTimeTokenWithIdOnly = await prisma.oneTimeToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OneTimeTokenFindManyArgs>(args?: SelectSubset<T, OneTimeTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OneTimeToken.
     * @param {OneTimeTokenCreateArgs} args - Arguments to create a OneTimeToken.
     * @example
     * // Create one OneTimeToken
     * const OneTimeToken = await prisma.oneTimeToken.create({
     *   data: {
     *     // ... data to create a OneTimeToken
     *   }
     * })
     * 
     */
    create<T extends OneTimeTokenCreateArgs>(args: SelectSubset<T, OneTimeTokenCreateArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OneTimeTokens.
     * @param {OneTimeTokenCreateManyArgs} args - Arguments to create many OneTimeTokens.
     * @example
     * // Create many OneTimeTokens
     * const oneTimeToken = await prisma.oneTimeToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OneTimeTokenCreateManyArgs>(args?: SelectSubset<T, OneTimeTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OneTimeTokens and returns the data saved in the database.
     * @param {OneTimeTokenCreateManyAndReturnArgs} args - Arguments to create many OneTimeTokens.
     * @example
     * // Create many OneTimeTokens
     * const oneTimeToken = await prisma.oneTimeToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OneTimeTokens and only return the `id`
     * const oneTimeTokenWithIdOnly = await prisma.oneTimeToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OneTimeTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, OneTimeTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OneTimeToken.
     * @param {OneTimeTokenDeleteArgs} args - Arguments to delete one OneTimeToken.
     * @example
     * // Delete one OneTimeToken
     * const OneTimeToken = await prisma.oneTimeToken.delete({
     *   where: {
     *     // ... filter to delete one OneTimeToken
     *   }
     * })
     * 
     */
    delete<T extends OneTimeTokenDeleteArgs>(args: SelectSubset<T, OneTimeTokenDeleteArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OneTimeToken.
     * @param {OneTimeTokenUpdateArgs} args - Arguments to update one OneTimeToken.
     * @example
     * // Update one OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OneTimeTokenUpdateArgs>(args: SelectSubset<T, OneTimeTokenUpdateArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OneTimeTokens.
     * @param {OneTimeTokenDeleteManyArgs} args - Arguments to filter OneTimeTokens to delete.
     * @example
     * // Delete a few OneTimeTokens
     * const { count } = await prisma.oneTimeToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OneTimeTokenDeleteManyArgs>(args?: SelectSubset<T, OneTimeTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OneTimeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OneTimeTokens
     * const oneTimeToken = await prisma.oneTimeToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OneTimeTokenUpdateManyArgs>(args: SelectSubset<T, OneTimeTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OneTimeToken.
     * @param {OneTimeTokenUpsertArgs} args - Arguments to update or create a OneTimeToken.
     * @example
     * // Update or create a OneTimeToken
     * const oneTimeToken = await prisma.oneTimeToken.upsert({
     *   create: {
     *     // ... data to create a OneTimeToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OneTimeToken we want to update
     *   }
     * })
     */
    upsert<T extends OneTimeTokenUpsertArgs>(args: SelectSubset<T, OneTimeTokenUpsertArgs<ExtArgs>>): Prisma__OneTimeTokenClient<$Result.GetResult<Prisma.$OneTimeTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OneTimeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenCountArgs} args - Arguments to filter OneTimeTokens to count.
     * @example
     * // Count the number of OneTimeTokens
     * const count = await prisma.oneTimeToken.count({
     *   where: {
     *     // ... the filter for the OneTimeTokens we want to count
     *   }
     * })
    **/
    count<T extends OneTimeTokenCountArgs>(
      args?: Subset<T, OneTimeTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OneTimeTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OneTimeToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OneTimeTokenAggregateArgs>(args: Subset<T, OneTimeTokenAggregateArgs>): Prisma.PrismaPromise<GetOneTimeTokenAggregateType<T>>

    /**
     * Group by OneTimeToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OneTimeTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OneTimeTokenGroupByArgs['orderBy'] }
        : { orderBy?: OneTimeTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OneTimeTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOneTimeTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OneTimeToken model
   */
  readonly fields: OneTimeTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OneTimeToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OneTimeTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OneTimeToken model
   */ 
  interface OneTimeTokenFieldRefs {
    readonly id: FieldRef<"OneTimeToken", 'Int'>
    readonly token: FieldRef<"OneTimeToken", 'String'>
    readonly userId: FieldRef<"OneTimeToken", 'Int'>
    readonly createdAt: FieldRef<"OneTimeToken", 'DateTime'>
    readonly expiresAt: FieldRef<"OneTimeToken", 'DateTime'>
    readonly used: FieldRef<"OneTimeToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OneTimeToken findUnique
   */
  export type OneTimeTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeToken to fetch.
     */
    where: OneTimeTokenWhereUniqueInput
  }

  /**
   * OneTimeToken findUniqueOrThrow
   */
  export type OneTimeTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeToken to fetch.
     */
    where: OneTimeTokenWhereUniqueInput
  }

  /**
   * OneTimeToken findFirst
   */
  export type OneTimeTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeToken to fetch.
     */
    where?: OneTimeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeTokens to fetch.
     */
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneTimeTokens.
     */
    cursor?: OneTimeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneTimeTokens.
     */
    distinct?: OneTimeTokenScalarFieldEnum | OneTimeTokenScalarFieldEnum[]
  }

  /**
   * OneTimeToken findFirstOrThrow
   */
  export type OneTimeTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeToken to fetch.
     */
    where?: OneTimeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeTokens to fetch.
     */
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneTimeTokens.
     */
    cursor?: OneTimeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneTimeTokens.
     */
    distinct?: OneTimeTokenScalarFieldEnum | OneTimeTokenScalarFieldEnum[]
  }

  /**
   * OneTimeToken findMany
   */
  export type OneTimeTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeTokens to fetch.
     */
    where?: OneTimeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeTokens to fetch.
     */
    orderBy?: OneTimeTokenOrderByWithRelationInput | OneTimeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OneTimeTokens.
     */
    cursor?: OneTimeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeTokens.
     */
    skip?: number
    distinct?: OneTimeTokenScalarFieldEnum | OneTimeTokenScalarFieldEnum[]
  }

  /**
   * OneTimeToken create
   */
  export type OneTimeTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a OneTimeToken.
     */
    data: XOR<OneTimeTokenCreateInput, OneTimeTokenUncheckedCreateInput>
  }

  /**
   * OneTimeToken createMany
   */
  export type OneTimeTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OneTimeTokens.
     */
    data: OneTimeTokenCreateManyInput | OneTimeTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OneTimeToken createManyAndReturn
   */
  export type OneTimeTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OneTimeTokens.
     */
    data: OneTimeTokenCreateManyInput | OneTimeTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OneTimeToken update
   */
  export type OneTimeTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a OneTimeToken.
     */
    data: XOR<OneTimeTokenUpdateInput, OneTimeTokenUncheckedUpdateInput>
    /**
     * Choose, which OneTimeToken to update.
     */
    where: OneTimeTokenWhereUniqueInput
  }

  /**
   * OneTimeToken updateMany
   */
  export type OneTimeTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OneTimeTokens.
     */
    data: XOR<OneTimeTokenUpdateManyMutationInput, OneTimeTokenUncheckedUpdateManyInput>
    /**
     * Filter which OneTimeTokens to update
     */
    where?: OneTimeTokenWhereInput
  }

  /**
   * OneTimeToken upsert
   */
  export type OneTimeTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the OneTimeToken to update in case it exists.
     */
    where: OneTimeTokenWhereUniqueInput
    /**
     * In case the OneTimeToken found by the `where` argument doesn't exist, create a new OneTimeToken with this data.
     */
    create: XOR<OneTimeTokenCreateInput, OneTimeTokenUncheckedCreateInput>
    /**
     * In case the OneTimeToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OneTimeTokenUpdateInput, OneTimeTokenUncheckedUpdateInput>
  }

  /**
   * OneTimeToken delete
   */
  export type OneTimeTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
    /**
     * Filter which OneTimeToken to delete.
     */
    where: OneTimeTokenWhereUniqueInput
  }

  /**
   * OneTimeToken deleteMany
   */
  export type OneTimeTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneTimeTokens to delete
     */
    where?: OneTimeTokenWhereInput
  }

  /**
   * OneTimeToken without action
   */
  export type OneTimeTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeToken
     */
    select?: OneTimeTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneTimeTokenInclude<ExtArgs> | null
  }


  /**
   * Model CrashRound
   */

  export type AggregateCrashRound = {
    _count: CrashRoundCountAggregateOutputType | null
    _avg: CrashRoundAvgAggregateOutputType | null
    _sum: CrashRoundSumAggregateOutputType | null
    _min: CrashRoundMinAggregateOutputType | null
    _max: CrashRoundMaxAggregateOutputType | null
  }

  export type CrashRoundAvgAggregateOutputType = {
    id: number | null
    crashPoint: Decimal | null
    totalPlayers: number | null
    winnersCount: number | null
    totalWagered: Decimal | null
    totalPayouts: Decimal | null
    nonce: number | null
  }

  export type CrashRoundSumAggregateOutputType = {
    id: number | null
    crashPoint: Decimal | null
    totalPlayers: number | null
    winnersCount: number | null
    totalWagered: Decimal | null
    totalPayouts: Decimal | null
    nonce: number | null
  }

  export type CrashRoundMinAggregateOutputType = {
    id: number | null
    gameId: string | null
    crashPoint: Decimal | null
    totalPlayers: number | null
    winnersCount: number | null
    totalWagered: Decimal | null
    totalPayouts: Decimal | null
    serverSeedHash: string | null
    clientSeed: string | null
    nonce: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrashRoundMaxAggregateOutputType = {
    id: number | null
    gameId: string | null
    crashPoint: Decimal | null
    totalPlayers: number | null
    winnersCount: number | null
    totalWagered: Decimal | null
    totalPayouts: Decimal | null
    serverSeedHash: string | null
    clientSeed: string | null
    nonce: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrashRoundCountAggregateOutputType = {
    id: number
    gameId: number
    crashPoint: number
    totalPlayers: number
    winnersCount: number
    totalWagered: number
    totalPayouts: number
    serverSeedHash: number
    clientSeed: number
    nonce: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrashRoundAvgAggregateInputType = {
    id?: true
    crashPoint?: true
    totalPlayers?: true
    winnersCount?: true
    totalWagered?: true
    totalPayouts?: true
    nonce?: true
  }

  export type CrashRoundSumAggregateInputType = {
    id?: true
    crashPoint?: true
    totalPlayers?: true
    winnersCount?: true
    totalWagered?: true
    totalPayouts?: true
    nonce?: true
  }

  export type CrashRoundMinAggregateInputType = {
    id?: true
    gameId?: true
    crashPoint?: true
    totalPlayers?: true
    winnersCount?: true
    totalWagered?: true
    totalPayouts?: true
    serverSeedHash?: true
    clientSeed?: true
    nonce?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrashRoundMaxAggregateInputType = {
    id?: true
    gameId?: true
    crashPoint?: true
    totalPlayers?: true
    winnersCount?: true
    totalWagered?: true
    totalPayouts?: true
    serverSeedHash?: true
    clientSeed?: true
    nonce?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrashRoundCountAggregateInputType = {
    id?: true
    gameId?: true
    crashPoint?: true
    totalPlayers?: true
    winnersCount?: true
    totalWagered?: true
    totalPayouts?: true
    serverSeedHash?: true
    clientSeed?: true
    nonce?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrashRoundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrashRound to aggregate.
     */
    where?: CrashRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashRounds to fetch.
     */
    orderBy?: CrashRoundOrderByWithRelationInput | CrashRoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrashRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrashRounds
    **/
    _count?: true | CrashRoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrashRoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrashRoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrashRoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrashRoundMaxAggregateInputType
  }

  export type GetCrashRoundAggregateType<T extends CrashRoundAggregateArgs> = {
        [P in keyof T & keyof AggregateCrashRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrashRound[P]>
      : GetScalarType<T[P], AggregateCrashRound[P]>
  }




  export type CrashRoundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashRoundWhereInput
    orderBy?: CrashRoundOrderByWithAggregationInput | CrashRoundOrderByWithAggregationInput[]
    by: CrashRoundScalarFieldEnum[] | CrashRoundScalarFieldEnum
    having?: CrashRoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrashRoundCountAggregateInputType | true
    _avg?: CrashRoundAvgAggregateInputType
    _sum?: CrashRoundSumAggregateInputType
    _min?: CrashRoundMinAggregateInputType
    _max?: CrashRoundMaxAggregateInputType
  }

  export type CrashRoundGroupByOutputType = {
    id: number
    gameId: string
    crashPoint: Decimal
    totalPlayers: number
    winnersCount: number
    totalWagered: Decimal
    totalPayouts: Decimal
    serverSeedHash: string
    clientSeed: string
    nonce: number
    createdAt: Date
    updatedAt: Date
    _count: CrashRoundCountAggregateOutputType | null
    _avg: CrashRoundAvgAggregateOutputType | null
    _sum: CrashRoundSumAggregateOutputType | null
    _min: CrashRoundMinAggregateOutputType | null
    _max: CrashRoundMaxAggregateOutputType | null
  }

  type GetCrashRoundGroupByPayload<T extends CrashRoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrashRoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrashRoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrashRoundGroupByOutputType[P]>
            : GetScalarType<T[P], CrashRoundGroupByOutputType[P]>
        }
      >
    >


  export type CrashRoundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    crashPoint?: boolean
    totalPlayers?: boolean
    winnersCount?: boolean
    totalWagered?: boolean
    totalPayouts?: boolean
    serverSeedHash?: boolean
    clientSeed?: boolean
    nonce?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bets?: boolean | CrashRound$betsArgs<ExtArgs>
    _count?: boolean | CrashRoundCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crashRound"]>

  export type CrashRoundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    crashPoint?: boolean
    totalPlayers?: boolean
    winnersCount?: boolean
    totalWagered?: boolean
    totalPayouts?: boolean
    serverSeedHash?: boolean
    clientSeed?: boolean
    nonce?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crashRound"]>

  export type CrashRoundSelectScalar = {
    id?: boolean
    gameId?: boolean
    crashPoint?: boolean
    totalPlayers?: boolean
    winnersCount?: boolean
    totalWagered?: boolean
    totalPayouts?: boolean
    serverSeedHash?: boolean
    clientSeed?: boolean
    nonce?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrashRoundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bets?: boolean | CrashRound$betsArgs<ExtArgs>
    _count?: boolean | CrashRoundCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrashRoundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CrashRoundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrashRound"
    objects: {
      bets: Prisma.$CrashBetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gameId: string
      crashPoint: Prisma.Decimal
      totalPlayers: number
      winnersCount: number
      totalWagered: Prisma.Decimal
      totalPayouts: Prisma.Decimal
      serverSeedHash: string
      clientSeed: string
      nonce: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crashRound"]>
    composites: {}
  }

  type CrashRoundGetPayload<S extends boolean | null | undefined | CrashRoundDefaultArgs> = $Result.GetResult<Prisma.$CrashRoundPayload, S>

  type CrashRoundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrashRoundFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrashRoundCountAggregateInputType | true
    }

  export interface CrashRoundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrashRound'], meta: { name: 'CrashRound' } }
    /**
     * Find zero or one CrashRound that matches the filter.
     * @param {CrashRoundFindUniqueArgs} args - Arguments to find a CrashRound
     * @example
     * // Get one CrashRound
     * const crashRound = await prisma.crashRound.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrashRoundFindUniqueArgs>(args: SelectSubset<T, CrashRoundFindUniqueArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CrashRound that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrashRoundFindUniqueOrThrowArgs} args - Arguments to find a CrashRound
     * @example
     * // Get one CrashRound
     * const crashRound = await prisma.crashRound.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrashRoundFindUniqueOrThrowArgs>(args: SelectSubset<T, CrashRoundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CrashRound that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashRoundFindFirstArgs} args - Arguments to find a CrashRound
     * @example
     * // Get one CrashRound
     * const crashRound = await prisma.crashRound.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrashRoundFindFirstArgs>(args?: SelectSubset<T, CrashRoundFindFirstArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CrashRound that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashRoundFindFirstOrThrowArgs} args - Arguments to find a CrashRound
     * @example
     * // Get one CrashRound
     * const crashRound = await prisma.crashRound.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrashRoundFindFirstOrThrowArgs>(args?: SelectSubset<T, CrashRoundFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CrashRounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashRoundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrashRounds
     * const crashRounds = await prisma.crashRound.findMany()
     * 
     * // Get first 10 CrashRounds
     * const crashRounds = await prisma.crashRound.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crashRoundWithIdOnly = await prisma.crashRound.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrashRoundFindManyArgs>(args?: SelectSubset<T, CrashRoundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CrashRound.
     * @param {CrashRoundCreateArgs} args - Arguments to create a CrashRound.
     * @example
     * // Create one CrashRound
     * const CrashRound = await prisma.crashRound.create({
     *   data: {
     *     // ... data to create a CrashRound
     *   }
     * })
     * 
     */
    create<T extends CrashRoundCreateArgs>(args: SelectSubset<T, CrashRoundCreateArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CrashRounds.
     * @param {CrashRoundCreateManyArgs} args - Arguments to create many CrashRounds.
     * @example
     * // Create many CrashRounds
     * const crashRound = await prisma.crashRound.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrashRoundCreateManyArgs>(args?: SelectSubset<T, CrashRoundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrashRounds and returns the data saved in the database.
     * @param {CrashRoundCreateManyAndReturnArgs} args - Arguments to create many CrashRounds.
     * @example
     * // Create many CrashRounds
     * const crashRound = await prisma.crashRound.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrashRounds and only return the `id`
     * const crashRoundWithIdOnly = await prisma.crashRound.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrashRoundCreateManyAndReturnArgs>(args?: SelectSubset<T, CrashRoundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CrashRound.
     * @param {CrashRoundDeleteArgs} args - Arguments to delete one CrashRound.
     * @example
     * // Delete one CrashRound
     * const CrashRound = await prisma.crashRound.delete({
     *   where: {
     *     // ... filter to delete one CrashRound
     *   }
     * })
     * 
     */
    delete<T extends CrashRoundDeleteArgs>(args: SelectSubset<T, CrashRoundDeleteArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CrashRound.
     * @param {CrashRoundUpdateArgs} args - Arguments to update one CrashRound.
     * @example
     * // Update one CrashRound
     * const crashRound = await prisma.crashRound.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrashRoundUpdateArgs>(args: SelectSubset<T, CrashRoundUpdateArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CrashRounds.
     * @param {CrashRoundDeleteManyArgs} args - Arguments to filter CrashRounds to delete.
     * @example
     * // Delete a few CrashRounds
     * const { count } = await prisma.crashRound.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrashRoundDeleteManyArgs>(args?: SelectSubset<T, CrashRoundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrashRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashRoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrashRounds
     * const crashRound = await prisma.crashRound.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrashRoundUpdateManyArgs>(args: SelectSubset<T, CrashRoundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrashRound.
     * @param {CrashRoundUpsertArgs} args - Arguments to update or create a CrashRound.
     * @example
     * // Update or create a CrashRound
     * const crashRound = await prisma.crashRound.upsert({
     *   create: {
     *     // ... data to create a CrashRound
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrashRound we want to update
     *   }
     * })
     */
    upsert<T extends CrashRoundUpsertArgs>(args: SelectSubset<T, CrashRoundUpsertArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CrashRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashRoundCountArgs} args - Arguments to filter CrashRounds to count.
     * @example
     * // Count the number of CrashRounds
     * const count = await prisma.crashRound.count({
     *   where: {
     *     // ... the filter for the CrashRounds we want to count
     *   }
     * })
    **/
    count<T extends CrashRoundCountArgs>(
      args?: Subset<T, CrashRoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrashRoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrashRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashRoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrashRoundAggregateArgs>(args: Subset<T, CrashRoundAggregateArgs>): Prisma.PrismaPromise<GetCrashRoundAggregateType<T>>

    /**
     * Group by CrashRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashRoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrashRoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrashRoundGroupByArgs['orderBy'] }
        : { orderBy?: CrashRoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrashRoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrashRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrashRound model
   */
  readonly fields: CrashRoundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrashRound.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrashRoundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bets<T extends CrashRound$betsArgs<ExtArgs> = {}>(args?: Subset<T, CrashRound$betsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrashRound model
   */ 
  interface CrashRoundFieldRefs {
    readonly id: FieldRef<"CrashRound", 'Int'>
    readonly gameId: FieldRef<"CrashRound", 'String'>
    readonly crashPoint: FieldRef<"CrashRound", 'Decimal'>
    readonly totalPlayers: FieldRef<"CrashRound", 'Int'>
    readonly winnersCount: FieldRef<"CrashRound", 'Int'>
    readonly totalWagered: FieldRef<"CrashRound", 'Decimal'>
    readonly totalPayouts: FieldRef<"CrashRound", 'Decimal'>
    readonly serverSeedHash: FieldRef<"CrashRound", 'String'>
    readonly clientSeed: FieldRef<"CrashRound", 'String'>
    readonly nonce: FieldRef<"CrashRound", 'Int'>
    readonly createdAt: FieldRef<"CrashRound", 'DateTime'>
    readonly updatedAt: FieldRef<"CrashRound", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrashRound findUnique
   */
  export type CrashRoundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * Filter, which CrashRound to fetch.
     */
    where: CrashRoundWhereUniqueInput
  }

  /**
   * CrashRound findUniqueOrThrow
   */
  export type CrashRoundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * Filter, which CrashRound to fetch.
     */
    where: CrashRoundWhereUniqueInput
  }

  /**
   * CrashRound findFirst
   */
  export type CrashRoundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * Filter, which CrashRound to fetch.
     */
    where?: CrashRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashRounds to fetch.
     */
    orderBy?: CrashRoundOrderByWithRelationInput | CrashRoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrashRounds.
     */
    cursor?: CrashRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrashRounds.
     */
    distinct?: CrashRoundScalarFieldEnum | CrashRoundScalarFieldEnum[]
  }

  /**
   * CrashRound findFirstOrThrow
   */
  export type CrashRoundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * Filter, which CrashRound to fetch.
     */
    where?: CrashRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashRounds to fetch.
     */
    orderBy?: CrashRoundOrderByWithRelationInput | CrashRoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrashRounds.
     */
    cursor?: CrashRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrashRounds.
     */
    distinct?: CrashRoundScalarFieldEnum | CrashRoundScalarFieldEnum[]
  }

  /**
   * CrashRound findMany
   */
  export type CrashRoundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * Filter, which CrashRounds to fetch.
     */
    where?: CrashRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashRounds to fetch.
     */
    orderBy?: CrashRoundOrderByWithRelationInput | CrashRoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrashRounds.
     */
    cursor?: CrashRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashRounds.
     */
    skip?: number
    distinct?: CrashRoundScalarFieldEnum | CrashRoundScalarFieldEnum[]
  }

  /**
   * CrashRound create
   */
  export type CrashRoundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * The data needed to create a CrashRound.
     */
    data: XOR<CrashRoundCreateInput, CrashRoundUncheckedCreateInput>
  }

  /**
   * CrashRound createMany
   */
  export type CrashRoundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrashRounds.
     */
    data: CrashRoundCreateManyInput | CrashRoundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrashRound createManyAndReturn
   */
  export type CrashRoundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CrashRounds.
     */
    data: CrashRoundCreateManyInput | CrashRoundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrashRound update
   */
  export type CrashRoundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * The data needed to update a CrashRound.
     */
    data: XOR<CrashRoundUpdateInput, CrashRoundUncheckedUpdateInput>
    /**
     * Choose, which CrashRound to update.
     */
    where: CrashRoundWhereUniqueInput
  }

  /**
   * CrashRound updateMany
   */
  export type CrashRoundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrashRounds.
     */
    data: XOR<CrashRoundUpdateManyMutationInput, CrashRoundUncheckedUpdateManyInput>
    /**
     * Filter which CrashRounds to update
     */
    where?: CrashRoundWhereInput
  }

  /**
   * CrashRound upsert
   */
  export type CrashRoundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * The filter to search for the CrashRound to update in case it exists.
     */
    where: CrashRoundWhereUniqueInput
    /**
     * In case the CrashRound found by the `where` argument doesn't exist, create a new CrashRound with this data.
     */
    create: XOR<CrashRoundCreateInput, CrashRoundUncheckedCreateInput>
    /**
     * In case the CrashRound was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrashRoundUpdateInput, CrashRoundUncheckedUpdateInput>
  }

  /**
   * CrashRound delete
   */
  export type CrashRoundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
    /**
     * Filter which CrashRound to delete.
     */
    where: CrashRoundWhereUniqueInput
  }

  /**
   * CrashRound deleteMany
   */
  export type CrashRoundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrashRounds to delete
     */
    where?: CrashRoundWhereInput
  }

  /**
   * CrashRound.bets
   */
  export type CrashRound$betsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    where?: CrashBetWhereInput
    orderBy?: CrashBetOrderByWithRelationInput | CrashBetOrderByWithRelationInput[]
    cursor?: CrashBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrashBetScalarFieldEnum | CrashBetScalarFieldEnum[]
  }

  /**
   * CrashRound without action
   */
  export type CrashRoundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashRound
     */
    select?: CrashRoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashRoundInclude<ExtArgs> | null
  }


  /**
   * Model CrashBet
   */

  export type AggregateCrashBet = {
    _count: CrashBetCountAggregateOutputType | null
    _avg: CrashBetAvgAggregateOutputType | null
    _sum: CrashBetSumAggregateOutputType | null
    _min: CrashBetMinAggregateOutputType | null
    _max: CrashBetMaxAggregateOutputType | null
  }

  export type CrashBetAvgAggregateOutputType = {
    id: number | null
    roundId: number | null
    userId: number | null
    tokenId: number | null
    betAmount: Decimal | null
    exitMultiplier: Decimal | null
    winnings: Decimal | null
  }

  export type CrashBetSumAggregateOutputType = {
    id: number | null
    roundId: number | null
    userId: number | null
    tokenId: number | null
    betAmount: Decimal | null
    exitMultiplier: Decimal | null
    winnings: Decimal | null
  }

  export type CrashBetMinAggregateOutputType = {
    id: number | null
    roundId: number | null
    userId: number | null
    tokenId: number | null
    betAmount: Decimal | null
    exitMultiplier: Decimal | null
    winnings: Decimal | null
    result: string | null
    createdAt: Date | null
  }

  export type CrashBetMaxAggregateOutputType = {
    id: number | null
    roundId: number | null
    userId: number | null
    tokenId: number | null
    betAmount: Decimal | null
    exitMultiplier: Decimal | null
    winnings: Decimal | null
    result: string | null
    createdAt: Date | null
  }

  export type CrashBetCountAggregateOutputType = {
    id: number
    roundId: number
    userId: number
    tokenId: number
    betAmount: number
    exitMultiplier: number
    winnings: number
    result: number
    createdAt: number
    _all: number
  }


  export type CrashBetAvgAggregateInputType = {
    id?: true
    roundId?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    exitMultiplier?: true
    winnings?: true
  }

  export type CrashBetSumAggregateInputType = {
    id?: true
    roundId?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    exitMultiplier?: true
    winnings?: true
  }

  export type CrashBetMinAggregateInputType = {
    id?: true
    roundId?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    exitMultiplier?: true
    winnings?: true
    result?: true
    createdAt?: true
  }

  export type CrashBetMaxAggregateInputType = {
    id?: true
    roundId?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    exitMultiplier?: true
    winnings?: true
    result?: true
    createdAt?: true
  }

  export type CrashBetCountAggregateInputType = {
    id?: true
    roundId?: true
    userId?: true
    tokenId?: true
    betAmount?: true
    exitMultiplier?: true
    winnings?: true
    result?: true
    createdAt?: true
    _all?: true
  }

  export type CrashBetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrashBet to aggregate.
     */
    where?: CrashBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashBets to fetch.
     */
    orderBy?: CrashBetOrderByWithRelationInput | CrashBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrashBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrashBets
    **/
    _count?: true | CrashBetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrashBetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrashBetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrashBetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrashBetMaxAggregateInputType
  }

  export type GetCrashBetAggregateType<T extends CrashBetAggregateArgs> = {
        [P in keyof T & keyof AggregateCrashBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrashBet[P]>
      : GetScalarType<T[P], AggregateCrashBet[P]>
  }




  export type CrashBetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashBetWhereInput
    orderBy?: CrashBetOrderByWithAggregationInput | CrashBetOrderByWithAggregationInput[]
    by: CrashBetScalarFieldEnum[] | CrashBetScalarFieldEnum
    having?: CrashBetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrashBetCountAggregateInputType | true
    _avg?: CrashBetAvgAggregateInputType
    _sum?: CrashBetSumAggregateInputType
    _min?: CrashBetMinAggregateInputType
    _max?: CrashBetMaxAggregateInputType
  }

  export type CrashBetGroupByOutputType = {
    id: number
    roundId: number
    userId: number
    tokenId: number
    betAmount: Decimal
    exitMultiplier: Decimal | null
    winnings: Decimal | null
    result: string
    createdAt: Date
    _count: CrashBetCountAggregateOutputType | null
    _avg: CrashBetAvgAggregateOutputType | null
    _sum: CrashBetSumAggregateOutputType | null
    _min: CrashBetMinAggregateOutputType | null
    _max: CrashBetMaxAggregateOutputType | null
  }

  type GetCrashBetGroupByPayload<T extends CrashBetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrashBetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrashBetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrashBetGroupByOutputType[P]>
            : GetScalarType<T[P], CrashBetGroupByOutputType[P]>
        }
      >
    >


  export type CrashBetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    userId?: boolean
    tokenId?: boolean
    betAmount?: boolean
    exitMultiplier?: boolean
    winnings?: boolean
    result?: boolean
    createdAt?: boolean
    round?: boolean | CrashRoundDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
    transactions?: boolean | CrashBet$transactionsArgs<ExtArgs>
    _count?: boolean | CrashBetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crashBet"]>

  export type CrashBetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    userId?: boolean
    tokenId?: boolean
    betAmount?: boolean
    exitMultiplier?: boolean
    winnings?: boolean
    result?: boolean
    createdAt?: boolean
    round?: boolean | CrashRoundDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crashBet"]>

  export type CrashBetSelectScalar = {
    id?: boolean
    roundId?: boolean
    userId?: boolean
    tokenId?: boolean
    betAmount?: boolean
    exitMultiplier?: boolean
    winnings?: boolean
    result?: boolean
    createdAt?: boolean
  }

  export type CrashBetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | CrashRoundDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
    transactions?: boolean | CrashBet$transactionsArgs<ExtArgs>
    _count?: boolean | CrashBetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrashBetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | CrashRoundDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $CrashBetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrashBet"
    objects: {
      round: Prisma.$CrashRoundPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
      transactions: Prisma.$CrashTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roundId: number
      userId: number
      tokenId: number
      betAmount: Prisma.Decimal
      exitMultiplier: Prisma.Decimal | null
      winnings: Prisma.Decimal | null
      result: string
      createdAt: Date
    }, ExtArgs["result"]["crashBet"]>
    composites: {}
  }

  type CrashBetGetPayload<S extends boolean | null | undefined | CrashBetDefaultArgs> = $Result.GetResult<Prisma.$CrashBetPayload, S>

  type CrashBetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrashBetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrashBetCountAggregateInputType | true
    }

  export interface CrashBetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrashBet'], meta: { name: 'CrashBet' } }
    /**
     * Find zero or one CrashBet that matches the filter.
     * @param {CrashBetFindUniqueArgs} args - Arguments to find a CrashBet
     * @example
     * // Get one CrashBet
     * const crashBet = await prisma.crashBet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrashBetFindUniqueArgs>(args: SelectSubset<T, CrashBetFindUniqueArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CrashBet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrashBetFindUniqueOrThrowArgs} args - Arguments to find a CrashBet
     * @example
     * // Get one CrashBet
     * const crashBet = await prisma.crashBet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrashBetFindUniqueOrThrowArgs>(args: SelectSubset<T, CrashBetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CrashBet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashBetFindFirstArgs} args - Arguments to find a CrashBet
     * @example
     * // Get one CrashBet
     * const crashBet = await prisma.crashBet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrashBetFindFirstArgs>(args?: SelectSubset<T, CrashBetFindFirstArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CrashBet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashBetFindFirstOrThrowArgs} args - Arguments to find a CrashBet
     * @example
     * // Get one CrashBet
     * const crashBet = await prisma.crashBet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrashBetFindFirstOrThrowArgs>(args?: SelectSubset<T, CrashBetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CrashBets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashBetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrashBets
     * const crashBets = await prisma.crashBet.findMany()
     * 
     * // Get first 10 CrashBets
     * const crashBets = await prisma.crashBet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crashBetWithIdOnly = await prisma.crashBet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrashBetFindManyArgs>(args?: SelectSubset<T, CrashBetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CrashBet.
     * @param {CrashBetCreateArgs} args - Arguments to create a CrashBet.
     * @example
     * // Create one CrashBet
     * const CrashBet = await prisma.crashBet.create({
     *   data: {
     *     // ... data to create a CrashBet
     *   }
     * })
     * 
     */
    create<T extends CrashBetCreateArgs>(args: SelectSubset<T, CrashBetCreateArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CrashBets.
     * @param {CrashBetCreateManyArgs} args - Arguments to create many CrashBets.
     * @example
     * // Create many CrashBets
     * const crashBet = await prisma.crashBet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrashBetCreateManyArgs>(args?: SelectSubset<T, CrashBetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrashBets and returns the data saved in the database.
     * @param {CrashBetCreateManyAndReturnArgs} args - Arguments to create many CrashBets.
     * @example
     * // Create many CrashBets
     * const crashBet = await prisma.crashBet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrashBets and only return the `id`
     * const crashBetWithIdOnly = await prisma.crashBet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrashBetCreateManyAndReturnArgs>(args?: SelectSubset<T, CrashBetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CrashBet.
     * @param {CrashBetDeleteArgs} args - Arguments to delete one CrashBet.
     * @example
     * // Delete one CrashBet
     * const CrashBet = await prisma.crashBet.delete({
     *   where: {
     *     // ... filter to delete one CrashBet
     *   }
     * })
     * 
     */
    delete<T extends CrashBetDeleteArgs>(args: SelectSubset<T, CrashBetDeleteArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CrashBet.
     * @param {CrashBetUpdateArgs} args - Arguments to update one CrashBet.
     * @example
     * // Update one CrashBet
     * const crashBet = await prisma.crashBet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrashBetUpdateArgs>(args: SelectSubset<T, CrashBetUpdateArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CrashBets.
     * @param {CrashBetDeleteManyArgs} args - Arguments to filter CrashBets to delete.
     * @example
     * // Delete a few CrashBets
     * const { count } = await prisma.crashBet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrashBetDeleteManyArgs>(args?: SelectSubset<T, CrashBetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrashBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashBetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrashBets
     * const crashBet = await prisma.crashBet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrashBetUpdateManyArgs>(args: SelectSubset<T, CrashBetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrashBet.
     * @param {CrashBetUpsertArgs} args - Arguments to update or create a CrashBet.
     * @example
     * // Update or create a CrashBet
     * const crashBet = await prisma.crashBet.upsert({
     *   create: {
     *     // ... data to create a CrashBet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrashBet we want to update
     *   }
     * })
     */
    upsert<T extends CrashBetUpsertArgs>(args: SelectSubset<T, CrashBetUpsertArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CrashBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashBetCountArgs} args - Arguments to filter CrashBets to count.
     * @example
     * // Count the number of CrashBets
     * const count = await prisma.crashBet.count({
     *   where: {
     *     // ... the filter for the CrashBets we want to count
     *   }
     * })
    **/
    count<T extends CrashBetCountArgs>(
      args?: Subset<T, CrashBetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrashBetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrashBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashBetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrashBetAggregateArgs>(args: Subset<T, CrashBetAggregateArgs>): Prisma.PrismaPromise<GetCrashBetAggregateType<T>>

    /**
     * Group by CrashBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashBetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrashBetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrashBetGroupByArgs['orderBy'] }
        : { orderBy?: CrashBetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrashBetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrashBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrashBet model
   */
  readonly fields: CrashBetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrashBet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrashBetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    round<T extends CrashRoundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CrashRoundDefaultArgs<ExtArgs>>): Prisma__CrashRoundClient<$Result.GetResult<Prisma.$CrashRoundPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends CrashBet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CrashBet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrashBet model
   */ 
  interface CrashBetFieldRefs {
    readonly id: FieldRef<"CrashBet", 'Int'>
    readonly roundId: FieldRef<"CrashBet", 'Int'>
    readonly userId: FieldRef<"CrashBet", 'Int'>
    readonly tokenId: FieldRef<"CrashBet", 'Int'>
    readonly betAmount: FieldRef<"CrashBet", 'Decimal'>
    readonly exitMultiplier: FieldRef<"CrashBet", 'Decimal'>
    readonly winnings: FieldRef<"CrashBet", 'Decimal'>
    readonly result: FieldRef<"CrashBet", 'String'>
    readonly createdAt: FieldRef<"CrashBet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrashBet findUnique
   */
  export type CrashBetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * Filter, which CrashBet to fetch.
     */
    where: CrashBetWhereUniqueInput
  }

  /**
   * CrashBet findUniqueOrThrow
   */
  export type CrashBetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * Filter, which CrashBet to fetch.
     */
    where: CrashBetWhereUniqueInput
  }

  /**
   * CrashBet findFirst
   */
  export type CrashBetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * Filter, which CrashBet to fetch.
     */
    where?: CrashBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashBets to fetch.
     */
    orderBy?: CrashBetOrderByWithRelationInput | CrashBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrashBets.
     */
    cursor?: CrashBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrashBets.
     */
    distinct?: CrashBetScalarFieldEnum | CrashBetScalarFieldEnum[]
  }

  /**
   * CrashBet findFirstOrThrow
   */
  export type CrashBetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * Filter, which CrashBet to fetch.
     */
    where?: CrashBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashBets to fetch.
     */
    orderBy?: CrashBetOrderByWithRelationInput | CrashBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrashBets.
     */
    cursor?: CrashBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrashBets.
     */
    distinct?: CrashBetScalarFieldEnum | CrashBetScalarFieldEnum[]
  }

  /**
   * CrashBet findMany
   */
  export type CrashBetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * Filter, which CrashBets to fetch.
     */
    where?: CrashBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashBets to fetch.
     */
    orderBy?: CrashBetOrderByWithRelationInput | CrashBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrashBets.
     */
    cursor?: CrashBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashBets.
     */
    skip?: number
    distinct?: CrashBetScalarFieldEnum | CrashBetScalarFieldEnum[]
  }

  /**
   * CrashBet create
   */
  export type CrashBetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * The data needed to create a CrashBet.
     */
    data: XOR<CrashBetCreateInput, CrashBetUncheckedCreateInput>
  }

  /**
   * CrashBet createMany
   */
  export type CrashBetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrashBets.
     */
    data: CrashBetCreateManyInput | CrashBetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrashBet createManyAndReturn
   */
  export type CrashBetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CrashBets.
     */
    data: CrashBetCreateManyInput | CrashBetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrashBet update
   */
  export type CrashBetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * The data needed to update a CrashBet.
     */
    data: XOR<CrashBetUpdateInput, CrashBetUncheckedUpdateInput>
    /**
     * Choose, which CrashBet to update.
     */
    where: CrashBetWhereUniqueInput
  }

  /**
   * CrashBet updateMany
   */
  export type CrashBetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrashBets.
     */
    data: XOR<CrashBetUpdateManyMutationInput, CrashBetUncheckedUpdateManyInput>
    /**
     * Filter which CrashBets to update
     */
    where?: CrashBetWhereInput
  }

  /**
   * CrashBet upsert
   */
  export type CrashBetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * The filter to search for the CrashBet to update in case it exists.
     */
    where: CrashBetWhereUniqueInput
    /**
     * In case the CrashBet found by the `where` argument doesn't exist, create a new CrashBet with this data.
     */
    create: XOR<CrashBetCreateInput, CrashBetUncheckedCreateInput>
    /**
     * In case the CrashBet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrashBetUpdateInput, CrashBetUncheckedUpdateInput>
  }

  /**
   * CrashBet delete
   */
  export type CrashBetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    /**
     * Filter which CrashBet to delete.
     */
    where: CrashBetWhereUniqueInput
  }

  /**
   * CrashBet deleteMany
   */
  export type CrashBetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrashBets to delete
     */
    where?: CrashBetWhereInput
  }

  /**
   * CrashBet.transactions
   */
  export type CrashBet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    where?: CrashTransactionWhereInput
    orderBy?: CrashTransactionOrderByWithRelationInput | CrashTransactionOrderByWithRelationInput[]
    cursor?: CrashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrashTransactionScalarFieldEnum | CrashTransactionScalarFieldEnum[]
  }

  /**
   * CrashBet without action
   */
  export type CrashBetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
  }


  /**
   * Model CrashTransaction
   */

  export type AggregateCrashTransaction = {
    _count: CrashTransactionCountAggregateOutputType | null
    _avg: CrashTransactionAvgAggregateOutputType | null
    _sum: CrashTransactionSumAggregateOutputType | null
    _min: CrashTransactionMinAggregateOutputType | null
    _max: CrashTransactionMaxAggregateOutputType | null
  }

  export type CrashTransactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    betId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type CrashTransactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    betId: number | null
    tokenId: number | null
    amount: Decimal | null
  }

  export type CrashTransactionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    betId: number | null
    tokenId: number | null
    amount: Decimal | null
    type: string | null
    createdAt: Date | null
  }

  export type CrashTransactionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    betId: number | null
    tokenId: number | null
    amount: Decimal | null
    type: string | null
    createdAt: Date | null
  }

  export type CrashTransactionCountAggregateOutputType = {
    id: number
    userId: number
    betId: number
    tokenId: number
    amount: number
    type: number
    createdAt: number
    _all: number
  }


  export type CrashTransactionAvgAggregateInputType = {
    id?: true
    userId?: true
    betId?: true
    tokenId?: true
    amount?: true
  }

  export type CrashTransactionSumAggregateInputType = {
    id?: true
    userId?: true
    betId?: true
    tokenId?: true
    amount?: true
  }

  export type CrashTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    betId?: true
    tokenId?: true
    amount?: true
    type?: true
    createdAt?: true
  }

  export type CrashTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    betId?: true
    tokenId?: true
    amount?: true
    type?: true
    createdAt?: true
  }

  export type CrashTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    betId?: true
    tokenId?: true
    amount?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type CrashTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrashTransaction to aggregate.
     */
    where?: CrashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashTransactions to fetch.
     */
    orderBy?: CrashTransactionOrderByWithRelationInput | CrashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrashTransactions
    **/
    _count?: true | CrashTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrashTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrashTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrashTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrashTransactionMaxAggregateInputType
  }

  export type GetCrashTransactionAggregateType<T extends CrashTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCrashTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrashTransaction[P]>
      : GetScalarType<T[P], AggregateCrashTransaction[P]>
  }




  export type CrashTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrashTransactionWhereInput
    orderBy?: CrashTransactionOrderByWithAggregationInput | CrashTransactionOrderByWithAggregationInput[]
    by: CrashTransactionScalarFieldEnum[] | CrashTransactionScalarFieldEnum
    having?: CrashTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrashTransactionCountAggregateInputType | true
    _avg?: CrashTransactionAvgAggregateInputType
    _sum?: CrashTransactionSumAggregateInputType
    _min?: CrashTransactionMinAggregateInputType
    _max?: CrashTransactionMaxAggregateInputType
  }

  export type CrashTransactionGroupByOutputType = {
    id: number
    userId: number
    betId: number | null
    tokenId: number
    amount: Decimal
    type: string
    createdAt: Date
    _count: CrashTransactionCountAggregateOutputType | null
    _avg: CrashTransactionAvgAggregateOutputType | null
    _sum: CrashTransactionSumAggregateOutputType | null
    _min: CrashTransactionMinAggregateOutputType | null
    _max: CrashTransactionMaxAggregateOutputType | null
  }

  type GetCrashTransactionGroupByPayload<T extends CrashTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrashTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrashTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrashTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CrashTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CrashTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    betId?: boolean
    tokenId?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bet?: boolean | CrashTransaction$betArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crashTransaction"]>

  export type CrashTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    betId?: boolean
    tokenId?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bet?: boolean | CrashTransaction$betArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crashTransaction"]>

  export type CrashTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    betId?: boolean
    tokenId?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type CrashTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bet?: boolean | CrashTransaction$betArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type CrashTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bet?: boolean | CrashTransaction$betArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $CrashTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrashTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bet: Prisma.$CrashBetPayload<ExtArgs> | null
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      betId: number | null
      tokenId: number
      amount: Prisma.Decimal
      type: string
      createdAt: Date
    }, ExtArgs["result"]["crashTransaction"]>
    composites: {}
  }

  type CrashTransactionGetPayload<S extends boolean | null | undefined | CrashTransactionDefaultArgs> = $Result.GetResult<Prisma.$CrashTransactionPayload, S>

  type CrashTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CrashTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CrashTransactionCountAggregateInputType | true
    }

  export interface CrashTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrashTransaction'], meta: { name: 'CrashTransaction' } }
    /**
     * Find zero or one CrashTransaction that matches the filter.
     * @param {CrashTransactionFindUniqueArgs} args - Arguments to find a CrashTransaction
     * @example
     * // Get one CrashTransaction
     * const crashTransaction = await prisma.crashTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrashTransactionFindUniqueArgs>(args: SelectSubset<T, CrashTransactionFindUniqueArgs<ExtArgs>>): Prisma__CrashTransactionClient<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CrashTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CrashTransactionFindUniqueOrThrowArgs} args - Arguments to find a CrashTransaction
     * @example
     * // Get one CrashTransaction
     * const crashTransaction = await prisma.crashTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrashTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CrashTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrashTransactionClient<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CrashTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashTransactionFindFirstArgs} args - Arguments to find a CrashTransaction
     * @example
     * // Get one CrashTransaction
     * const crashTransaction = await prisma.crashTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrashTransactionFindFirstArgs>(args?: SelectSubset<T, CrashTransactionFindFirstArgs<ExtArgs>>): Prisma__CrashTransactionClient<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CrashTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashTransactionFindFirstOrThrowArgs} args - Arguments to find a CrashTransaction
     * @example
     * // Get one CrashTransaction
     * const crashTransaction = await prisma.crashTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrashTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CrashTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrashTransactionClient<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CrashTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrashTransactions
     * const crashTransactions = await prisma.crashTransaction.findMany()
     * 
     * // Get first 10 CrashTransactions
     * const crashTransactions = await prisma.crashTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crashTransactionWithIdOnly = await prisma.crashTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrashTransactionFindManyArgs>(args?: SelectSubset<T, CrashTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CrashTransaction.
     * @param {CrashTransactionCreateArgs} args - Arguments to create a CrashTransaction.
     * @example
     * // Create one CrashTransaction
     * const CrashTransaction = await prisma.crashTransaction.create({
     *   data: {
     *     // ... data to create a CrashTransaction
     *   }
     * })
     * 
     */
    create<T extends CrashTransactionCreateArgs>(args: SelectSubset<T, CrashTransactionCreateArgs<ExtArgs>>): Prisma__CrashTransactionClient<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CrashTransactions.
     * @param {CrashTransactionCreateManyArgs} args - Arguments to create many CrashTransactions.
     * @example
     * // Create many CrashTransactions
     * const crashTransaction = await prisma.crashTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrashTransactionCreateManyArgs>(args?: SelectSubset<T, CrashTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrashTransactions and returns the data saved in the database.
     * @param {CrashTransactionCreateManyAndReturnArgs} args - Arguments to create many CrashTransactions.
     * @example
     * // Create many CrashTransactions
     * const crashTransaction = await prisma.crashTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrashTransactions and only return the `id`
     * const crashTransactionWithIdOnly = await prisma.crashTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrashTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CrashTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CrashTransaction.
     * @param {CrashTransactionDeleteArgs} args - Arguments to delete one CrashTransaction.
     * @example
     * // Delete one CrashTransaction
     * const CrashTransaction = await prisma.crashTransaction.delete({
     *   where: {
     *     // ... filter to delete one CrashTransaction
     *   }
     * })
     * 
     */
    delete<T extends CrashTransactionDeleteArgs>(args: SelectSubset<T, CrashTransactionDeleteArgs<ExtArgs>>): Prisma__CrashTransactionClient<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CrashTransaction.
     * @param {CrashTransactionUpdateArgs} args - Arguments to update one CrashTransaction.
     * @example
     * // Update one CrashTransaction
     * const crashTransaction = await prisma.crashTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrashTransactionUpdateArgs>(args: SelectSubset<T, CrashTransactionUpdateArgs<ExtArgs>>): Prisma__CrashTransactionClient<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CrashTransactions.
     * @param {CrashTransactionDeleteManyArgs} args - Arguments to filter CrashTransactions to delete.
     * @example
     * // Delete a few CrashTransactions
     * const { count } = await prisma.crashTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrashTransactionDeleteManyArgs>(args?: SelectSubset<T, CrashTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrashTransactions
     * const crashTransaction = await prisma.crashTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrashTransactionUpdateManyArgs>(args: SelectSubset<T, CrashTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CrashTransaction.
     * @param {CrashTransactionUpsertArgs} args - Arguments to update or create a CrashTransaction.
     * @example
     * // Update or create a CrashTransaction
     * const crashTransaction = await prisma.crashTransaction.upsert({
     *   create: {
     *     // ... data to create a CrashTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrashTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CrashTransactionUpsertArgs>(args: SelectSubset<T, CrashTransactionUpsertArgs<ExtArgs>>): Prisma__CrashTransactionClient<$Result.GetResult<Prisma.$CrashTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CrashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashTransactionCountArgs} args - Arguments to filter CrashTransactions to count.
     * @example
     * // Count the number of CrashTransactions
     * const count = await prisma.crashTransaction.count({
     *   where: {
     *     // ... the filter for the CrashTransactions we want to count
     *   }
     * })
    **/
    count<T extends CrashTransactionCountArgs>(
      args?: Subset<T, CrashTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrashTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrashTransactionAggregateArgs>(args: Subset<T, CrashTransactionAggregateArgs>): Prisma.PrismaPromise<GetCrashTransactionAggregateType<T>>

    /**
     * Group by CrashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrashTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrashTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrashTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CrashTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrashTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrashTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrashTransaction model
   */
  readonly fields: CrashTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrashTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrashTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bet<T extends CrashTransaction$betArgs<ExtArgs> = {}>(args?: Subset<T, CrashTransaction$betArgs<ExtArgs>>): Prisma__CrashBetClient<$Result.GetResult<Prisma.$CrashBetPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrashTransaction model
   */ 
  interface CrashTransactionFieldRefs {
    readonly id: FieldRef<"CrashTransaction", 'Int'>
    readonly userId: FieldRef<"CrashTransaction", 'Int'>
    readonly betId: FieldRef<"CrashTransaction", 'Int'>
    readonly tokenId: FieldRef<"CrashTransaction", 'Int'>
    readonly amount: FieldRef<"CrashTransaction", 'Decimal'>
    readonly type: FieldRef<"CrashTransaction", 'String'>
    readonly createdAt: FieldRef<"CrashTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CrashTransaction findUnique
   */
  export type CrashTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CrashTransaction to fetch.
     */
    where: CrashTransactionWhereUniqueInput
  }

  /**
   * CrashTransaction findUniqueOrThrow
   */
  export type CrashTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CrashTransaction to fetch.
     */
    where: CrashTransactionWhereUniqueInput
  }

  /**
   * CrashTransaction findFirst
   */
  export type CrashTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CrashTransaction to fetch.
     */
    where?: CrashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashTransactions to fetch.
     */
    orderBy?: CrashTransactionOrderByWithRelationInput | CrashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrashTransactions.
     */
    cursor?: CrashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrashTransactions.
     */
    distinct?: CrashTransactionScalarFieldEnum | CrashTransactionScalarFieldEnum[]
  }

  /**
   * CrashTransaction findFirstOrThrow
   */
  export type CrashTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CrashTransaction to fetch.
     */
    where?: CrashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashTransactions to fetch.
     */
    orderBy?: CrashTransactionOrderByWithRelationInput | CrashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrashTransactions.
     */
    cursor?: CrashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrashTransactions.
     */
    distinct?: CrashTransactionScalarFieldEnum | CrashTransactionScalarFieldEnum[]
  }

  /**
   * CrashTransaction findMany
   */
  export type CrashTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CrashTransactions to fetch.
     */
    where?: CrashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrashTransactions to fetch.
     */
    orderBy?: CrashTransactionOrderByWithRelationInput | CrashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrashTransactions.
     */
    cursor?: CrashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrashTransactions.
     */
    skip?: number
    distinct?: CrashTransactionScalarFieldEnum | CrashTransactionScalarFieldEnum[]
  }

  /**
   * CrashTransaction create
   */
  export type CrashTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CrashTransaction.
     */
    data: XOR<CrashTransactionCreateInput, CrashTransactionUncheckedCreateInput>
  }

  /**
   * CrashTransaction createMany
   */
  export type CrashTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrashTransactions.
     */
    data: CrashTransactionCreateManyInput | CrashTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrashTransaction createManyAndReturn
   */
  export type CrashTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CrashTransactions.
     */
    data: CrashTransactionCreateManyInput | CrashTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrashTransaction update
   */
  export type CrashTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CrashTransaction.
     */
    data: XOR<CrashTransactionUpdateInput, CrashTransactionUncheckedUpdateInput>
    /**
     * Choose, which CrashTransaction to update.
     */
    where: CrashTransactionWhereUniqueInput
  }

  /**
   * CrashTransaction updateMany
   */
  export type CrashTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrashTransactions.
     */
    data: XOR<CrashTransactionUpdateManyMutationInput, CrashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CrashTransactions to update
     */
    where?: CrashTransactionWhereInput
  }

  /**
   * CrashTransaction upsert
   */
  export type CrashTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CrashTransaction to update in case it exists.
     */
    where: CrashTransactionWhereUniqueInput
    /**
     * In case the CrashTransaction found by the `where` argument doesn't exist, create a new CrashTransaction with this data.
     */
    create: XOR<CrashTransactionCreateInput, CrashTransactionUncheckedCreateInput>
    /**
     * In case the CrashTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrashTransactionUpdateInput, CrashTransactionUncheckedUpdateInput>
  }

  /**
   * CrashTransaction delete
   */
  export type CrashTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
    /**
     * Filter which CrashTransaction to delete.
     */
    where: CrashTransactionWhereUniqueInput
  }

  /**
   * CrashTransaction deleteMany
   */
  export type CrashTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrashTransactions to delete
     */
    where?: CrashTransactionWhereInput
  }

  /**
   * CrashTransaction.bet
   */
  export type CrashTransaction$betArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashBet
     */
    select?: CrashBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashBetInclude<ExtArgs> | null
    where?: CrashBetWhereInput
  }

  /**
   * CrashTransaction without action
   */
  export type CrashTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrashTransaction
     */
    select?: CrashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrashTransactionInclude<ExtArgs> | null
  }


  /**
   * Model MinesweeperDifficulty
   */

  export type AggregateMinesweeperDifficulty = {
    _count: MinesweeperDifficultyCountAggregateOutputType | null
    _avg: MinesweeperDifficultyAvgAggregateOutputType | null
    _sum: MinesweeperDifficultySumAggregateOutputType | null
    _min: MinesweeperDifficultyMinAggregateOutputType | null
    _max: MinesweeperDifficultyMaxAggregateOutputType | null
  }

  export type MinesweeperDifficultyAvgAggregateOutputType = {
    id: number | null
    minesCount: number | null
    gridSize: number | null
    multiplier: number | null
  }

  export type MinesweeperDifficultySumAggregateOutputType = {
    id: number | null
    minesCount: number | null
    gridSize: number | null
    multiplier: number | null
  }

  export type MinesweeperDifficultyMinAggregateOutputType = {
    id: number | null
    name: string | null
    minesCount: number | null
    gridSize: number | null
    multiplier: number | null
    createdAt: Date | null
  }

  export type MinesweeperDifficultyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    minesCount: number | null
    gridSize: number | null
    multiplier: number | null
    createdAt: Date | null
  }

  export type MinesweeperDifficultyCountAggregateOutputType = {
    id: number
    name: number
    minesCount: number
    gridSize: number
    multiplier: number
    createdAt: number
    _all: number
  }


  export type MinesweeperDifficultyAvgAggregateInputType = {
    id?: true
    minesCount?: true
    gridSize?: true
    multiplier?: true
  }

  export type MinesweeperDifficultySumAggregateInputType = {
    id?: true
    minesCount?: true
    gridSize?: true
    multiplier?: true
  }

  export type MinesweeperDifficultyMinAggregateInputType = {
    id?: true
    name?: true
    minesCount?: true
    gridSize?: true
    multiplier?: true
    createdAt?: true
  }

  export type MinesweeperDifficultyMaxAggregateInputType = {
    id?: true
    name?: true
    minesCount?: true
    gridSize?: true
    multiplier?: true
    createdAt?: true
  }

  export type MinesweeperDifficultyCountAggregateInputType = {
    id?: true
    name?: true
    minesCount?: true
    gridSize?: true
    multiplier?: true
    createdAt?: true
    _all?: true
  }

  export type MinesweeperDifficultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinesweeperDifficulty to aggregate.
     */
    where?: MinesweeperDifficultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperDifficulties to fetch.
     */
    orderBy?: MinesweeperDifficultyOrderByWithRelationInput | MinesweeperDifficultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MinesweeperDifficultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperDifficulties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperDifficulties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MinesweeperDifficulties
    **/
    _count?: true | MinesweeperDifficultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MinesweeperDifficultyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MinesweeperDifficultySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinesweeperDifficultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinesweeperDifficultyMaxAggregateInputType
  }

  export type GetMinesweeperDifficultyAggregateType<T extends MinesweeperDifficultyAggregateArgs> = {
        [P in keyof T & keyof AggregateMinesweeperDifficulty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinesweeperDifficulty[P]>
      : GetScalarType<T[P], AggregateMinesweeperDifficulty[P]>
  }




  export type MinesweeperDifficultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinesweeperDifficultyWhereInput
    orderBy?: MinesweeperDifficultyOrderByWithAggregationInput | MinesweeperDifficultyOrderByWithAggregationInput[]
    by: MinesweeperDifficultyScalarFieldEnum[] | MinesweeperDifficultyScalarFieldEnum
    having?: MinesweeperDifficultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinesweeperDifficultyCountAggregateInputType | true
    _avg?: MinesweeperDifficultyAvgAggregateInputType
    _sum?: MinesweeperDifficultySumAggregateInputType
    _min?: MinesweeperDifficultyMinAggregateInputType
    _max?: MinesweeperDifficultyMaxAggregateInputType
  }

  export type MinesweeperDifficultyGroupByOutputType = {
    id: number
    name: string
    minesCount: number
    gridSize: number
    multiplier: number
    createdAt: Date
    _count: MinesweeperDifficultyCountAggregateOutputType | null
    _avg: MinesweeperDifficultyAvgAggregateOutputType | null
    _sum: MinesweeperDifficultySumAggregateOutputType | null
    _min: MinesweeperDifficultyMinAggregateOutputType | null
    _max: MinesweeperDifficultyMaxAggregateOutputType | null
  }

  type GetMinesweeperDifficultyGroupByPayload<T extends MinesweeperDifficultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinesweeperDifficultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinesweeperDifficultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinesweeperDifficultyGroupByOutputType[P]>
            : GetScalarType<T[P], MinesweeperDifficultyGroupByOutputType[P]>
        }
      >
    >


  export type MinesweeperDifficultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    minesCount?: boolean
    gridSize?: boolean
    multiplier?: boolean
    createdAt?: boolean
    games?: boolean | MinesweeperDifficulty$gamesArgs<ExtArgs>
    _count?: boolean | MinesweeperDifficultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minesweeperDifficulty"]>

  export type MinesweeperDifficultySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    minesCount?: boolean
    gridSize?: boolean
    multiplier?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["minesweeperDifficulty"]>

  export type MinesweeperDifficultySelectScalar = {
    id?: boolean
    name?: boolean
    minesCount?: boolean
    gridSize?: boolean
    multiplier?: boolean
    createdAt?: boolean
  }

  export type MinesweeperDifficultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | MinesweeperDifficulty$gamesArgs<ExtArgs>
    _count?: boolean | MinesweeperDifficultyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MinesweeperDifficultyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MinesweeperDifficultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MinesweeperDifficulty"
    objects: {
      games: Prisma.$MinesweeperGamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      minesCount: number
      gridSize: number
      multiplier: number
      createdAt: Date
    }, ExtArgs["result"]["minesweeperDifficulty"]>
    composites: {}
  }

  type MinesweeperDifficultyGetPayload<S extends boolean | null | undefined | MinesweeperDifficultyDefaultArgs> = $Result.GetResult<Prisma.$MinesweeperDifficultyPayload, S>

  type MinesweeperDifficultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MinesweeperDifficultyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MinesweeperDifficultyCountAggregateInputType | true
    }

  export interface MinesweeperDifficultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MinesweeperDifficulty'], meta: { name: 'MinesweeperDifficulty' } }
    /**
     * Find zero or one MinesweeperDifficulty that matches the filter.
     * @param {MinesweeperDifficultyFindUniqueArgs} args - Arguments to find a MinesweeperDifficulty
     * @example
     * // Get one MinesweeperDifficulty
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MinesweeperDifficultyFindUniqueArgs>(args: SelectSubset<T, MinesweeperDifficultyFindUniqueArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MinesweeperDifficulty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MinesweeperDifficultyFindUniqueOrThrowArgs} args - Arguments to find a MinesweeperDifficulty
     * @example
     * // Get one MinesweeperDifficulty
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MinesweeperDifficultyFindUniqueOrThrowArgs>(args: SelectSubset<T, MinesweeperDifficultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MinesweeperDifficulty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperDifficultyFindFirstArgs} args - Arguments to find a MinesweeperDifficulty
     * @example
     * // Get one MinesweeperDifficulty
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MinesweeperDifficultyFindFirstArgs>(args?: SelectSubset<T, MinesweeperDifficultyFindFirstArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MinesweeperDifficulty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperDifficultyFindFirstOrThrowArgs} args - Arguments to find a MinesweeperDifficulty
     * @example
     * // Get one MinesweeperDifficulty
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MinesweeperDifficultyFindFirstOrThrowArgs>(args?: SelectSubset<T, MinesweeperDifficultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MinesweeperDifficulties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperDifficultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MinesweeperDifficulties
     * const minesweeperDifficulties = await prisma.minesweeperDifficulty.findMany()
     * 
     * // Get first 10 MinesweeperDifficulties
     * const minesweeperDifficulties = await prisma.minesweeperDifficulty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const minesweeperDifficultyWithIdOnly = await prisma.minesweeperDifficulty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MinesweeperDifficultyFindManyArgs>(args?: SelectSubset<T, MinesweeperDifficultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MinesweeperDifficulty.
     * @param {MinesweeperDifficultyCreateArgs} args - Arguments to create a MinesweeperDifficulty.
     * @example
     * // Create one MinesweeperDifficulty
     * const MinesweeperDifficulty = await prisma.minesweeperDifficulty.create({
     *   data: {
     *     // ... data to create a MinesweeperDifficulty
     *   }
     * })
     * 
     */
    create<T extends MinesweeperDifficultyCreateArgs>(args: SelectSubset<T, MinesweeperDifficultyCreateArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MinesweeperDifficulties.
     * @param {MinesweeperDifficultyCreateManyArgs} args - Arguments to create many MinesweeperDifficulties.
     * @example
     * // Create many MinesweeperDifficulties
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MinesweeperDifficultyCreateManyArgs>(args?: SelectSubset<T, MinesweeperDifficultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MinesweeperDifficulties and returns the data saved in the database.
     * @param {MinesweeperDifficultyCreateManyAndReturnArgs} args - Arguments to create many MinesweeperDifficulties.
     * @example
     * // Create many MinesweeperDifficulties
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MinesweeperDifficulties and only return the `id`
     * const minesweeperDifficultyWithIdOnly = await prisma.minesweeperDifficulty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MinesweeperDifficultyCreateManyAndReturnArgs>(args?: SelectSubset<T, MinesweeperDifficultyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MinesweeperDifficulty.
     * @param {MinesweeperDifficultyDeleteArgs} args - Arguments to delete one MinesweeperDifficulty.
     * @example
     * // Delete one MinesweeperDifficulty
     * const MinesweeperDifficulty = await prisma.minesweeperDifficulty.delete({
     *   where: {
     *     // ... filter to delete one MinesweeperDifficulty
     *   }
     * })
     * 
     */
    delete<T extends MinesweeperDifficultyDeleteArgs>(args: SelectSubset<T, MinesweeperDifficultyDeleteArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MinesweeperDifficulty.
     * @param {MinesweeperDifficultyUpdateArgs} args - Arguments to update one MinesweeperDifficulty.
     * @example
     * // Update one MinesweeperDifficulty
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MinesweeperDifficultyUpdateArgs>(args: SelectSubset<T, MinesweeperDifficultyUpdateArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MinesweeperDifficulties.
     * @param {MinesweeperDifficultyDeleteManyArgs} args - Arguments to filter MinesweeperDifficulties to delete.
     * @example
     * // Delete a few MinesweeperDifficulties
     * const { count } = await prisma.minesweeperDifficulty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MinesweeperDifficultyDeleteManyArgs>(args?: SelectSubset<T, MinesweeperDifficultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MinesweeperDifficulties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperDifficultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MinesweeperDifficulties
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MinesweeperDifficultyUpdateManyArgs>(args: SelectSubset<T, MinesweeperDifficultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MinesweeperDifficulty.
     * @param {MinesweeperDifficultyUpsertArgs} args - Arguments to update or create a MinesweeperDifficulty.
     * @example
     * // Update or create a MinesweeperDifficulty
     * const minesweeperDifficulty = await prisma.minesweeperDifficulty.upsert({
     *   create: {
     *     // ... data to create a MinesweeperDifficulty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MinesweeperDifficulty we want to update
     *   }
     * })
     */
    upsert<T extends MinesweeperDifficultyUpsertArgs>(args: SelectSubset<T, MinesweeperDifficultyUpsertArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MinesweeperDifficulties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperDifficultyCountArgs} args - Arguments to filter MinesweeperDifficulties to count.
     * @example
     * // Count the number of MinesweeperDifficulties
     * const count = await prisma.minesweeperDifficulty.count({
     *   where: {
     *     // ... the filter for the MinesweeperDifficulties we want to count
     *   }
     * })
    **/
    count<T extends MinesweeperDifficultyCountArgs>(
      args?: Subset<T, MinesweeperDifficultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinesweeperDifficultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MinesweeperDifficulty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperDifficultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinesweeperDifficultyAggregateArgs>(args: Subset<T, MinesweeperDifficultyAggregateArgs>): Prisma.PrismaPromise<GetMinesweeperDifficultyAggregateType<T>>

    /**
     * Group by MinesweeperDifficulty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperDifficultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MinesweeperDifficultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinesweeperDifficultyGroupByArgs['orderBy'] }
        : { orderBy?: MinesweeperDifficultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MinesweeperDifficultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinesweeperDifficultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MinesweeperDifficulty model
   */
  readonly fields: MinesweeperDifficultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MinesweeperDifficulty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinesweeperDifficultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends MinesweeperDifficulty$gamesArgs<ExtArgs> = {}>(args?: Subset<T, MinesweeperDifficulty$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MinesweeperDifficulty model
   */ 
  interface MinesweeperDifficultyFieldRefs {
    readonly id: FieldRef<"MinesweeperDifficulty", 'Int'>
    readonly name: FieldRef<"MinesweeperDifficulty", 'String'>
    readonly minesCount: FieldRef<"MinesweeperDifficulty", 'Int'>
    readonly gridSize: FieldRef<"MinesweeperDifficulty", 'Int'>
    readonly multiplier: FieldRef<"MinesweeperDifficulty", 'Float'>
    readonly createdAt: FieldRef<"MinesweeperDifficulty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MinesweeperDifficulty findUnique
   */
  export type MinesweeperDifficultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperDifficulty to fetch.
     */
    where: MinesweeperDifficultyWhereUniqueInput
  }

  /**
   * MinesweeperDifficulty findUniqueOrThrow
   */
  export type MinesweeperDifficultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperDifficulty to fetch.
     */
    where: MinesweeperDifficultyWhereUniqueInput
  }

  /**
   * MinesweeperDifficulty findFirst
   */
  export type MinesweeperDifficultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperDifficulty to fetch.
     */
    where?: MinesweeperDifficultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperDifficulties to fetch.
     */
    orderBy?: MinesweeperDifficultyOrderByWithRelationInput | MinesweeperDifficultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinesweeperDifficulties.
     */
    cursor?: MinesweeperDifficultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperDifficulties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperDifficulties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinesweeperDifficulties.
     */
    distinct?: MinesweeperDifficultyScalarFieldEnum | MinesweeperDifficultyScalarFieldEnum[]
  }

  /**
   * MinesweeperDifficulty findFirstOrThrow
   */
  export type MinesweeperDifficultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperDifficulty to fetch.
     */
    where?: MinesweeperDifficultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperDifficulties to fetch.
     */
    orderBy?: MinesweeperDifficultyOrderByWithRelationInput | MinesweeperDifficultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinesweeperDifficulties.
     */
    cursor?: MinesweeperDifficultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperDifficulties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperDifficulties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinesweeperDifficulties.
     */
    distinct?: MinesweeperDifficultyScalarFieldEnum | MinesweeperDifficultyScalarFieldEnum[]
  }

  /**
   * MinesweeperDifficulty findMany
   */
  export type MinesweeperDifficultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperDifficulties to fetch.
     */
    where?: MinesweeperDifficultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperDifficulties to fetch.
     */
    orderBy?: MinesweeperDifficultyOrderByWithRelationInput | MinesweeperDifficultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MinesweeperDifficulties.
     */
    cursor?: MinesweeperDifficultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperDifficulties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperDifficulties.
     */
    skip?: number
    distinct?: MinesweeperDifficultyScalarFieldEnum | MinesweeperDifficultyScalarFieldEnum[]
  }

  /**
   * MinesweeperDifficulty create
   */
  export type MinesweeperDifficultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * The data needed to create a MinesweeperDifficulty.
     */
    data: XOR<MinesweeperDifficultyCreateInput, MinesweeperDifficultyUncheckedCreateInput>
  }

  /**
   * MinesweeperDifficulty createMany
   */
  export type MinesweeperDifficultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MinesweeperDifficulties.
     */
    data: MinesweeperDifficultyCreateManyInput | MinesweeperDifficultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MinesweeperDifficulty createManyAndReturn
   */
  export type MinesweeperDifficultyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MinesweeperDifficulties.
     */
    data: MinesweeperDifficultyCreateManyInput | MinesweeperDifficultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MinesweeperDifficulty update
   */
  export type MinesweeperDifficultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * The data needed to update a MinesweeperDifficulty.
     */
    data: XOR<MinesweeperDifficultyUpdateInput, MinesweeperDifficultyUncheckedUpdateInput>
    /**
     * Choose, which MinesweeperDifficulty to update.
     */
    where: MinesweeperDifficultyWhereUniqueInput
  }

  /**
   * MinesweeperDifficulty updateMany
   */
  export type MinesweeperDifficultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MinesweeperDifficulties.
     */
    data: XOR<MinesweeperDifficultyUpdateManyMutationInput, MinesweeperDifficultyUncheckedUpdateManyInput>
    /**
     * Filter which MinesweeperDifficulties to update
     */
    where?: MinesweeperDifficultyWhereInput
  }

  /**
   * MinesweeperDifficulty upsert
   */
  export type MinesweeperDifficultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * The filter to search for the MinesweeperDifficulty to update in case it exists.
     */
    where: MinesweeperDifficultyWhereUniqueInput
    /**
     * In case the MinesweeperDifficulty found by the `where` argument doesn't exist, create a new MinesweeperDifficulty with this data.
     */
    create: XOR<MinesweeperDifficultyCreateInput, MinesweeperDifficultyUncheckedCreateInput>
    /**
     * In case the MinesweeperDifficulty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MinesweeperDifficultyUpdateInput, MinesweeperDifficultyUncheckedUpdateInput>
  }

  /**
   * MinesweeperDifficulty delete
   */
  export type MinesweeperDifficultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
    /**
     * Filter which MinesweeperDifficulty to delete.
     */
    where: MinesweeperDifficultyWhereUniqueInput
  }

  /**
   * MinesweeperDifficulty deleteMany
   */
  export type MinesweeperDifficultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinesweeperDifficulties to delete
     */
    where?: MinesweeperDifficultyWhereInput
  }

  /**
   * MinesweeperDifficulty.games
   */
  export type MinesweeperDifficulty$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    where?: MinesweeperGameWhereInput
    orderBy?: MinesweeperGameOrderByWithRelationInput | MinesweeperGameOrderByWithRelationInput[]
    cursor?: MinesweeperGameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinesweeperGameScalarFieldEnum | MinesweeperGameScalarFieldEnum[]
  }

  /**
   * MinesweeperDifficulty without action
   */
  export type MinesweeperDifficultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperDifficulty
     */
    select?: MinesweeperDifficultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperDifficultyInclude<ExtArgs> | null
  }


  /**
   * Model MinesweeperGame
   */

  export type AggregateMinesweeperGame = {
    _count: MinesweeperGameCountAggregateOutputType | null
    _avg: MinesweeperGameAvgAggregateOutputType | null
    _sum: MinesweeperGameSumAggregateOutputType | null
    _min: MinesweeperGameMinAggregateOutputType | null
    _max: MinesweeperGameMaxAggregateOutputType | null
  }

  export type MinesweeperGameAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    difficultyId: number | null
    revealedCells: number | null
    flaggedCells: number | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    multiplier: number | null
  }

  export type MinesweeperGameSumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    difficultyId: number | null
    revealedCells: number | null
    flaggedCells: number | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    multiplier: number | null
  }

  export type MinesweeperGameMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    difficultyId: number | null
    status: string | null
    revealedCells: number | null
    flaggedCells: number | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    multiplier: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MinesweeperGameMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    difficultyId: number | null
    status: string | null
    revealedCells: number | null
    flaggedCells: number | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    multiplier: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MinesweeperGameCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    difficultyId: number
    gameState: number
    minesPositions: number
    status: number
    revealedCells: number
    flaggedCells: number
    betAmount: number
    winAmount: number
    multiplier: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MinesweeperGameAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    difficultyId?: true
    revealedCells?: true
    flaggedCells?: true
    betAmount?: true
    winAmount?: true
    multiplier?: true
  }

  export type MinesweeperGameSumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    difficultyId?: true
    revealedCells?: true
    flaggedCells?: true
    betAmount?: true
    winAmount?: true
    multiplier?: true
  }

  export type MinesweeperGameMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    difficultyId?: true
    status?: true
    revealedCells?: true
    flaggedCells?: true
    betAmount?: true
    winAmount?: true
    multiplier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MinesweeperGameMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    difficultyId?: true
    status?: true
    revealedCells?: true
    flaggedCells?: true
    betAmount?: true
    winAmount?: true
    multiplier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MinesweeperGameCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    difficultyId?: true
    gameState?: true
    minesPositions?: true
    status?: true
    revealedCells?: true
    flaggedCells?: true
    betAmount?: true
    winAmount?: true
    multiplier?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MinesweeperGameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinesweeperGame to aggregate.
     */
    where?: MinesweeperGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperGames to fetch.
     */
    orderBy?: MinesweeperGameOrderByWithRelationInput | MinesweeperGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MinesweeperGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MinesweeperGames
    **/
    _count?: true | MinesweeperGameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MinesweeperGameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MinesweeperGameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinesweeperGameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinesweeperGameMaxAggregateInputType
  }

  export type GetMinesweeperGameAggregateType<T extends MinesweeperGameAggregateArgs> = {
        [P in keyof T & keyof AggregateMinesweeperGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinesweeperGame[P]>
      : GetScalarType<T[P], AggregateMinesweeperGame[P]>
  }




  export type MinesweeperGameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinesweeperGameWhereInput
    orderBy?: MinesweeperGameOrderByWithAggregationInput | MinesweeperGameOrderByWithAggregationInput[]
    by: MinesweeperGameScalarFieldEnum[] | MinesweeperGameScalarFieldEnum
    having?: MinesweeperGameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinesweeperGameCountAggregateInputType | true
    _avg?: MinesweeperGameAvgAggregateInputType
    _sum?: MinesweeperGameSumAggregateInputType
    _min?: MinesweeperGameMinAggregateInputType
    _max?: MinesweeperGameMaxAggregateInputType
  }

  export type MinesweeperGameGroupByOutputType = {
    id: number
    userId: number
    tokenId: number
    difficultyId: number
    gameState: JsonValue
    minesPositions: JsonValue
    status: string
    revealedCells: number
    flaggedCells: number
    betAmount: Decimal
    winAmount: Decimal | null
    multiplier: number
    createdAt: Date
    updatedAt: Date
    _count: MinesweeperGameCountAggregateOutputType | null
    _avg: MinesweeperGameAvgAggregateOutputType | null
    _sum: MinesweeperGameSumAggregateOutputType | null
    _min: MinesweeperGameMinAggregateOutputType | null
    _max: MinesweeperGameMaxAggregateOutputType | null
  }

  type GetMinesweeperGameGroupByPayload<T extends MinesweeperGameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinesweeperGameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinesweeperGameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinesweeperGameGroupByOutputType[P]>
            : GetScalarType<T[P], MinesweeperGameGroupByOutputType[P]>
        }
      >
    >


  export type MinesweeperGameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    difficultyId?: boolean
    gameState?: boolean
    minesPositions?: boolean
    status?: boolean
    revealedCells?: boolean
    flaggedCells?: boolean
    betAmount?: boolean
    winAmount?: boolean
    multiplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
    difficulty?: boolean | MinesweeperDifficultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minesweeperGame"]>

  export type MinesweeperGameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    difficultyId?: boolean
    gameState?: boolean
    minesPositions?: boolean
    status?: boolean
    revealedCells?: boolean
    flaggedCells?: boolean
    betAmount?: boolean
    winAmount?: boolean
    multiplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
    difficulty?: boolean | MinesweeperDifficultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minesweeperGame"]>

  export type MinesweeperGameSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    difficultyId?: boolean
    gameState?: boolean
    minesPositions?: boolean
    status?: boolean
    revealedCells?: boolean
    flaggedCells?: boolean
    betAmount?: boolean
    winAmount?: boolean
    multiplier?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MinesweeperGameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
    difficulty?: boolean | MinesweeperDifficultyDefaultArgs<ExtArgs>
  }
  export type MinesweeperGameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
    difficulty?: boolean | MinesweeperDifficultyDefaultArgs<ExtArgs>
  }

  export type $MinesweeperGamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MinesweeperGame"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
      difficulty: Prisma.$MinesweeperDifficultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number
      difficultyId: number
      gameState: Prisma.JsonValue
      minesPositions: Prisma.JsonValue
      status: string
      revealedCells: number
      flaggedCells: number
      betAmount: Prisma.Decimal
      winAmount: Prisma.Decimal | null
      multiplier: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["minesweeperGame"]>
    composites: {}
  }

  type MinesweeperGameGetPayload<S extends boolean | null | undefined | MinesweeperGameDefaultArgs> = $Result.GetResult<Prisma.$MinesweeperGamePayload, S>

  type MinesweeperGameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MinesweeperGameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MinesweeperGameCountAggregateInputType | true
    }

  export interface MinesweeperGameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MinesweeperGame'], meta: { name: 'MinesweeperGame' } }
    /**
     * Find zero or one MinesweeperGame that matches the filter.
     * @param {MinesweeperGameFindUniqueArgs} args - Arguments to find a MinesweeperGame
     * @example
     * // Get one MinesweeperGame
     * const minesweeperGame = await prisma.minesweeperGame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MinesweeperGameFindUniqueArgs>(args: SelectSubset<T, MinesweeperGameFindUniqueArgs<ExtArgs>>): Prisma__MinesweeperGameClient<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MinesweeperGame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MinesweeperGameFindUniqueOrThrowArgs} args - Arguments to find a MinesweeperGame
     * @example
     * // Get one MinesweeperGame
     * const minesweeperGame = await prisma.minesweeperGame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MinesweeperGameFindUniqueOrThrowArgs>(args: SelectSubset<T, MinesweeperGameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MinesweeperGameClient<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MinesweeperGame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperGameFindFirstArgs} args - Arguments to find a MinesweeperGame
     * @example
     * // Get one MinesweeperGame
     * const minesweeperGame = await prisma.minesweeperGame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MinesweeperGameFindFirstArgs>(args?: SelectSubset<T, MinesweeperGameFindFirstArgs<ExtArgs>>): Prisma__MinesweeperGameClient<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MinesweeperGame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperGameFindFirstOrThrowArgs} args - Arguments to find a MinesweeperGame
     * @example
     * // Get one MinesweeperGame
     * const minesweeperGame = await prisma.minesweeperGame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MinesweeperGameFindFirstOrThrowArgs>(args?: SelectSubset<T, MinesweeperGameFindFirstOrThrowArgs<ExtArgs>>): Prisma__MinesweeperGameClient<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MinesweeperGames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperGameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MinesweeperGames
     * const minesweeperGames = await prisma.minesweeperGame.findMany()
     * 
     * // Get first 10 MinesweeperGames
     * const minesweeperGames = await prisma.minesweeperGame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const minesweeperGameWithIdOnly = await prisma.minesweeperGame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MinesweeperGameFindManyArgs>(args?: SelectSubset<T, MinesweeperGameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MinesweeperGame.
     * @param {MinesweeperGameCreateArgs} args - Arguments to create a MinesweeperGame.
     * @example
     * // Create one MinesweeperGame
     * const MinesweeperGame = await prisma.minesweeperGame.create({
     *   data: {
     *     // ... data to create a MinesweeperGame
     *   }
     * })
     * 
     */
    create<T extends MinesweeperGameCreateArgs>(args: SelectSubset<T, MinesweeperGameCreateArgs<ExtArgs>>): Prisma__MinesweeperGameClient<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MinesweeperGames.
     * @param {MinesweeperGameCreateManyArgs} args - Arguments to create many MinesweeperGames.
     * @example
     * // Create many MinesweeperGames
     * const minesweeperGame = await prisma.minesweeperGame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MinesweeperGameCreateManyArgs>(args?: SelectSubset<T, MinesweeperGameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MinesweeperGames and returns the data saved in the database.
     * @param {MinesweeperGameCreateManyAndReturnArgs} args - Arguments to create many MinesweeperGames.
     * @example
     * // Create many MinesweeperGames
     * const minesweeperGame = await prisma.minesweeperGame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MinesweeperGames and only return the `id`
     * const minesweeperGameWithIdOnly = await prisma.minesweeperGame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MinesweeperGameCreateManyAndReturnArgs>(args?: SelectSubset<T, MinesweeperGameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MinesweeperGame.
     * @param {MinesweeperGameDeleteArgs} args - Arguments to delete one MinesweeperGame.
     * @example
     * // Delete one MinesweeperGame
     * const MinesweeperGame = await prisma.minesweeperGame.delete({
     *   where: {
     *     // ... filter to delete one MinesweeperGame
     *   }
     * })
     * 
     */
    delete<T extends MinesweeperGameDeleteArgs>(args: SelectSubset<T, MinesweeperGameDeleteArgs<ExtArgs>>): Prisma__MinesweeperGameClient<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MinesweeperGame.
     * @param {MinesweeperGameUpdateArgs} args - Arguments to update one MinesweeperGame.
     * @example
     * // Update one MinesweeperGame
     * const minesweeperGame = await prisma.minesweeperGame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MinesweeperGameUpdateArgs>(args: SelectSubset<T, MinesweeperGameUpdateArgs<ExtArgs>>): Prisma__MinesweeperGameClient<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MinesweeperGames.
     * @param {MinesweeperGameDeleteManyArgs} args - Arguments to filter MinesweeperGames to delete.
     * @example
     * // Delete a few MinesweeperGames
     * const { count } = await prisma.minesweeperGame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MinesweeperGameDeleteManyArgs>(args?: SelectSubset<T, MinesweeperGameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MinesweeperGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperGameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MinesweeperGames
     * const minesweeperGame = await prisma.minesweeperGame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MinesweeperGameUpdateManyArgs>(args: SelectSubset<T, MinesweeperGameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MinesweeperGame.
     * @param {MinesweeperGameUpsertArgs} args - Arguments to update or create a MinesweeperGame.
     * @example
     * // Update or create a MinesweeperGame
     * const minesweeperGame = await prisma.minesweeperGame.upsert({
     *   create: {
     *     // ... data to create a MinesweeperGame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MinesweeperGame we want to update
     *   }
     * })
     */
    upsert<T extends MinesweeperGameUpsertArgs>(args: SelectSubset<T, MinesweeperGameUpsertArgs<ExtArgs>>): Prisma__MinesweeperGameClient<$Result.GetResult<Prisma.$MinesweeperGamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MinesweeperGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperGameCountArgs} args - Arguments to filter MinesweeperGames to count.
     * @example
     * // Count the number of MinesweeperGames
     * const count = await prisma.minesweeperGame.count({
     *   where: {
     *     // ... the filter for the MinesweeperGames we want to count
     *   }
     * })
    **/
    count<T extends MinesweeperGameCountArgs>(
      args?: Subset<T, MinesweeperGameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinesweeperGameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MinesweeperGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperGameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinesweeperGameAggregateArgs>(args: Subset<T, MinesweeperGameAggregateArgs>): Prisma.PrismaPromise<GetMinesweeperGameAggregateType<T>>

    /**
     * Group by MinesweeperGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperGameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MinesweeperGameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinesweeperGameGroupByArgs['orderBy'] }
        : { orderBy?: MinesweeperGameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MinesweeperGameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinesweeperGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MinesweeperGame model
   */
  readonly fields: MinesweeperGameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MinesweeperGame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinesweeperGameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    difficulty<T extends MinesweeperDifficultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MinesweeperDifficultyDefaultArgs<ExtArgs>>): Prisma__MinesweeperDifficultyClient<$Result.GetResult<Prisma.$MinesweeperDifficultyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MinesweeperGame model
   */ 
  interface MinesweeperGameFieldRefs {
    readonly id: FieldRef<"MinesweeperGame", 'Int'>
    readonly userId: FieldRef<"MinesweeperGame", 'Int'>
    readonly tokenId: FieldRef<"MinesweeperGame", 'Int'>
    readonly difficultyId: FieldRef<"MinesweeperGame", 'Int'>
    readonly gameState: FieldRef<"MinesweeperGame", 'Json'>
    readonly minesPositions: FieldRef<"MinesweeperGame", 'Json'>
    readonly status: FieldRef<"MinesweeperGame", 'String'>
    readonly revealedCells: FieldRef<"MinesweeperGame", 'Int'>
    readonly flaggedCells: FieldRef<"MinesweeperGame", 'Int'>
    readonly betAmount: FieldRef<"MinesweeperGame", 'Decimal'>
    readonly winAmount: FieldRef<"MinesweeperGame", 'Decimal'>
    readonly multiplier: FieldRef<"MinesweeperGame", 'Float'>
    readonly createdAt: FieldRef<"MinesweeperGame", 'DateTime'>
    readonly updatedAt: FieldRef<"MinesweeperGame", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MinesweeperGame findUnique
   */
  export type MinesweeperGameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperGame to fetch.
     */
    where: MinesweeperGameWhereUniqueInput
  }

  /**
   * MinesweeperGame findUniqueOrThrow
   */
  export type MinesweeperGameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperGame to fetch.
     */
    where: MinesweeperGameWhereUniqueInput
  }

  /**
   * MinesweeperGame findFirst
   */
  export type MinesweeperGameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperGame to fetch.
     */
    where?: MinesweeperGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperGames to fetch.
     */
    orderBy?: MinesweeperGameOrderByWithRelationInput | MinesweeperGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinesweeperGames.
     */
    cursor?: MinesweeperGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinesweeperGames.
     */
    distinct?: MinesweeperGameScalarFieldEnum | MinesweeperGameScalarFieldEnum[]
  }

  /**
   * MinesweeperGame findFirstOrThrow
   */
  export type MinesweeperGameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperGame to fetch.
     */
    where?: MinesweeperGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperGames to fetch.
     */
    orderBy?: MinesweeperGameOrderByWithRelationInput | MinesweeperGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinesweeperGames.
     */
    cursor?: MinesweeperGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinesweeperGames.
     */
    distinct?: MinesweeperGameScalarFieldEnum | MinesweeperGameScalarFieldEnum[]
  }

  /**
   * MinesweeperGame findMany
   */
  export type MinesweeperGameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperGames to fetch.
     */
    where?: MinesweeperGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperGames to fetch.
     */
    orderBy?: MinesweeperGameOrderByWithRelationInput | MinesweeperGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MinesweeperGames.
     */
    cursor?: MinesweeperGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperGames.
     */
    skip?: number
    distinct?: MinesweeperGameScalarFieldEnum | MinesweeperGameScalarFieldEnum[]
  }

  /**
   * MinesweeperGame create
   */
  export type MinesweeperGameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * The data needed to create a MinesweeperGame.
     */
    data: XOR<MinesweeperGameCreateInput, MinesweeperGameUncheckedCreateInput>
  }

  /**
   * MinesweeperGame createMany
   */
  export type MinesweeperGameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MinesweeperGames.
     */
    data: MinesweeperGameCreateManyInput | MinesweeperGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MinesweeperGame createManyAndReturn
   */
  export type MinesweeperGameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MinesweeperGames.
     */
    data: MinesweeperGameCreateManyInput | MinesweeperGameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MinesweeperGame update
   */
  export type MinesweeperGameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * The data needed to update a MinesweeperGame.
     */
    data: XOR<MinesweeperGameUpdateInput, MinesweeperGameUncheckedUpdateInput>
    /**
     * Choose, which MinesweeperGame to update.
     */
    where: MinesweeperGameWhereUniqueInput
  }

  /**
   * MinesweeperGame updateMany
   */
  export type MinesweeperGameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MinesweeperGames.
     */
    data: XOR<MinesweeperGameUpdateManyMutationInput, MinesweeperGameUncheckedUpdateManyInput>
    /**
     * Filter which MinesweeperGames to update
     */
    where?: MinesweeperGameWhereInput
  }

  /**
   * MinesweeperGame upsert
   */
  export type MinesweeperGameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * The filter to search for the MinesweeperGame to update in case it exists.
     */
    where: MinesweeperGameWhereUniqueInput
    /**
     * In case the MinesweeperGame found by the `where` argument doesn't exist, create a new MinesweeperGame with this data.
     */
    create: XOR<MinesweeperGameCreateInput, MinesweeperGameUncheckedCreateInput>
    /**
     * In case the MinesweeperGame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MinesweeperGameUpdateInput, MinesweeperGameUncheckedUpdateInput>
  }

  /**
   * MinesweeperGame delete
   */
  export type MinesweeperGameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
    /**
     * Filter which MinesweeperGame to delete.
     */
    where: MinesweeperGameWhereUniqueInput
  }

  /**
   * MinesweeperGame deleteMany
   */
  export type MinesweeperGameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinesweeperGames to delete
     */
    where?: MinesweeperGameWhereInput
  }

  /**
   * MinesweeperGame without action
   */
  export type MinesweeperGameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperGame
     */
    select?: MinesweeperGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperGameInclude<ExtArgs> | null
  }


  /**
   * Model MinesweeperBet
   */

  export type AggregateMinesweeperBet = {
    _count: MinesweeperBetCountAggregateOutputType | null
    _avg: MinesweeperBetAvgAggregateOutputType | null
    _sum: MinesweeperBetSumAggregateOutputType | null
    _min: MinesweeperBetMinAggregateOutputType | null
    _max: MinesweeperBetMaxAggregateOutputType | null
  }

  export type MinesweeperBetAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    gameId: number | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    multiplier: number | null
  }

  export type MinesweeperBetSumAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    gameId: number | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    multiplier: number | null
  }

  export type MinesweeperBetMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    gameId: number | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    result: string | null
    multiplier: number | null
    createdAt: Date | null
  }

  export type MinesweeperBetMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenId: number | null
    gameId: number | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    result: string | null
    multiplier: number | null
    createdAt: Date | null
  }

  export type MinesweeperBetCountAggregateOutputType = {
    id: number
    userId: number
    tokenId: number
    gameId: number
    betAmount: number
    winAmount: number
    result: number
    multiplier: number
    createdAt: number
    _all: number
  }


  export type MinesweeperBetAvgAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameId?: true
    betAmount?: true
    winAmount?: true
    multiplier?: true
  }

  export type MinesweeperBetSumAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameId?: true
    betAmount?: true
    winAmount?: true
    multiplier?: true
  }

  export type MinesweeperBetMinAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameId?: true
    betAmount?: true
    winAmount?: true
    result?: true
    multiplier?: true
    createdAt?: true
  }

  export type MinesweeperBetMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameId?: true
    betAmount?: true
    winAmount?: true
    result?: true
    multiplier?: true
    createdAt?: true
  }

  export type MinesweeperBetCountAggregateInputType = {
    id?: true
    userId?: true
    tokenId?: true
    gameId?: true
    betAmount?: true
    winAmount?: true
    result?: true
    multiplier?: true
    createdAt?: true
    _all?: true
  }

  export type MinesweeperBetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinesweeperBet to aggregate.
     */
    where?: MinesweeperBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperBets to fetch.
     */
    orderBy?: MinesweeperBetOrderByWithRelationInput | MinesweeperBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MinesweeperBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MinesweeperBets
    **/
    _count?: true | MinesweeperBetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MinesweeperBetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MinesweeperBetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinesweeperBetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinesweeperBetMaxAggregateInputType
  }

  export type GetMinesweeperBetAggregateType<T extends MinesweeperBetAggregateArgs> = {
        [P in keyof T & keyof AggregateMinesweeperBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinesweeperBet[P]>
      : GetScalarType<T[P], AggregateMinesweeperBet[P]>
  }




  export type MinesweeperBetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinesweeperBetWhereInput
    orderBy?: MinesweeperBetOrderByWithAggregationInput | MinesweeperBetOrderByWithAggregationInput[]
    by: MinesweeperBetScalarFieldEnum[] | MinesweeperBetScalarFieldEnum
    having?: MinesweeperBetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinesweeperBetCountAggregateInputType | true
    _avg?: MinesweeperBetAvgAggregateInputType
    _sum?: MinesweeperBetSumAggregateInputType
    _min?: MinesweeperBetMinAggregateInputType
    _max?: MinesweeperBetMaxAggregateInputType
  }

  export type MinesweeperBetGroupByOutputType = {
    id: number
    userId: number
    tokenId: number
    gameId: number
    betAmount: Decimal
    winAmount: Decimal | null
    result: string
    multiplier: number
    createdAt: Date
    _count: MinesweeperBetCountAggregateOutputType | null
    _avg: MinesweeperBetAvgAggregateOutputType | null
    _sum: MinesweeperBetSumAggregateOutputType | null
    _min: MinesweeperBetMinAggregateOutputType | null
    _max: MinesweeperBetMaxAggregateOutputType | null
  }

  type GetMinesweeperBetGroupByPayload<T extends MinesweeperBetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinesweeperBetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinesweeperBetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinesweeperBetGroupByOutputType[P]>
            : GetScalarType<T[P], MinesweeperBetGroupByOutputType[P]>
        }
      >
    >


  export type MinesweeperBetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameId?: boolean
    betAmount?: boolean
    winAmount?: boolean
    result?: boolean
    multiplier?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minesweeperBet"]>

  export type MinesweeperBetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameId?: boolean
    betAmount?: boolean
    winAmount?: boolean
    result?: boolean
    multiplier?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minesweeperBet"]>

  export type MinesweeperBetSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenId?: boolean
    gameId?: boolean
    betAmount?: boolean
    winAmount?: boolean
    result?: boolean
    multiplier?: boolean
    createdAt?: boolean
  }

  export type MinesweeperBetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }
  export type MinesweeperBetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    token?: boolean | CryptoTokenDefaultArgs<ExtArgs>
  }

  export type $MinesweeperBetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MinesweeperBet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      token: Prisma.$CryptoTokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenId: number
      gameId: number
      betAmount: Prisma.Decimal
      winAmount: Prisma.Decimal | null
      result: string
      multiplier: number
      createdAt: Date
    }, ExtArgs["result"]["minesweeperBet"]>
    composites: {}
  }

  type MinesweeperBetGetPayload<S extends boolean | null | undefined | MinesweeperBetDefaultArgs> = $Result.GetResult<Prisma.$MinesweeperBetPayload, S>

  type MinesweeperBetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MinesweeperBetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MinesweeperBetCountAggregateInputType | true
    }

  export interface MinesweeperBetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MinesweeperBet'], meta: { name: 'MinesweeperBet' } }
    /**
     * Find zero or one MinesweeperBet that matches the filter.
     * @param {MinesweeperBetFindUniqueArgs} args - Arguments to find a MinesweeperBet
     * @example
     * // Get one MinesweeperBet
     * const minesweeperBet = await prisma.minesweeperBet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MinesweeperBetFindUniqueArgs>(args: SelectSubset<T, MinesweeperBetFindUniqueArgs<ExtArgs>>): Prisma__MinesweeperBetClient<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MinesweeperBet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MinesweeperBetFindUniqueOrThrowArgs} args - Arguments to find a MinesweeperBet
     * @example
     * // Get one MinesweeperBet
     * const minesweeperBet = await prisma.minesweeperBet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MinesweeperBetFindUniqueOrThrowArgs>(args: SelectSubset<T, MinesweeperBetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MinesweeperBetClient<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MinesweeperBet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperBetFindFirstArgs} args - Arguments to find a MinesweeperBet
     * @example
     * // Get one MinesweeperBet
     * const minesweeperBet = await prisma.minesweeperBet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MinesweeperBetFindFirstArgs>(args?: SelectSubset<T, MinesweeperBetFindFirstArgs<ExtArgs>>): Prisma__MinesweeperBetClient<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MinesweeperBet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperBetFindFirstOrThrowArgs} args - Arguments to find a MinesweeperBet
     * @example
     * // Get one MinesweeperBet
     * const minesweeperBet = await prisma.minesweeperBet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MinesweeperBetFindFirstOrThrowArgs>(args?: SelectSubset<T, MinesweeperBetFindFirstOrThrowArgs<ExtArgs>>): Prisma__MinesweeperBetClient<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MinesweeperBets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperBetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MinesweeperBets
     * const minesweeperBets = await prisma.minesweeperBet.findMany()
     * 
     * // Get first 10 MinesweeperBets
     * const minesweeperBets = await prisma.minesweeperBet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const minesweeperBetWithIdOnly = await prisma.minesweeperBet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MinesweeperBetFindManyArgs>(args?: SelectSubset<T, MinesweeperBetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MinesweeperBet.
     * @param {MinesweeperBetCreateArgs} args - Arguments to create a MinesweeperBet.
     * @example
     * // Create one MinesweeperBet
     * const MinesweeperBet = await prisma.minesweeperBet.create({
     *   data: {
     *     // ... data to create a MinesweeperBet
     *   }
     * })
     * 
     */
    create<T extends MinesweeperBetCreateArgs>(args: SelectSubset<T, MinesweeperBetCreateArgs<ExtArgs>>): Prisma__MinesweeperBetClient<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MinesweeperBets.
     * @param {MinesweeperBetCreateManyArgs} args - Arguments to create many MinesweeperBets.
     * @example
     * // Create many MinesweeperBets
     * const minesweeperBet = await prisma.minesweeperBet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MinesweeperBetCreateManyArgs>(args?: SelectSubset<T, MinesweeperBetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MinesweeperBets and returns the data saved in the database.
     * @param {MinesweeperBetCreateManyAndReturnArgs} args - Arguments to create many MinesweeperBets.
     * @example
     * // Create many MinesweeperBets
     * const minesweeperBet = await prisma.minesweeperBet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MinesweeperBets and only return the `id`
     * const minesweeperBetWithIdOnly = await prisma.minesweeperBet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MinesweeperBetCreateManyAndReturnArgs>(args?: SelectSubset<T, MinesweeperBetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MinesweeperBet.
     * @param {MinesweeperBetDeleteArgs} args - Arguments to delete one MinesweeperBet.
     * @example
     * // Delete one MinesweeperBet
     * const MinesweeperBet = await prisma.minesweeperBet.delete({
     *   where: {
     *     // ... filter to delete one MinesweeperBet
     *   }
     * })
     * 
     */
    delete<T extends MinesweeperBetDeleteArgs>(args: SelectSubset<T, MinesweeperBetDeleteArgs<ExtArgs>>): Prisma__MinesweeperBetClient<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MinesweeperBet.
     * @param {MinesweeperBetUpdateArgs} args - Arguments to update one MinesweeperBet.
     * @example
     * // Update one MinesweeperBet
     * const minesweeperBet = await prisma.minesweeperBet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MinesweeperBetUpdateArgs>(args: SelectSubset<T, MinesweeperBetUpdateArgs<ExtArgs>>): Prisma__MinesweeperBetClient<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MinesweeperBets.
     * @param {MinesweeperBetDeleteManyArgs} args - Arguments to filter MinesweeperBets to delete.
     * @example
     * // Delete a few MinesweeperBets
     * const { count } = await prisma.minesweeperBet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MinesweeperBetDeleteManyArgs>(args?: SelectSubset<T, MinesweeperBetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MinesweeperBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperBetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MinesweeperBets
     * const minesweeperBet = await prisma.minesweeperBet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MinesweeperBetUpdateManyArgs>(args: SelectSubset<T, MinesweeperBetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MinesweeperBet.
     * @param {MinesweeperBetUpsertArgs} args - Arguments to update or create a MinesweeperBet.
     * @example
     * // Update or create a MinesweeperBet
     * const minesweeperBet = await prisma.minesweeperBet.upsert({
     *   create: {
     *     // ... data to create a MinesweeperBet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MinesweeperBet we want to update
     *   }
     * })
     */
    upsert<T extends MinesweeperBetUpsertArgs>(args: SelectSubset<T, MinesweeperBetUpsertArgs<ExtArgs>>): Prisma__MinesweeperBetClient<$Result.GetResult<Prisma.$MinesweeperBetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MinesweeperBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperBetCountArgs} args - Arguments to filter MinesweeperBets to count.
     * @example
     * // Count the number of MinesweeperBets
     * const count = await prisma.minesweeperBet.count({
     *   where: {
     *     // ... the filter for the MinesweeperBets we want to count
     *   }
     * })
    **/
    count<T extends MinesweeperBetCountArgs>(
      args?: Subset<T, MinesweeperBetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinesweeperBetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MinesweeperBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperBetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinesweeperBetAggregateArgs>(args: Subset<T, MinesweeperBetAggregateArgs>): Prisma.PrismaPromise<GetMinesweeperBetAggregateType<T>>

    /**
     * Group by MinesweeperBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinesweeperBetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MinesweeperBetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinesweeperBetGroupByArgs['orderBy'] }
        : { orderBy?: MinesweeperBetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MinesweeperBetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinesweeperBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MinesweeperBet model
   */
  readonly fields: MinesweeperBetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MinesweeperBet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinesweeperBetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    token<T extends CryptoTokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoTokenDefaultArgs<ExtArgs>>): Prisma__CryptoTokenClient<$Result.GetResult<Prisma.$CryptoTokenPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MinesweeperBet model
   */ 
  interface MinesweeperBetFieldRefs {
    readonly id: FieldRef<"MinesweeperBet", 'Int'>
    readonly userId: FieldRef<"MinesweeperBet", 'Int'>
    readonly tokenId: FieldRef<"MinesweeperBet", 'Int'>
    readonly gameId: FieldRef<"MinesweeperBet", 'Int'>
    readonly betAmount: FieldRef<"MinesweeperBet", 'Decimal'>
    readonly winAmount: FieldRef<"MinesweeperBet", 'Decimal'>
    readonly result: FieldRef<"MinesweeperBet", 'String'>
    readonly multiplier: FieldRef<"MinesweeperBet", 'Float'>
    readonly createdAt: FieldRef<"MinesweeperBet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MinesweeperBet findUnique
   */
  export type MinesweeperBetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperBet to fetch.
     */
    where: MinesweeperBetWhereUniqueInput
  }

  /**
   * MinesweeperBet findUniqueOrThrow
   */
  export type MinesweeperBetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperBet to fetch.
     */
    where: MinesweeperBetWhereUniqueInput
  }

  /**
   * MinesweeperBet findFirst
   */
  export type MinesweeperBetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperBet to fetch.
     */
    where?: MinesweeperBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperBets to fetch.
     */
    orderBy?: MinesweeperBetOrderByWithRelationInput | MinesweeperBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinesweeperBets.
     */
    cursor?: MinesweeperBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinesweeperBets.
     */
    distinct?: MinesweeperBetScalarFieldEnum | MinesweeperBetScalarFieldEnum[]
  }

  /**
   * MinesweeperBet findFirstOrThrow
   */
  export type MinesweeperBetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperBet to fetch.
     */
    where?: MinesweeperBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperBets to fetch.
     */
    orderBy?: MinesweeperBetOrderByWithRelationInput | MinesweeperBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinesweeperBets.
     */
    cursor?: MinesweeperBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinesweeperBets.
     */
    distinct?: MinesweeperBetScalarFieldEnum | MinesweeperBetScalarFieldEnum[]
  }

  /**
   * MinesweeperBet findMany
   */
  export type MinesweeperBetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * Filter, which MinesweeperBets to fetch.
     */
    where?: MinesweeperBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinesweeperBets to fetch.
     */
    orderBy?: MinesweeperBetOrderByWithRelationInput | MinesweeperBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MinesweeperBets.
     */
    cursor?: MinesweeperBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinesweeperBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinesweeperBets.
     */
    skip?: number
    distinct?: MinesweeperBetScalarFieldEnum | MinesweeperBetScalarFieldEnum[]
  }

  /**
   * MinesweeperBet create
   */
  export type MinesweeperBetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * The data needed to create a MinesweeperBet.
     */
    data: XOR<MinesweeperBetCreateInput, MinesweeperBetUncheckedCreateInput>
  }

  /**
   * MinesweeperBet createMany
   */
  export type MinesweeperBetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MinesweeperBets.
     */
    data: MinesweeperBetCreateManyInput | MinesweeperBetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MinesweeperBet createManyAndReturn
   */
  export type MinesweeperBetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MinesweeperBets.
     */
    data: MinesweeperBetCreateManyInput | MinesweeperBetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MinesweeperBet update
   */
  export type MinesweeperBetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * The data needed to update a MinesweeperBet.
     */
    data: XOR<MinesweeperBetUpdateInput, MinesweeperBetUncheckedUpdateInput>
    /**
     * Choose, which MinesweeperBet to update.
     */
    where: MinesweeperBetWhereUniqueInput
  }

  /**
   * MinesweeperBet updateMany
   */
  export type MinesweeperBetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MinesweeperBets.
     */
    data: XOR<MinesweeperBetUpdateManyMutationInput, MinesweeperBetUncheckedUpdateManyInput>
    /**
     * Filter which MinesweeperBets to update
     */
    where?: MinesweeperBetWhereInput
  }

  /**
   * MinesweeperBet upsert
   */
  export type MinesweeperBetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * The filter to search for the MinesweeperBet to update in case it exists.
     */
    where: MinesweeperBetWhereUniqueInput
    /**
     * In case the MinesweeperBet found by the `where` argument doesn't exist, create a new MinesweeperBet with this data.
     */
    create: XOR<MinesweeperBetCreateInput, MinesweeperBetUncheckedCreateInput>
    /**
     * In case the MinesweeperBet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MinesweeperBetUpdateInput, MinesweeperBetUncheckedUpdateInput>
  }

  /**
   * MinesweeperBet delete
   */
  export type MinesweeperBetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
    /**
     * Filter which MinesweeperBet to delete.
     */
    where: MinesweeperBetWhereUniqueInput
  }

  /**
   * MinesweeperBet deleteMany
   */
  export type MinesweeperBetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinesweeperBets to delete
     */
    where?: MinesweeperBetWhereInput
  }

  /**
   * MinesweeperBet without action
   */
  export type MinesweeperBetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinesweeperBet
     */
    select?: MinesweeperBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinesweeperBetInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CryptoTokenScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    name: 'name',
    network: 'network',
    decimals: 'decimals',
    createdAt: 'createdAt'
  };

  export type CryptoTokenScalarFieldEnum = (typeof CryptoTokenScalarFieldEnum)[keyof typeof CryptoTokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    telegramId: 'telegramId',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    photoUrl: 'photoUrl',
    passwordHash: 'passwordHash',
    salt: 'salt',
    isAdmin: 'isAdmin',
    isBlocked: 'isBlocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referralCode: 'referralCode',
    referredById: 'referredById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BalanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    type: 'type',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BalanceScalarFieldEnum = (typeof BalanceScalarFieldEnum)[keyof typeof BalanceScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    type: 'type',
    status: 'status',
    amount: 'amount',
    txHash: 'txHash',
    walletAddress: 'walletAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const BetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    gameType: 'gameType',
    betAmount: 'betAmount',
    payoutAmount: 'payoutAmount',
    netAmount: 'netAmount',
    payoutRatio: 'payoutRatio',
    roundId: 'roundId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type BetScalarFieldEnum = (typeof BetScalarFieldEnum)[keyof typeof BetScalarFieldEnum]


  export const BonusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    wageringMultiplier: 'wageringMultiplier',
    maxBonusAmount: 'maxBonusAmount'
  };

  export type BonusScalarFieldEnum = (typeof BonusScalarFieldEnum)[keyof typeof BonusScalarFieldEnum]


  export const UserBonusScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bonusId: 'bonusId',
    tokenId: 'tokenId',
    grantedAmount: 'grantedAmount',
    requiredWager: 'requiredWager',
    wageredAmount: 'wageredAmount',
    isActive: 'isActive',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type UserBonusScalarFieldEnum = (typeof UserBonusScalarFieldEnum)[keyof typeof UserBonusScalarFieldEnum]


  export const LeaderboardEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    metric: 'metric',
    score: 'score',
    period: 'period',
    updatedAt: 'updatedAt'
  };

  export type LeaderboardEntryScalarFieldEnum = (typeof LeaderboardEntryScalarFieldEnum)[keyof typeof LeaderboardEntryScalarFieldEnum]


  export const ReferralTransactionScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    tokenId: 'tokenId',
    eventType: 'eventType',
    amount: 'amount',
    sourceEntityId: 'sourceEntityId',
    sourceEntityType: 'sourceEntityType',
    createdAt: 'createdAt'
  };

  export type ReferralTransactionScalarFieldEnum = (typeof ReferralTransactionScalarFieldEnum)[keyof typeof ReferralTransactionScalarFieldEnum]


  export const OneTimeTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    used: 'used'
  };

  export type OneTimeTokenScalarFieldEnum = (typeof OneTimeTokenScalarFieldEnum)[keyof typeof OneTimeTokenScalarFieldEnum]


  export const CrashRoundScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    crashPoint: 'crashPoint',
    totalPlayers: 'totalPlayers',
    winnersCount: 'winnersCount',
    totalWagered: 'totalWagered',
    totalPayouts: 'totalPayouts',
    serverSeedHash: 'serverSeedHash',
    clientSeed: 'clientSeed',
    nonce: 'nonce',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrashRoundScalarFieldEnum = (typeof CrashRoundScalarFieldEnum)[keyof typeof CrashRoundScalarFieldEnum]


  export const CrashBetScalarFieldEnum: {
    id: 'id',
    roundId: 'roundId',
    userId: 'userId',
    tokenId: 'tokenId',
    betAmount: 'betAmount',
    exitMultiplier: 'exitMultiplier',
    winnings: 'winnings',
    result: 'result',
    createdAt: 'createdAt'
  };

  export type CrashBetScalarFieldEnum = (typeof CrashBetScalarFieldEnum)[keyof typeof CrashBetScalarFieldEnum]


  export const CrashTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    betId: 'betId',
    tokenId: 'tokenId',
    amount: 'amount',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type CrashTransactionScalarFieldEnum = (typeof CrashTransactionScalarFieldEnum)[keyof typeof CrashTransactionScalarFieldEnum]


  export const MinesweeperDifficultyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    minesCount: 'minesCount',
    gridSize: 'gridSize',
    multiplier: 'multiplier',
    createdAt: 'createdAt'
  };

  export type MinesweeperDifficultyScalarFieldEnum = (typeof MinesweeperDifficultyScalarFieldEnum)[keyof typeof MinesweeperDifficultyScalarFieldEnum]


  export const MinesweeperGameScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    difficultyId: 'difficultyId',
    gameState: 'gameState',
    minesPositions: 'minesPositions',
    status: 'status',
    revealedCells: 'revealedCells',
    flaggedCells: 'flaggedCells',
    betAmount: 'betAmount',
    winAmount: 'winAmount',
    multiplier: 'multiplier',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MinesweeperGameScalarFieldEnum = (typeof MinesweeperGameScalarFieldEnum)[keyof typeof MinesweeperGameScalarFieldEnum]


  export const MinesweeperBetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenId: 'tokenId',
    gameId: 'gameId',
    betAmount: 'betAmount',
    winAmount: 'winAmount',
    result: 'result',
    multiplier: 'multiplier',
    createdAt: 'createdAt'
  };

  export type MinesweeperBetScalarFieldEnum = (typeof MinesweeperBetScalarFieldEnum)[keyof typeof MinesweeperBetScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BalanceType'
   */
  export type EnumBalanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BalanceType'>
    


  /**
   * Reference to a field of type 'BalanceType[]'
   */
  export type ListEnumBalanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BalanceType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'GameType'
   */
  export type EnumGameTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameType'>
    


  /**
   * Reference to a field of type 'GameType[]'
   */
  export type ListEnumGameTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ReferralEventType'
   */
  export type EnumReferralEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralEventType'>
    


  /**
   * Reference to a field of type 'ReferralEventType[]'
   */
  export type ListEnumReferralEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralEventType[]'>
    
  /**
   * Deep Input Types
   */


  export type CryptoTokenWhereInput = {
    AND?: CryptoTokenWhereInput | CryptoTokenWhereInput[]
    OR?: CryptoTokenWhereInput[]
    NOT?: CryptoTokenWhereInput | CryptoTokenWhereInput[]
    id?: IntFilter<"CryptoToken"> | number
    symbol?: StringFilter<"CryptoToken"> | string
    name?: StringFilter<"CryptoToken"> | string
    network?: StringFilter<"CryptoToken"> | string
    decimals?: IntFilter<"CryptoToken"> | number
    createdAt?: DateTimeFilter<"CryptoToken"> | Date | string
    crashBets?: CrashBetListRelationFilter
    crashTransactions?: CrashTransactionListRelationFilter
    minesweeperGames?: MinesweeperGameListRelationFilter
    minesweeperBets?: MinesweeperBetListRelationFilter
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
    bets?: BetListRelationFilter
    leaderboard?: LeaderboardEntryListRelationFilter
    userBonuses?: UserBonusListRelationFilter
    referralCommissions?: ReferralTransactionListRelationFilter
  }

  export type CryptoTokenOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
    crashBets?: CrashBetOrderByRelationAggregateInput
    crashTransactions?: CrashTransactionOrderByRelationAggregateInput
    minesweeperGames?: MinesweeperGameOrderByRelationAggregateInput
    minesweeperBets?: MinesweeperBetOrderByRelationAggregateInput
    balances?: BalanceOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    bets?: BetOrderByRelationAggregateInput
    leaderboard?: LeaderboardEntryOrderByRelationAggregateInput
    userBonuses?: UserBonusOrderByRelationAggregateInput
    referralCommissions?: ReferralTransactionOrderByRelationAggregateInput
  }

  export type CryptoTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    symbol?: string
    AND?: CryptoTokenWhereInput | CryptoTokenWhereInput[]
    OR?: CryptoTokenWhereInput[]
    NOT?: CryptoTokenWhereInput | CryptoTokenWhereInput[]
    name?: StringFilter<"CryptoToken"> | string
    network?: StringFilter<"CryptoToken"> | string
    decimals?: IntFilter<"CryptoToken"> | number
    createdAt?: DateTimeFilter<"CryptoToken"> | Date | string
    crashBets?: CrashBetListRelationFilter
    crashTransactions?: CrashTransactionListRelationFilter
    minesweeperGames?: MinesweeperGameListRelationFilter
    minesweeperBets?: MinesweeperBetListRelationFilter
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
    bets?: BetListRelationFilter
    leaderboard?: LeaderboardEntryListRelationFilter
    userBonuses?: UserBonusListRelationFilter
    referralCommissions?: ReferralTransactionListRelationFilter
  }, "id" | "symbol">

  export type CryptoTokenOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
    _count?: CryptoTokenCountOrderByAggregateInput
    _avg?: CryptoTokenAvgOrderByAggregateInput
    _max?: CryptoTokenMaxOrderByAggregateInput
    _min?: CryptoTokenMinOrderByAggregateInput
    _sum?: CryptoTokenSumOrderByAggregateInput
  }

  export type CryptoTokenScalarWhereWithAggregatesInput = {
    AND?: CryptoTokenScalarWhereWithAggregatesInput | CryptoTokenScalarWhereWithAggregatesInput[]
    OR?: CryptoTokenScalarWhereWithAggregatesInput[]
    NOT?: CryptoTokenScalarWhereWithAggregatesInput | CryptoTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CryptoToken"> | number
    symbol?: StringWithAggregatesFilter<"CryptoToken"> | string
    name?: StringWithAggregatesFilter<"CryptoToken"> | string
    network?: StringWithAggregatesFilter<"CryptoToken"> | string
    decimals?: IntWithAggregatesFilter<"CryptoToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CryptoToken"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    telegramId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referralCode?: StringFilter<"User"> | string
    referredById?: IntNullableFilter<"User"> | number | null
    referrer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    crashBets?: CrashBetListRelationFilter
    crashTransactions?: CrashTransactionListRelationFilter
    minesweeperGames?: MinesweeperGameListRelationFilter
    minesweeperBets?: MinesweeperBetListRelationFilter
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
    bets?: BetListRelationFilter
    leaderboardEntries?: LeaderboardEntryListRelationFilter
    bonuses?: UserBonusListRelationFilter
    commissions?: ReferralTransactionListRelationFilter
    referralActions?: ReferralTransactionListRelationFilter
    authTokens?: OneTimeTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    salt?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrderInput | SortOrder
    referrer?: UserOrderByWithRelationInput
    referrals?: UserOrderByRelationAggregateInput
    crashBets?: CrashBetOrderByRelationAggregateInput
    crashTransactions?: CrashTransactionOrderByRelationAggregateInput
    minesweeperGames?: MinesweeperGameOrderByRelationAggregateInput
    minesweeperBets?: MinesweeperBetOrderByRelationAggregateInput
    balances?: BalanceOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    bets?: BetOrderByRelationAggregateInput
    leaderboardEntries?: LeaderboardEntryOrderByRelationAggregateInput
    bonuses?: UserBonusOrderByRelationAggregateInput
    commissions?: ReferralTransactionOrderByRelationAggregateInput
    referralActions?: ReferralTransactionOrderByRelationAggregateInput
    authTokens?: OneTimeTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    telegramId?: string
    username?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: IntNullableFilter<"User"> | number | null
    referrer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    crashBets?: CrashBetListRelationFilter
    crashTransactions?: CrashTransactionListRelationFilter
    minesweeperGames?: MinesweeperGameListRelationFilter
    minesweeperBets?: MinesweeperBetListRelationFilter
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
    bets?: BetListRelationFilter
    leaderboardEntries?: LeaderboardEntryListRelationFilter
    bonuses?: UserBonusListRelationFilter
    commissions?: ReferralTransactionListRelationFilter
    referralActions?: ReferralTransactionListRelationFilter
    authTokens?: OneTimeTokenListRelationFilter
  }, "id" | "telegramId" | "username" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    salt?: SortOrderInput | SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    telegramId?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    salt?: StringNullableWithAggregatesFilter<"User"> | string | null
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    isBlocked?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    referralCode?: StringWithAggregatesFilter<"User"> | string
    referredById?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type BalanceWhereInput = {
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    id?: IntFilter<"Balance"> | number
    userId?: IntFilter<"Balance"> | number
    tokenId?: IntFilter<"Balance"> | number
    type?: EnumBalanceTypeFilter<"Balance"> | $Enums.BalanceType
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Balance"> | Date | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type BalanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type BalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_tokenId_type?: BalanceUserIdTokenIdTypeCompoundUniqueInput
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    userId?: IntFilter<"Balance"> | number
    tokenId?: IntFilter<"Balance"> | number
    type?: EnumBalanceTypeFilter<"Balance"> | $Enums.BalanceType
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Balance"> | Date | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id" | "userId_tokenId_type">

  export type BalanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BalanceCountOrderByAggregateInput
    _avg?: BalanceAvgOrderByAggregateInput
    _max?: BalanceMaxOrderByAggregateInput
    _min?: BalanceMinOrderByAggregateInput
    _sum?: BalanceSumOrderByAggregateInput
  }

  export type BalanceScalarWhereWithAggregatesInput = {
    AND?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    OR?: BalanceScalarWhereWithAggregatesInput[]
    NOT?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Balance"> | number
    userId?: IntWithAggregatesFilter<"Balance"> | number
    tokenId?: IntWithAggregatesFilter<"Balance"> | number
    type?: EnumBalanceTypeWithAggregatesFilter<"Balance"> | $Enums.BalanceType
    amount?: DecimalWithAggregatesFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Balance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Balance"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    userId?: IntFilter<"Transaction"> | number
    tokenId?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"Transaction"> | string | null
    walletAddress?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    txHash_userId?: TransactionTxHashUserIdCompoundUniqueInput
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: IntFilter<"Transaction"> | number
    tokenId?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"Transaction"> | string | null
    walletAddress?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id" | "txHash_userId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    userId?: IntWithAggregatesFilter<"Transaction"> | number
    tokenId?: IntWithAggregatesFilter<"Transaction"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    walletAddress?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type BetWhereInput = {
    AND?: BetWhereInput | BetWhereInput[]
    OR?: BetWhereInput[]
    NOT?: BetWhereInput | BetWhereInput[]
    id?: IntFilter<"Bet"> | number
    userId?: IntFilter<"Bet"> | number
    tokenId?: IntFilter<"Bet"> | number
    gameType?: EnumGameTypeFilter<"Bet"> | $Enums.GameType
    betAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFilter<"Bet"> | number
    roundId?: StringFilter<"Bet"> | string
    details?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type BetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type BetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BetWhereInput | BetWhereInput[]
    OR?: BetWhereInput[]
    NOT?: BetWhereInput | BetWhereInput[]
    userId?: IntFilter<"Bet"> | number
    tokenId?: IntFilter<"Bet"> | number
    gameType?: EnumGameTypeFilter<"Bet"> | $Enums.GameType
    betAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFilter<"Bet"> | number
    roundId?: StringFilter<"Bet"> | string
    details?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id">

  export type BetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BetCountOrderByAggregateInput
    _avg?: BetAvgOrderByAggregateInput
    _max?: BetMaxOrderByAggregateInput
    _min?: BetMinOrderByAggregateInput
    _sum?: BetSumOrderByAggregateInput
  }

  export type BetScalarWhereWithAggregatesInput = {
    AND?: BetScalarWhereWithAggregatesInput | BetScalarWhereWithAggregatesInput[]
    OR?: BetScalarWhereWithAggregatesInput[]
    NOT?: BetScalarWhereWithAggregatesInput | BetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bet"> | number
    userId?: IntWithAggregatesFilter<"Bet"> | number
    tokenId?: IntWithAggregatesFilter<"Bet"> | number
    gameType?: EnumGameTypeWithAggregatesFilter<"Bet"> | $Enums.GameType
    betAmount?: DecimalWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatWithAggregatesFilter<"Bet"> | number
    roundId?: StringWithAggregatesFilter<"Bet"> | string
    details?: JsonNullableWithAggregatesFilter<"Bet">
    createdAt?: DateTimeWithAggregatesFilter<"Bet"> | Date | string
  }

  export type BonusWhereInput = {
    AND?: BonusWhereInput | BonusWhereInput[]
    OR?: BonusWhereInput[]
    NOT?: BonusWhereInput | BonusWhereInput[]
    id?: IntFilter<"Bonus"> | number
    name?: StringFilter<"Bonus"> | string
    description?: StringFilter<"Bonus"> | string
    wageringMultiplier?: FloatFilter<"Bonus"> | number
    maxBonusAmount?: DecimalFilter<"Bonus"> | Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusListRelationFilter
  }

  export type BonusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
    userBonuses?: UserBonusOrderByRelationAggregateInput
  }

  export type BonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BonusWhereInput | BonusWhereInput[]
    OR?: BonusWhereInput[]
    NOT?: BonusWhereInput | BonusWhereInput[]
    description?: StringFilter<"Bonus"> | string
    wageringMultiplier?: FloatFilter<"Bonus"> | number
    maxBonusAmount?: DecimalFilter<"Bonus"> | Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusListRelationFilter
  }, "id" | "name">

  export type BonusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
    _count?: BonusCountOrderByAggregateInput
    _avg?: BonusAvgOrderByAggregateInput
    _max?: BonusMaxOrderByAggregateInput
    _min?: BonusMinOrderByAggregateInput
    _sum?: BonusSumOrderByAggregateInput
  }

  export type BonusScalarWhereWithAggregatesInput = {
    AND?: BonusScalarWhereWithAggregatesInput | BonusScalarWhereWithAggregatesInput[]
    OR?: BonusScalarWhereWithAggregatesInput[]
    NOT?: BonusScalarWhereWithAggregatesInput | BonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bonus"> | number
    name?: StringWithAggregatesFilter<"Bonus"> | string
    description?: StringWithAggregatesFilter<"Bonus"> | string
    wageringMultiplier?: FloatWithAggregatesFilter<"Bonus"> | number
    maxBonusAmount?: DecimalWithAggregatesFilter<"Bonus"> | Decimal | DecimalJsLike | number | string
  }

  export type UserBonusWhereInput = {
    AND?: UserBonusWhereInput | UserBonusWhereInput[]
    OR?: UserBonusWhereInput[]
    NOT?: UserBonusWhereInput | UserBonusWhereInput[]
    id?: IntFilter<"UserBonus"> | number
    userId?: IntFilter<"UserBonus"> | number
    bonusId?: IntFilter<"UserBonus"> | number
    tokenId?: IntFilter<"UserBonus"> | number
    grantedAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"UserBonus"> | boolean
    isCompleted?: BoolFilter<"UserBonus"> | boolean
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    bonus?: XOR<BonusRelationFilter, BonusWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type UserBonusOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    bonus?: BonusOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type UserBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_bonusId_tokenId?: UserBonusUserIdBonusIdTokenIdCompoundUniqueInput
    AND?: UserBonusWhereInput | UserBonusWhereInput[]
    OR?: UserBonusWhereInput[]
    NOT?: UserBonusWhereInput | UserBonusWhereInput[]
    userId?: IntFilter<"UserBonus"> | number
    bonusId?: IntFilter<"UserBonus"> | number
    tokenId?: IntFilter<"UserBonus"> | number
    grantedAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"UserBonus"> | boolean
    isCompleted?: BoolFilter<"UserBonus"> | boolean
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    bonus?: XOR<BonusRelationFilter, BonusWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id" | "userId_bonusId_tokenId">

  export type UserBonusOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: UserBonusCountOrderByAggregateInput
    _avg?: UserBonusAvgOrderByAggregateInput
    _max?: UserBonusMaxOrderByAggregateInput
    _min?: UserBonusMinOrderByAggregateInput
    _sum?: UserBonusSumOrderByAggregateInput
  }

  export type UserBonusScalarWhereWithAggregatesInput = {
    AND?: UserBonusScalarWhereWithAggregatesInput | UserBonusScalarWhereWithAggregatesInput[]
    OR?: UserBonusScalarWhereWithAggregatesInput[]
    NOT?: UserBonusScalarWhereWithAggregatesInput | UserBonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserBonus"> | number
    userId?: IntWithAggregatesFilter<"UserBonus"> | number
    bonusId?: IntWithAggregatesFilter<"UserBonus"> | number
    tokenId?: IntWithAggregatesFilter<"UserBonus"> | number
    grantedAmount?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalWithAggregatesFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"UserBonus"> | boolean
    isCompleted?: BoolWithAggregatesFilter<"UserBonus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserBonus"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserBonus"> | Date | string | null
  }

  export type LeaderboardEntryWhereInput = {
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    id?: IntFilter<"LeaderboardEntry"> | number
    userId?: IntFilter<"LeaderboardEntry"> | number
    tokenId?: IntNullableFilter<"LeaderboardEntry"> | number | null
    metric?: StringFilter<"LeaderboardEntry"> | string
    score?: DecimalFilter<"LeaderboardEntry"> | Decimal | DecimalJsLike | number | string
    period?: StringFilter<"LeaderboardEntry"> | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenNullableRelationFilter, CryptoTokenWhereInput> | null
  }

  export type LeaderboardEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type LeaderboardEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_metric_period_tokenId?: LeaderboardEntryUserIdMetricPeriodTokenIdCompoundUniqueInput
    AND?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    OR?: LeaderboardEntryWhereInput[]
    NOT?: LeaderboardEntryWhereInput | LeaderboardEntryWhereInput[]
    userId?: IntFilter<"LeaderboardEntry"> | number
    tokenId?: IntNullableFilter<"LeaderboardEntry"> | number | null
    metric?: StringFilter<"LeaderboardEntry"> | string
    score?: DecimalFilter<"LeaderboardEntry"> | Decimal | DecimalJsLike | number | string
    period?: StringFilter<"LeaderboardEntry"> | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenNullableRelationFilter, CryptoTokenWhereInput> | null
  }, "id" | "userId_metric_period_tokenId">

  export type LeaderboardEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaderboardEntryCountOrderByAggregateInput
    _avg?: LeaderboardEntryAvgOrderByAggregateInput
    _max?: LeaderboardEntryMaxOrderByAggregateInput
    _min?: LeaderboardEntryMinOrderByAggregateInput
    _sum?: LeaderboardEntrySumOrderByAggregateInput
  }

  export type LeaderboardEntryScalarWhereWithAggregatesInput = {
    AND?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    OR?: LeaderboardEntryScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardEntryScalarWhereWithAggregatesInput | LeaderboardEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    userId?: IntWithAggregatesFilter<"LeaderboardEntry"> | number
    tokenId?: IntNullableWithAggregatesFilter<"LeaderboardEntry"> | number | null
    metric?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    score?: DecimalWithAggregatesFilter<"LeaderboardEntry"> | Decimal | DecimalJsLike | number | string
    period?: StringWithAggregatesFilter<"LeaderboardEntry"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaderboardEntry"> | Date | string
  }

  export type ReferralTransactionWhereInput = {
    AND?: ReferralTransactionWhereInput | ReferralTransactionWhereInput[]
    OR?: ReferralTransactionWhereInput[]
    NOT?: ReferralTransactionWhereInput | ReferralTransactionWhereInput[]
    id?: IntFilter<"ReferralTransaction"> | number
    referrerId?: IntFilter<"ReferralTransaction"> | number
    refereeId?: IntFilter<"ReferralTransaction"> | number
    tokenId?: IntFilter<"ReferralTransaction"> | number
    eventType?: EnumReferralEventTypeFilter<"ReferralTransaction"> | $Enums.ReferralEventType
    amount?: DecimalFilter<"ReferralTransaction"> | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFilter<"ReferralTransaction"> | number
    sourceEntityType?: StringFilter<"ReferralTransaction"> | string
    createdAt?: DateTimeFilter<"ReferralTransaction"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referee?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type ReferralTransactionOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referee?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type ReferralTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferralTransactionWhereInput | ReferralTransactionWhereInput[]
    OR?: ReferralTransactionWhereInput[]
    NOT?: ReferralTransactionWhereInput | ReferralTransactionWhereInput[]
    referrerId?: IntFilter<"ReferralTransaction"> | number
    refereeId?: IntFilter<"ReferralTransaction"> | number
    tokenId?: IntFilter<"ReferralTransaction"> | number
    eventType?: EnumReferralEventTypeFilter<"ReferralTransaction"> | $Enums.ReferralEventType
    amount?: DecimalFilter<"ReferralTransaction"> | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFilter<"ReferralTransaction"> | number
    sourceEntityType?: StringFilter<"ReferralTransaction"> | string
    createdAt?: DateTimeFilter<"ReferralTransaction"> | Date | string
    referrer?: XOR<UserRelationFilter, UserWhereInput>
    referee?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id">

  export type ReferralTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
    _count?: ReferralTransactionCountOrderByAggregateInput
    _avg?: ReferralTransactionAvgOrderByAggregateInput
    _max?: ReferralTransactionMaxOrderByAggregateInput
    _min?: ReferralTransactionMinOrderByAggregateInput
    _sum?: ReferralTransactionSumOrderByAggregateInput
  }

  export type ReferralTransactionScalarWhereWithAggregatesInput = {
    AND?: ReferralTransactionScalarWhereWithAggregatesInput | ReferralTransactionScalarWhereWithAggregatesInput[]
    OR?: ReferralTransactionScalarWhereWithAggregatesInput[]
    NOT?: ReferralTransactionScalarWhereWithAggregatesInput | ReferralTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    referrerId?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    refereeId?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    tokenId?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    eventType?: EnumReferralEventTypeWithAggregatesFilter<"ReferralTransaction"> | $Enums.ReferralEventType
    amount?: DecimalWithAggregatesFilter<"ReferralTransaction"> | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntWithAggregatesFilter<"ReferralTransaction"> | number
    sourceEntityType?: StringWithAggregatesFilter<"ReferralTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReferralTransaction"> | Date | string
  }

  export type OneTimeTokenWhereInput = {
    AND?: OneTimeTokenWhereInput | OneTimeTokenWhereInput[]
    OR?: OneTimeTokenWhereInput[]
    NOT?: OneTimeTokenWhereInput | OneTimeTokenWhereInput[]
    id?: IntFilter<"OneTimeToken"> | number
    token?: StringFilter<"OneTimeToken"> | string
    userId?: IntFilter<"OneTimeToken"> | number
    createdAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    expiresAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    used?: BoolFilter<"OneTimeToken"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OneTimeTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OneTimeTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: OneTimeTokenWhereInput | OneTimeTokenWhereInput[]
    OR?: OneTimeTokenWhereInput[]
    NOT?: OneTimeTokenWhereInput | OneTimeTokenWhereInput[]
    userId?: IntFilter<"OneTimeToken"> | number
    createdAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    expiresAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    used?: BoolFilter<"OneTimeToken"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type OneTimeTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    _count?: OneTimeTokenCountOrderByAggregateInput
    _avg?: OneTimeTokenAvgOrderByAggregateInput
    _max?: OneTimeTokenMaxOrderByAggregateInput
    _min?: OneTimeTokenMinOrderByAggregateInput
    _sum?: OneTimeTokenSumOrderByAggregateInput
  }

  export type OneTimeTokenScalarWhereWithAggregatesInput = {
    AND?: OneTimeTokenScalarWhereWithAggregatesInput | OneTimeTokenScalarWhereWithAggregatesInput[]
    OR?: OneTimeTokenScalarWhereWithAggregatesInput[]
    NOT?: OneTimeTokenScalarWhereWithAggregatesInput | OneTimeTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OneTimeToken"> | number
    token?: StringWithAggregatesFilter<"OneTimeToken"> | string
    userId?: IntWithAggregatesFilter<"OneTimeToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OneTimeToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"OneTimeToken"> | Date | string
    used?: BoolWithAggregatesFilter<"OneTimeToken"> | boolean
  }

  export type CrashRoundWhereInput = {
    AND?: CrashRoundWhereInput | CrashRoundWhereInput[]
    OR?: CrashRoundWhereInput[]
    NOT?: CrashRoundWhereInput | CrashRoundWhereInput[]
    id?: IntFilter<"CrashRound"> | number
    gameId?: StringFilter<"CrashRound"> | string
    crashPoint?: DecimalFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntFilter<"CrashRound"> | number
    winnersCount?: IntFilter<"CrashRound"> | number
    totalWagered?: DecimalFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    serverSeedHash?: StringFilter<"CrashRound"> | string
    clientSeed?: StringFilter<"CrashRound"> | string
    nonce?: IntFilter<"CrashRound"> | number
    createdAt?: DateTimeFilter<"CrashRound"> | Date | string
    updatedAt?: DateTimeFilter<"CrashRound"> | Date | string
    bets?: CrashBetListRelationFilter
  }

  export type CrashRoundOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    crashPoint?: SortOrder
    totalPlayers?: SortOrder
    winnersCount?: SortOrder
    totalWagered?: SortOrder
    totalPayouts?: SortOrder
    serverSeedHash?: SortOrder
    clientSeed?: SortOrder
    nonce?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bets?: CrashBetOrderByRelationAggregateInput
  }

  export type CrashRoundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    gameId?: string
    serverSeedHash?: string
    AND?: CrashRoundWhereInput | CrashRoundWhereInput[]
    OR?: CrashRoundWhereInput[]
    NOT?: CrashRoundWhereInput | CrashRoundWhereInput[]
    crashPoint?: DecimalFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntFilter<"CrashRound"> | number
    winnersCount?: IntFilter<"CrashRound"> | number
    totalWagered?: DecimalFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    clientSeed?: StringFilter<"CrashRound"> | string
    nonce?: IntFilter<"CrashRound"> | number
    createdAt?: DateTimeFilter<"CrashRound"> | Date | string
    updatedAt?: DateTimeFilter<"CrashRound"> | Date | string
    bets?: CrashBetListRelationFilter
  }, "id" | "gameId" | "serverSeedHash">

  export type CrashRoundOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    crashPoint?: SortOrder
    totalPlayers?: SortOrder
    winnersCount?: SortOrder
    totalWagered?: SortOrder
    totalPayouts?: SortOrder
    serverSeedHash?: SortOrder
    clientSeed?: SortOrder
    nonce?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrashRoundCountOrderByAggregateInput
    _avg?: CrashRoundAvgOrderByAggregateInput
    _max?: CrashRoundMaxOrderByAggregateInput
    _min?: CrashRoundMinOrderByAggregateInput
    _sum?: CrashRoundSumOrderByAggregateInput
  }

  export type CrashRoundScalarWhereWithAggregatesInput = {
    AND?: CrashRoundScalarWhereWithAggregatesInput | CrashRoundScalarWhereWithAggregatesInput[]
    OR?: CrashRoundScalarWhereWithAggregatesInput[]
    NOT?: CrashRoundScalarWhereWithAggregatesInput | CrashRoundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CrashRound"> | number
    gameId?: StringWithAggregatesFilter<"CrashRound"> | string
    crashPoint?: DecimalWithAggregatesFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntWithAggregatesFilter<"CrashRound"> | number
    winnersCount?: IntWithAggregatesFilter<"CrashRound"> | number
    totalWagered?: DecimalWithAggregatesFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalWithAggregatesFilter<"CrashRound"> | Decimal | DecimalJsLike | number | string
    serverSeedHash?: StringWithAggregatesFilter<"CrashRound"> | string
    clientSeed?: StringWithAggregatesFilter<"CrashRound"> | string
    nonce?: IntWithAggregatesFilter<"CrashRound"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CrashRound"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CrashRound"> | Date | string
  }

  export type CrashBetWhereInput = {
    AND?: CrashBetWhereInput | CrashBetWhereInput[]
    OR?: CrashBetWhereInput[]
    NOT?: CrashBetWhereInput | CrashBetWhereInput[]
    id?: IntFilter<"CrashBet"> | number
    roundId?: IntFilter<"CrashBet"> | number
    userId?: IntFilter<"CrashBet"> | number
    tokenId?: IntFilter<"CrashBet"> | number
    betAmount?: DecimalFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string
    exitMultiplier?: DecimalNullableFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string | null
    winnings?: DecimalNullableFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string | null
    result?: StringFilter<"CrashBet"> | string
    createdAt?: DateTimeFilter<"CrashBet"> | Date | string
    round?: XOR<CrashRoundRelationFilter, CrashRoundWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
    transactions?: CrashTransactionListRelationFilter
  }

  export type CrashBetOrderByWithRelationInput = {
    id?: SortOrder
    roundId?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    exitMultiplier?: SortOrderInput | SortOrder
    winnings?: SortOrderInput | SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    round?: CrashRoundOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
    transactions?: CrashTransactionOrderByRelationAggregateInput
  }

  export type CrashBetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CrashBetWhereInput | CrashBetWhereInput[]
    OR?: CrashBetWhereInput[]
    NOT?: CrashBetWhereInput | CrashBetWhereInput[]
    roundId?: IntFilter<"CrashBet"> | number
    userId?: IntFilter<"CrashBet"> | number
    tokenId?: IntFilter<"CrashBet"> | number
    betAmount?: DecimalFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string
    exitMultiplier?: DecimalNullableFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string | null
    winnings?: DecimalNullableFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string | null
    result?: StringFilter<"CrashBet"> | string
    createdAt?: DateTimeFilter<"CrashBet"> | Date | string
    round?: XOR<CrashRoundRelationFilter, CrashRoundWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
    transactions?: CrashTransactionListRelationFilter
  }, "id">

  export type CrashBetOrderByWithAggregationInput = {
    id?: SortOrder
    roundId?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    exitMultiplier?: SortOrderInput | SortOrder
    winnings?: SortOrderInput | SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    _count?: CrashBetCountOrderByAggregateInput
    _avg?: CrashBetAvgOrderByAggregateInput
    _max?: CrashBetMaxOrderByAggregateInput
    _min?: CrashBetMinOrderByAggregateInput
    _sum?: CrashBetSumOrderByAggregateInput
  }

  export type CrashBetScalarWhereWithAggregatesInput = {
    AND?: CrashBetScalarWhereWithAggregatesInput | CrashBetScalarWhereWithAggregatesInput[]
    OR?: CrashBetScalarWhereWithAggregatesInput[]
    NOT?: CrashBetScalarWhereWithAggregatesInput | CrashBetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CrashBet"> | number
    roundId?: IntWithAggregatesFilter<"CrashBet"> | number
    userId?: IntWithAggregatesFilter<"CrashBet"> | number
    tokenId?: IntWithAggregatesFilter<"CrashBet"> | number
    betAmount?: DecimalWithAggregatesFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string
    exitMultiplier?: DecimalNullableWithAggregatesFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string | null
    winnings?: DecimalNullableWithAggregatesFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string | null
    result?: StringWithAggregatesFilter<"CrashBet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CrashBet"> | Date | string
  }

  export type CrashTransactionWhereInput = {
    AND?: CrashTransactionWhereInput | CrashTransactionWhereInput[]
    OR?: CrashTransactionWhereInput[]
    NOT?: CrashTransactionWhereInput | CrashTransactionWhereInput[]
    id?: IntFilter<"CrashTransaction"> | number
    userId?: IntFilter<"CrashTransaction"> | number
    betId?: IntNullableFilter<"CrashTransaction"> | number | null
    tokenId?: IntFilter<"CrashTransaction"> | number
    amount?: DecimalFilter<"CrashTransaction"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"CrashTransaction"> | string
    createdAt?: DateTimeFilter<"CrashTransaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    bet?: XOR<CrashBetNullableRelationFilter, CrashBetWhereInput> | null
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type CrashTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    betId?: SortOrderInput | SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bet?: CrashBetOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type CrashTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CrashTransactionWhereInput | CrashTransactionWhereInput[]
    OR?: CrashTransactionWhereInput[]
    NOT?: CrashTransactionWhereInput | CrashTransactionWhereInput[]
    userId?: IntFilter<"CrashTransaction"> | number
    betId?: IntNullableFilter<"CrashTransaction"> | number | null
    tokenId?: IntFilter<"CrashTransaction"> | number
    amount?: DecimalFilter<"CrashTransaction"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"CrashTransaction"> | string
    createdAt?: DateTimeFilter<"CrashTransaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    bet?: XOR<CrashBetNullableRelationFilter, CrashBetWhereInput> | null
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id">

  export type CrashTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    betId?: SortOrderInput | SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: CrashTransactionCountOrderByAggregateInput
    _avg?: CrashTransactionAvgOrderByAggregateInput
    _max?: CrashTransactionMaxOrderByAggregateInput
    _min?: CrashTransactionMinOrderByAggregateInput
    _sum?: CrashTransactionSumOrderByAggregateInput
  }

  export type CrashTransactionScalarWhereWithAggregatesInput = {
    AND?: CrashTransactionScalarWhereWithAggregatesInput | CrashTransactionScalarWhereWithAggregatesInput[]
    OR?: CrashTransactionScalarWhereWithAggregatesInput[]
    NOT?: CrashTransactionScalarWhereWithAggregatesInput | CrashTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CrashTransaction"> | number
    userId?: IntWithAggregatesFilter<"CrashTransaction"> | number
    betId?: IntNullableWithAggregatesFilter<"CrashTransaction"> | number | null
    tokenId?: IntWithAggregatesFilter<"CrashTransaction"> | number
    amount?: DecimalWithAggregatesFilter<"CrashTransaction"> | Decimal | DecimalJsLike | number | string
    type?: StringWithAggregatesFilter<"CrashTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CrashTransaction"> | Date | string
  }

  export type MinesweeperDifficultyWhereInput = {
    AND?: MinesweeperDifficultyWhereInput | MinesweeperDifficultyWhereInput[]
    OR?: MinesweeperDifficultyWhereInput[]
    NOT?: MinesweeperDifficultyWhereInput | MinesweeperDifficultyWhereInput[]
    id?: IntFilter<"MinesweeperDifficulty"> | number
    name?: StringFilter<"MinesweeperDifficulty"> | string
    minesCount?: IntFilter<"MinesweeperDifficulty"> | number
    gridSize?: IntFilter<"MinesweeperDifficulty"> | number
    multiplier?: FloatFilter<"MinesweeperDifficulty"> | number
    createdAt?: DateTimeFilter<"MinesweeperDifficulty"> | Date | string
    games?: MinesweeperGameListRelationFilter
  }

  export type MinesweeperDifficultyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    minesCount?: SortOrder
    gridSize?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    games?: MinesweeperGameOrderByRelationAggregateInput
  }

  export type MinesweeperDifficultyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: MinesweeperDifficultyWhereInput | MinesweeperDifficultyWhereInput[]
    OR?: MinesweeperDifficultyWhereInput[]
    NOT?: MinesweeperDifficultyWhereInput | MinesweeperDifficultyWhereInput[]
    minesCount?: IntFilter<"MinesweeperDifficulty"> | number
    gridSize?: IntFilter<"MinesweeperDifficulty"> | number
    multiplier?: FloatFilter<"MinesweeperDifficulty"> | number
    createdAt?: DateTimeFilter<"MinesweeperDifficulty"> | Date | string
    games?: MinesweeperGameListRelationFilter
  }, "id" | "name">

  export type MinesweeperDifficultyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    minesCount?: SortOrder
    gridSize?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    _count?: MinesweeperDifficultyCountOrderByAggregateInput
    _avg?: MinesweeperDifficultyAvgOrderByAggregateInput
    _max?: MinesweeperDifficultyMaxOrderByAggregateInput
    _min?: MinesweeperDifficultyMinOrderByAggregateInput
    _sum?: MinesweeperDifficultySumOrderByAggregateInput
  }

  export type MinesweeperDifficultyScalarWhereWithAggregatesInput = {
    AND?: MinesweeperDifficultyScalarWhereWithAggregatesInput | MinesweeperDifficultyScalarWhereWithAggregatesInput[]
    OR?: MinesweeperDifficultyScalarWhereWithAggregatesInput[]
    NOT?: MinesweeperDifficultyScalarWhereWithAggregatesInput | MinesweeperDifficultyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MinesweeperDifficulty"> | number
    name?: StringWithAggregatesFilter<"MinesweeperDifficulty"> | string
    minesCount?: IntWithAggregatesFilter<"MinesweeperDifficulty"> | number
    gridSize?: IntWithAggregatesFilter<"MinesweeperDifficulty"> | number
    multiplier?: FloatWithAggregatesFilter<"MinesweeperDifficulty"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MinesweeperDifficulty"> | Date | string
  }

  export type MinesweeperGameWhereInput = {
    AND?: MinesweeperGameWhereInput | MinesweeperGameWhereInput[]
    OR?: MinesweeperGameWhereInput[]
    NOT?: MinesweeperGameWhereInput | MinesweeperGameWhereInput[]
    id?: IntFilter<"MinesweeperGame"> | number
    userId?: IntFilter<"MinesweeperGame"> | number
    tokenId?: IntFilter<"MinesweeperGame"> | number
    difficultyId?: IntFilter<"MinesweeperGame"> | number
    gameState?: JsonFilter<"MinesweeperGame">
    minesPositions?: JsonFilter<"MinesweeperGame">
    status?: StringFilter<"MinesweeperGame"> | string
    revealedCells?: IntFilter<"MinesweeperGame"> | number
    flaggedCells?: IntFilter<"MinesweeperGame"> | number
    betAmount?: DecimalFilter<"MinesweeperGame"> | Decimal | DecimalJsLike | number | string
    winAmount?: DecimalNullableFilter<"MinesweeperGame"> | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFilter<"MinesweeperGame"> | number
    createdAt?: DateTimeFilter<"MinesweeperGame"> | Date | string
    updatedAt?: DateTimeFilter<"MinesweeperGame"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
    difficulty?: XOR<MinesweeperDifficultyRelationFilter, MinesweeperDifficultyWhereInput>
  }

  export type MinesweeperGameOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    difficultyId?: SortOrder
    gameState?: SortOrder
    minesPositions?: SortOrder
    status?: SortOrder
    revealedCells?: SortOrder
    flaggedCells?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrderInput | SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
    difficulty?: MinesweeperDifficultyOrderByWithRelationInput
  }

  export type MinesweeperGameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MinesweeperGameWhereInput | MinesweeperGameWhereInput[]
    OR?: MinesweeperGameWhereInput[]
    NOT?: MinesweeperGameWhereInput | MinesweeperGameWhereInput[]
    userId?: IntFilter<"MinesweeperGame"> | number
    tokenId?: IntFilter<"MinesweeperGame"> | number
    difficultyId?: IntFilter<"MinesweeperGame"> | number
    gameState?: JsonFilter<"MinesweeperGame">
    minesPositions?: JsonFilter<"MinesweeperGame">
    status?: StringFilter<"MinesweeperGame"> | string
    revealedCells?: IntFilter<"MinesweeperGame"> | number
    flaggedCells?: IntFilter<"MinesweeperGame"> | number
    betAmount?: DecimalFilter<"MinesweeperGame"> | Decimal | DecimalJsLike | number | string
    winAmount?: DecimalNullableFilter<"MinesweeperGame"> | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFilter<"MinesweeperGame"> | number
    createdAt?: DateTimeFilter<"MinesweeperGame"> | Date | string
    updatedAt?: DateTimeFilter<"MinesweeperGame"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
    difficulty?: XOR<MinesweeperDifficultyRelationFilter, MinesweeperDifficultyWhereInput>
  }, "id">

  export type MinesweeperGameOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    difficultyId?: SortOrder
    gameState?: SortOrder
    minesPositions?: SortOrder
    status?: SortOrder
    revealedCells?: SortOrder
    flaggedCells?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrderInput | SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MinesweeperGameCountOrderByAggregateInput
    _avg?: MinesweeperGameAvgOrderByAggregateInput
    _max?: MinesweeperGameMaxOrderByAggregateInput
    _min?: MinesweeperGameMinOrderByAggregateInput
    _sum?: MinesweeperGameSumOrderByAggregateInput
  }

  export type MinesweeperGameScalarWhereWithAggregatesInput = {
    AND?: MinesweeperGameScalarWhereWithAggregatesInput | MinesweeperGameScalarWhereWithAggregatesInput[]
    OR?: MinesweeperGameScalarWhereWithAggregatesInput[]
    NOT?: MinesweeperGameScalarWhereWithAggregatesInput | MinesweeperGameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MinesweeperGame"> | number
    userId?: IntWithAggregatesFilter<"MinesweeperGame"> | number
    tokenId?: IntWithAggregatesFilter<"MinesweeperGame"> | number
    difficultyId?: IntWithAggregatesFilter<"MinesweeperGame"> | number
    gameState?: JsonWithAggregatesFilter<"MinesweeperGame">
    minesPositions?: JsonWithAggregatesFilter<"MinesweeperGame">
    status?: StringWithAggregatesFilter<"MinesweeperGame"> | string
    revealedCells?: IntWithAggregatesFilter<"MinesweeperGame"> | number
    flaggedCells?: IntWithAggregatesFilter<"MinesweeperGame"> | number
    betAmount?: DecimalWithAggregatesFilter<"MinesweeperGame"> | Decimal | DecimalJsLike | number | string
    winAmount?: DecimalNullableWithAggregatesFilter<"MinesweeperGame"> | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatWithAggregatesFilter<"MinesweeperGame"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MinesweeperGame"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MinesweeperGame"> | Date | string
  }

  export type MinesweeperBetWhereInput = {
    AND?: MinesweeperBetWhereInput | MinesweeperBetWhereInput[]
    OR?: MinesweeperBetWhereInput[]
    NOT?: MinesweeperBetWhereInput | MinesweeperBetWhereInput[]
    id?: IntFilter<"MinesweeperBet"> | number
    userId?: IntFilter<"MinesweeperBet"> | number
    tokenId?: IntFilter<"MinesweeperBet"> | number
    gameId?: IntFilter<"MinesweeperBet"> | number
    betAmount?: DecimalFilter<"MinesweeperBet"> | Decimal | DecimalJsLike | number | string
    winAmount?: DecimalNullableFilter<"MinesweeperBet"> | Decimal | DecimalJsLike | number | string | null
    result?: StringFilter<"MinesweeperBet"> | string
    multiplier?: FloatFilter<"MinesweeperBet"> | number
    createdAt?: DateTimeFilter<"MinesweeperBet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }

  export type MinesweeperBetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameId?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrderInput | SortOrder
    result?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    token?: CryptoTokenOrderByWithRelationInput
  }

  export type MinesweeperBetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MinesweeperBetWhereInput | MinesweeperBetWhereInput[]
    OR?: MinesweeperBetWhereInput[]
    NOT?: MinesweeperBetWhereInput | MinesweeperBetWhereInput[]
    userId?: IntFilter<"MinesweeperBet"> | number
    tokenId?: IntFilter<"MinesweeperBet"> | number
    gameId?: IntFilter<"MinesweeperBet"> | number
    betAmount?: DecimalFilter<"MinesweeperBet"> | Decimal | DecimalJsLike | number | string
    winAmount?: DecimalNullableFilter<"MinesweeperBet"> | Decimal | DecimalJsLike | number | string | null
    result?: StringFilter<"MinesweeperBet"> | string
    multiplier?: FloatFilter<"MinesweeperBet"> | number
    createdAt?: DateTimeFilter<"MinesweeperBet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    token?: XOR<CryptoTokenRelationFilter, CryptoTokenWhereInput>
  }, "id">

  export type MinesweeperBetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameId?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrderInput | SortOrder
    result?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    _count?: MinesweeperBetCountOrderByAggregateInput
    _avg?: MinesweeperBetAvgOrderByAggregateInput
    _max?: MinesweeperBetMaxOrderByAggregateInput
    _min?: MinesweeperBetMinOrderByAggregateInput
    _sum?: MinesweeperBetSumOrderByAggregateInput
  }

  export type MinesweeperBetScalarWhereWithAggregatesInput = {
    AND?: MinesweeperBetScalarWhereWithAggregatesInput | MinesweeperBetScalarWhereWithAggregatesInput[]
    OR?: MinesweeperBetScalarWhereWithAggregatesInput[]
    NOT?: MinesweeperBetScalarWhereWithAggregatesInput | MinesweeperBetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MinesweeperBet"> | number
    userId?: IntWithAggregatesFilter<"MinesweeperBet"> | number
    tokenId?: IntWithAggregatesFilter<"MinesweeperBet"> | number
    gameId?: IntWithAggregatesFilter<"MinesweeperBet"> | number
    betAmount?: DecimalWithAggregatesFilter<"MinesweeperBet"> | Decimal | DecimalJsLike | number | string
    winAmount?: DecimalNullableWithAggregatesFilter<"MinesweeperBet"> | Decimal | DecimalJsLike | number | string | null
    result?: StringWithAggregatesFilter<"MinesweeperBet"> | string
    multiplier?: FloatWithAggregatesFilter<"MinesweeperBet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MinesweeperBet"> | Date | string
  }

  export type CryptoTokenCreateInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenCreateManyInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
  }

  export type CryptoTokenUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
  }

  export type UserUpdateManyMutationInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BalanceCreateInput = {
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBalancesInput
    token: CryptoTokenCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceUpdateInput = {
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBalancesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceCreateManyInput = {
    id?: number
    userId: number
    tokenId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceUpdateManyMutationInput = {
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    token: CryptoTokenCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: number
    userId: number
    tokenId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetCreateInput = {
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBetsInput
    token: CryptoTokenCreateNestedOneWithoutBetsInput
  }

  export type BetUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BetUpdateInput = {
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBetsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutBetsNestedInput
  }

  export type BetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetCreateManyInput = {
    id?: number
    userId: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BetUpdateManyMutationInput = {
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BonusCreateInput = {
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusCreateNestedManyWithoutBonusInput
  }

  export type BonusUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutBonusInput
  }

  export type BonusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusUpdateManyWithoutBonusNestedInput
  }

  export type BonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBonuses?: UserBonusUncheckedUpdateManyWithoutBonusNestedInput
  }

  export type BonusCreateManyInput = {
    id?: number
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
  }

  export type BonusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserBonusCreateInput = {
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutBonusesInput
    bonus: BonusCreateNestedOneWithoutUserBonusesInput
    token: CryptoTokenCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateInput = {
    id?: number
    userId: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusUpdateInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    bonus?: BonusUpdateOneRequiredWithoutUserBonusesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusCreateManyInput = {
    id?: number
    userId: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusUpdateManyMutationInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaderboardEntryCreateInput = {
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
    token?: CryptoTokenCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardEntryUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId?: number | null
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryUpdateInput = {
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
    token?: CryptoTokenUpdateOneWithoutLeaderboardNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: NullableIntFieldUpdateOperationsInput | number | null
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryCreateManyInput = {
    id?: number
    userId: number
    tokenId?: number | null
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryUpdateManyMutationInput = {
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: NullableIntFieldUpdateOperationsInput | number | null
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionCreateInput = {
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutCommissionsInput
    referee: UserCreateNestedOneWithoutReferralActionsInput
    token: CryptoTokenCreateNestedOneWithoutReferralCommissionsInput
  }

  export type ReferralTransactionUncheckedCreateInput = {
    id?: number
    referrerId: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionUpdateInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutCommissionsNestedInput
    referee?: UserUpdateOneRequiredWithoutReferralActionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutReferralCommissionsNestedInput
  }

  export type ReferralTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionCreateManyInput = {
    id?: number
    referrerId: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionUpdateManyMutationInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneTimeTokenCreateInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
    user: UserCreateNestedOneWithoutAuthTokensInput
  }

  export type OneTimeTokenUncheckedCreateInput = {
    id?: number
    token: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type OneTimeTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAuthTokensNestedInput
  }

  export type OneTimeTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OneTimeTokenCreateManyInput = {
    id?: number
    token: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type OneTimeTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OneTimeTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrashRoundCreateInput = {
    gameId: string
    crashPoint: Decimal | DecimalJsLike | number | string
    totalPlayers?: number
    winnersCount?: number
    totalWagered?: Decimal | DecimalJsLike | number | string
    totalPayouts?: Decimal | DecimalJsLike | number | string
    serverSeedHash: string
    clientSeed: string
    nonce?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bets?: CrashBetCreateNestedManyWithoutRoundInput
  }

  export type CrashRoundUncheckedCreateInput = {
    id?: number
    gameId: string
    crashPoint: Decimal | DecimalJsLike | number | string
    totalPlayers?: number
    winnersCount?: number
    totalWagered?: Decimal | DecimalJsLike | number | string
    totalPayouts?: Decimal | DecimalJsLike | number | string
    serverSeedHash: string
    clientSeed: string
    nonce?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bets?: CrashBetUncheckedCreateNestedManyWithoutRoundInput
  }

  export type CrashRoundUpdateInput = {
    gameId?: StringFieldUpdateOperationsInput | string
    crashPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntFieldUpdateOperationsInput | number
    winnersCount?: IntFieldUpdateOperationsInput | number
    totalWagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serverSeedHash?: StringFieldUpdateOperationsInput | string
    clientSeed?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bets?: CrashBetUpdateManyWithoutRoundNestedInput
  }

  export type CrashRoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    crashPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntFieldUpdateOperationsInput | number
    winnersCount?: IntFieldUpdateOperationsInput | number
    totalWagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serverSeedHash?: StringFieldUpdateOperationsInput | string
    clientSeed?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bets?: CrashBetUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type CrashRoundCreateManyInput = {
    id?: number
    gameId: string
    crashPoint: Decimal | DecimalJsLike | number | string
    totalPlayers?: number
    winnersCount?: number
    totalWagered?: Decimal | DecimalJsLike | number | string
    totalPayouts?: Decimal | DecimalJsLike | number | string
    serverSeedHash: string
    clientSeed: string
    nonce?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrashRoundUpdateManyMutationInput = {
    gameId?: StringFieldUpdateOperationsInput | string
    crashPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntFieldUpdateOperationsInput | number
    winnersCount?: IntFieldUpdateOperationsInput | number
    totalWagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serverSeedHash?: StringFieldUpdateOperationsInput | string
    clientSeed?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashRoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    crashPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntFieldUpdateOperationsInput | number
    winnersCount?: IntFieldUpdateOperationsInput | number
    totalWagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serverSeedHash?: StringFieldUpdateOperationsInput | string
    clientSeed?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashBetCreateInput = {
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    round: CrashRoundCreateNestedOneWithoutBetsInput
    user: UserCreateNestedOneWithoutCrashBetsInput
    token: CryptoTokenCreateNestedOneWithoutCrashBetsInput
    transactions?: CrashTransactionCreateNestedManyWithoutBetInput
  }

  export type CrashBetUncheckedCreateInput = {
    id?: number
    roundId: number
    userId: number
    tokenId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    transactions?: CrashTransactionUncheckedCreateNestedManyWithoutBetInput
  }

  export type CrashBetUpdateInput = {
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: CrashRoundUpdateOneRequiredWithoutBetsNestedInput
    user?: UserUpdateOneRequiredWithoutCrashBetsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutCrashBetsNestedInput
    transactions?: CrashTransactionUpdateManyWithoutBetNestedInput
  }

  export type CrashBetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CrashTransactionUncheckedUpdateManyWithoutBetNestedInput
  }

  export type CrashBetCreateManyInput = {
    id?: number
    roundId: number
    userId: number
    tokenId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
  }

  export type CrashBetUpdateManyMutationInput = {
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashBetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCrashTransactionsInput
    bet?: CrashBetCreateNestedOneWithoutTransactionsInput
    token: CryptoTokenCreateNestedOneWithoutCrashTransactionsInput
  }

  export type CrashTransactionUncheckedCreateInput = {
    id?: number
    userId: number
    betId?: number | null
    tokenId: number
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type CrashTransactionUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCrashTransactionsNestedInput
    bet?: CrashBetUpdateOneWithoutTransactionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutCrashTransactionsNestedInput
  }

  export type CrashTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    betId?: NullableIntFieldUpdateOperationsInput | number | null
    tokenId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionCreateManyInput = {
    id?: number
    userId: number
    betId?: number | null
    tokenId: number
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type CrashTransactionUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    betId?: NullableIntFieldUpdateOperationsInput | number | null
    tokenId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperDifficultyCreateInput = {
    name: string
    minesCount: number
    gridSize?: number
    multiplier: number
    createdAt?: Date | string
    games?: MinesweeperGameCreateNestedManyWithoutDifficultyInput
  }

  export type MinesweeperDifficultyUncheckedCreateInput = {
    id?: number
    name: string
    minesCount: number
    gridSize?: number
    multiplier: number
    createdAt?: Date | string
    games?: MinesweeperGameUncheckedCreateNestedManyWithoutDifficultyInput
  }

  export type MinesweeperDifficultyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    minesCount?: IntFieldUpdateOperationsInput | number
    gridSize?: IntFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: MinesweeperGameUpdateManyWithoutDifficultyNestedInput
  }

  export type MinesweeperDifficultyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minesCount?: IntFieldUpdateOperationsInput | number
    gridSize?: IntFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: MinesweeperGameUncheckedUpdateManyWithoutDifficultyNestedInput
  }

  export type MinesweeperDifficultyCreateManyInput = {
    id?: number
    name: string
    minesCount: number
    gridSize?: number
    multiplier: number
    createdAt?: Date | string
  }

  export type MinesweeperDifficultyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    minesCount?: IntFieldUpdateOperationsInput | number
    gridSize?: IntFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperDifficultyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minesCount?: IntFieldUpdateOperationsInput | number
    gridSize?: IntFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameCreateInput = {
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMinesweeperGamesInput
    token: CryptoTokenCreateNestedOneWithoutMinesweeperGamesInput
    difficulty: MinesweeperDifficultyCreateNestedOneWithoutGamesInput
  }

  export type MinesweeperGameUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId: number
    difficultyId: number
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinesweeperGameUpdateInput = {
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMinesweeperGamesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutMinesweeperGamesNestedInput
    difficulty?: MinesweeperDifficultyUpdateOneRequiredWithoutGamesNestedInput
  }

  export type MinesweeperGameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    difficultyId?: IntFieldUpdateOperationsInput | number
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameCreateManyInput = {
    id?: number
    userId: number
    tokenId: number
    difficultyId: number
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinesweeperGameUpdateManyMutationInput = {
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    difficultyId?: IntFieldUpdateOperationsInput | number
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperBetCreateInput = {
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMinesweeperBetsInput
    token: CryptoTokenCreateNestedOneWithoutMinesweeperBetsInput
  }

  export type MinesweeperBetUncheckedCreateInput = {
    id?: number
    userId: number
    tokenId: number
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
  }

  export type MinesweeperBetUpdateInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMinesweeperBetsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutMinesweeperBetsNestedInput
  }

  export type MinesweeperBetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperBetCreateManyInput = {
    id?: number
    userId: number
    tokenId: number
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
  }

  export type MinesweeperBetUpdateManyMutationInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperBetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CrashBetListRelationFilter = {
    every?: CrashBetWhereInput
    some?: CrashBetWhereInput
    none?: CrashBetWhereInput
  }

  export type CrashTransactionListRelationFilter = {
    every?: CrashTransactionWhereInput
    some?: CrashTransactionWhereInput
    none?: CrashTransactionWhereInput
  }

  export type MinesweeperGameListRelationFilter = {
    every?: MinesweeperGameWhereInput
    some?: MinesweeperGameWhereInput
    none?: MinesweeperGameWhereInput
  }

  export type MinesweeperBetListRelationFilter = {
    every?: MinesweeperBetWhereInput
    some?: MinesweeperBetWhereInput
    none?: MinesweeperBetWhereInput
  }

  export type BalanceListRelationFilter = {
    every?: BalanceWhereInput
    some?: BalanceWhereInput
    none?: BalanceWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type BetListRelationFilter = {
    every?: BetWhereInput
    some?: BetWhereInput
    none?: BetWhereInput
  }

  export type LeaderboardEntryListRelationFilter = {
    every?: LeaderboardEntryWhereInput
    some?: LeaderboardEntryWhereInput
    none?: LeaderboardEntryWhereInput
  }

  export type UserBonusListRelationFilter = {
    every?: UserBonusWhereInput
    some?: UserBonusWhereInput
    none?: UserBonusWhereInput
  }

  export type ReferralTransactionListRelationFilter = {
    every?: ReferralTransactionWhereInput
    some?: ReferralTransactionWhereInput
    none?: ReferralTransactionWhereInput
  }

  export type CrashBetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrashTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MinesweeperGameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MinesweeperBetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoTokenCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
  }

  export type CryptoTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    decimals?: SortOrder
  }

  export type CryptoTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
  }

  export type CryptoTokenMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    network?: SortOrder
    decimals?: SortOrder
    createdAt?: SortOrder
  }

  export type CryptoTokenSumOrderByAggregateInput = {
    id?: SortOrder
    decimals?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type OneTimeTokenListRelationFilter = {
    every?: OneTimeTokenWhereInput
    some?: OneTimeTokenWhereInput
    none?: OneTimeTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OneTimeTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photoUrl?: SortOrder
    passwordHash?: SortOrder
    salt?: SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    referredById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photoUrl?: SortOrder
    passwordHash?: SortOrder
    salt?: SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photoUrl?: SortOrder
    passwordHash?: SortOrder
    salt?: SortOrder
    isAdmin?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    referredById?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumBalanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeFilter<$PrismaModel> | $Enums.BalanceType
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CryptoTokenRelationFilter = {
    is?: CryptoTokenWhereInput
    isNot?: CryptoTokenWhereInput
  }

  export type BalanceUserIdTokenIdTypeCompoundUniqueInput = {
    userId: number
    tokenId: number
    type: $Enums.BalanceType
  }

  export type BalanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type BalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type EnumBalanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.BalanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBalanceTypeFilter<$PrismaModel>
    _max?: NestedEnumBalanceTypeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type TransactionTxHashUserIdCompoundUniqueInput = {
    txHash: string
    userId: number
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    walletAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumGameTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameTypeFilter<$PrismaModel> | $Enums.GameType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type BetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
  }

  export type BetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    createdAt?: SortOrder
  }

  export type BetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameType?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
    roundId?: SortOrder
    createdAt?: SortOrder
  }

  export type BetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    payoutAmount?: SortOrder
    netAmount?: SortOrder
    payoutRatio?: SortOrder
  }

  export type EnumGameTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameTypeFilter<$PrismaModel>
    _max?: NestedEnumGameTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BonusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type BonusAvgOrderByAggregateInput = {
    id?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type BonusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type BonusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type BonusSumOrderByAggregateInput = {
    id?: SortOrder
    wageringMultiplier?: SortOrder
    maxBonusAmount?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BonusRelationFilter = {
    is?: BonusWhereInput
    isNot?: BonusWhereInput
  }

  export type UserBonusUserIdBonusIdTokenIdCompoundUniqueInput = {
    userId: number
    bonusId: number
    tokenId: number
  }

  export type UserBonusCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserBonusAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
  }

  export type UserBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserBonusMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
    isActive?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserBonusSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bonusId?: SortOrder
    tokenId?: SortOrder
    grantedAmount?: SortOrder
    requiredWager?: SortOrder
    wageredAmount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CryptoTokenNullableRelationFilter = {
    is?: CryptoTokenWhereInput | null
    isNot?: CryptoTokenWhereInput | null
  }

  export type LeaderboardEntryUserIdMetricPeriodTokenIdCompoundUniqueInput = {
    userId: number
    metric: string
    period: string
    tokenId: number
  }

  export type LeaderboardEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
  }

  export type LeaderboardEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    metric?: SortOrder
    score?: SortOrder
    period?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardEntrySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
  }

  export type EnumReferralEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralEventType | EnumReferralEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralEventTypeFilter<$PrismaModel> | $Enums.ReferralEventType
  }

  export type ReferralTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
  }

  export type ReferralTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    eventType?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
    sourceEntityType?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    sourceEntityId?: SortOrder
  }

  export type EnumReferralEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralEventType | EnumReferralEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReferralEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferralEventTypeFilter<$PrismaModel>
    _max?: NestedEnumReferralEventTypeFilter<$PrismaModel>
  }

  export type OneTimeTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type OneTimeTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OneTimeTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type OneTimeTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type OneTimeTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CrashRoundCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    crashPoint?: SortOrder
    totalPlayers?: SortOrder
    winnersCount?: SortOrder
    totalWagered?: SortOrder
    totalPayouts?: SortOrder
    serverSeedHash?: SortOrder
    clientSeed?: SortOrder
    nonce?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrashRoundAvgOrderByAggregateInput = {
    id?: SortOrder
    crashPoint?: SortOrder
    totalPlayers?: SortOrder
    winnersCount?: SortOrder
    totalWagered?: SortOrder
    totalPayouts?: SortOrder
    nonce?: SortOrder
  }

  export type CrashRoundMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    crashPoint?: SortOrder
    totalPlayers?: SortOrder
    winnersCount?: SortOrder
    totalWagered?: SortOrder
    totalPayouts?: SortOrder
    serverSeedHash?: SortOrder
    clientSeed?: SortOrder
    nonce?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrashRoundMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    crashPoint?: SortOrder
    totalPlayers?: SortOrder
    winnersCount?: SortOrder
    totalWagered?: SortOrder
    totalPayouts?: SortOrder
    serverSeedHash?: SortOrder
    clientSeed?: SortOrder
    nonce?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrashRoundSumOrderByAggregateInput = {
    id?: SortOrder
    crashPoint?: SortOrder
    totalPlayers?: SortOrder
    winnersCount?: SortOrder
    totalWagered?: SortOrder
    totalPayouts?: SortOrder
    nonce?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CrashRoundRelationFilter = {
    is?: CrashRoundWhereInput
    isNot?: CrashRoundWhereInput
  }

  export type CrashBetCountOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    exitMultiplier?: SortOrder
    winnings?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CrashBetAvgOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    exitMultiplier?: SortOrder
    winnings?: SortOrder
  }

  export type CrashBetMaxOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    exitMultiplier?: SortOrder
    winnings?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CrashBetMinOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    exitMultiplier?: SortOrder
    winnings?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type CrashBetSumOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    betAmount?: SortOrder
    exitMultiplier?: SortOrder
    winnings?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CrashBetNullableRelationFilter = {
    is?: CrashBetWhereInput | null
    isNot?: CrashBetWhereInput | null
  }

  export type CrashTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    betId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CrashTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    betId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type CrashTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    betId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CrashTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    betId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CrashTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    betId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
  }

  export type MinesweeperDifficultyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    minesCount?: SortOrder
    gridSize?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
  }

  export type MinesweeperDifficultyAvgOrderByAggregateInput = {
    id?: SortOrder
    minesCount?: SortOrder
    gridSize?: SortOrder
    multiplier?: SortOrder
  }

  export type MinesweeperDifficultyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    minesCount?: SortOrder
    gridSize?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
  }

  export type MinesweeperDifficultyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    minesCount?: SortOrder
    gridSize?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
  }

  export type MinesweeperDifficultySumOrderByAggregateInput = {
    id?: SortOrder
    minesCount?: SortOrder
    gridSize?: SortOrder
    multiplier?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MinesweeperDifficultyRelationFilter = {
    is?: MinesweeperDifficultyWhereInput
    isNot?: MinesweeperDifficultyWhereInput
  }

  export type MinesweeperGameCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    difficultyId?: SortOrder
    gameState?: SortOrder
    minesPositions?: SortOrder
    status?: SortOrder
    revealedCells?: SortOrder
    flaggedCells?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MinesweeperGameAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    difficultyId?: SortOrder
    revealedCells?: SortOrder
    flaggedCells?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    multiplier?: SortOrder
  }

  export type MinesweeperGameMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    revealedCells?: SortOrder
    flaggedCells?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MinesweeperGameMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    difficultyId?: SortOrder
    status?: SortOrder
    revealedCells?: SortOrder
    flaggedCells?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MinesweeperGameSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    difficultyId?: SortOrder
    revealedCells?: SortOrder
    flaggedCells?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    multiplier?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type MinesweeperBetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameId?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    result?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
  }

  export type MinesweeperBetAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameId?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    multiplier?: SortOrder
  }

  export type MinesweeperBetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameId?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    result?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
  }

  export type MinesweeperBetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameId?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    result?: SortOrder
    multiplier?: SortOrder
    createdAt?: SortOrder
  }

  export type MinesweeperBetSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenId?: SortOrder
    gameId?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    multiplier?: SortOrder
  }

  export type CrashBetCreateNestedManyWithoutTokenInput = {
    create?: XOR<CrashBetCreateWithoutTokenInput, CrashBetUncheckedCreateWithoutTokenInput> | CrashBetCreateWithoutTokenInput[] | CrashBetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutTokenInput | CrashBetCreateOrConnectWithoutTokenInput[]
    createMany?: CrashBetCreateManyTokenInputEnvelope
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
  }

  export type CrashTransactionCreateNestedManyWithoutTokenInput = {
    create?: XOR<CrashTransactionCreateWithoutTokenInput, CrashTransactionUncheckedCreateWithoutTokenInput> | CrashTransactionCreateWithoutTokenInput[] | CrashTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutTokenInput | CrashTransactionCreateOrConnectWithoutTokenInput[]
    createMany?: CrashTransactionCreateManyTokenInputEnvelope
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
  }

  export type MinesweeperGameCreateNestedManyWithoutTokenInput = {
    create?: XOR<MinesweeperGameCreateWithoutTokenInput, MinesweeperGameUncheckedCreateWithoutTokenInput> | MinesweeperGameCreateWithoutTokenInput[] | MinesweeperGameUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutTokenInput | MinesweeperGameCreateOrConnectWithoutTokenInput[]
    createMany?: MinesweeperGameCreateManyTokenInputEnvelope
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
  }

  export type MinesweeperBetCreateNestedManyWithoutTokenInput = {
    create?: XOR<MinesweeperBetCreateWithoutTokenInput, MinesweeperBetUncheckedCreateWithoutTokenInput> | MinesweeperBetCreateWithoutTokenInput[] | MinesweeperBetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MinesweeperBetCreateOrConnectWithoutTokenInput | MinesweeperBetCreateOrConnectWithoutTokenInput[]
    createMany?: MinesweeperBetCreateManyTokenInputEnvelope
    connect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
  }

  export type BalanceCreateNestedManyWithoutTokenInput = {
    create?: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput> | BalanceCreateWithoutTokenInput[] | BalanceUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutTokenInput | BalanceCreateOrConnectWithoutTokenInput[]
    createMany?: BalanceCreateManyTokenInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutTokenInput = {
    create?: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput> | TransactionCreateWithoutTokenInput[] | TransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTokenInput | TransactionCreateOrConnectWithoutTokenInput[]
    createMany?: TransactionCreateManyTokenInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BetCreateNestedManyWithoutTokenInput = {
    create?: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput> | BetCreateWithoutTokenInput[] | BetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BetCreateOrConnectWithoutTokenInput | BetCreateOrConnectWithoutTokenInput[]
    createMany?: BetCreateManyTokenInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type LeaderboardEntryCreateNestedManyWithoutTokenInput = {
    create?: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput> | LeaderboardEntryCreateWithoutTokenInput[] | LeaderboardEntryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutTokenInput | LeaderboardEntryCreateOrConnectWithoutTokenInput[]
    createMany?: LeaderboardEntryCreateManyTokenInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type UserBonusCreateNestedManyWithoutTokenInput = {
    create?: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput> | UserBonusCreateWithoutTokenInput[] | UserBonusUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutTokenInput | UserBonusCreateOrConnectWithoutTokenInput[]
    createMany?: UserBonusCreateManyTokenInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type ReferralTransactionCreateNestedManyWithoutTokenInput = {
    create?: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput> | ReferralTransactionCreateWithoutTokenInput[] | ReferralTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutTokenInput | ReferralTransactionCreateOrConnectWithoutTokenInput[]
    createMany?: ReferralTransactionCreateManyTokenInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type CrashBetUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<CrashBetCreateWithoutTokenInput, CrashBetUncheckedCreateWithoutTokenInput> | CrashBetCreateWithoutTokenInput[] | CrashBetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutTokenInput | CrashBetCreateOrConnectWithoutTokenInput[]
    createMany?: CrashBetCreateManyTokenInputEnvelope
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
  }

  export type CrashTransactionUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<CrashTransactionCreateWithoutTokenInput, CrashTransactionUncheckedCreateWithoutTokenInput> | CrashTransactionCreateWithoutTokenInput[] | CrashTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutTokenInput | CrashTransactionCreateOrConnectWithoutTokenInput[]
    createMany?: CrashTransactionCreateManyTokenInputEnvelope
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
  }

  export type MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<MinesweeperGameCreateWithoutTokenInput, MinesweeperGameUncheckedCreateWithoutTokenInput> | MinesweeperGameCreateWithoutTokenInput[] | MinesweeperGameUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutTokenInput | MinesweeperGameCreateOrConnectWithoutTokenInput[]
    createMany?: MinesweeperGameCreateManyTokenInputEnvelope
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
  }

  export type MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<MinesweeperBetCreateWithoutTokenInput, MinesweeperBetUncheckedCreateWithoutTokenInput> | MinesweeperBetCreateWithoutTokenInput[] | MinesweeperBetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MinesweeperBetCreateOrConnectWithoutTokenInput | MinesweeperBetCreateOrConnectWithoutTokenInput[]
    createMany?: MinesweeperBetCreateManyTokenInputEnvelope
    connect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
  }

  export type BalanceUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput> | BalanceCreateWithoutTokenInput[] | BalanceUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutTokenInput | BalanceCreateOrConnectWithoutTokenInput[]
    createMany?: BalanceCreateManyTokenInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput> | TransactionCreateWithoutTokenInput[] | TransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTokenInput | TransactionCreateOrConnectWithoutTokenInput[]
    createMany?: TransactionCreateManyTokenInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BetUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput> | BetCreateWithoutTokenInput[] | BetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BetCreateOrConnectWithoutTokenInput | BetCreateOrConnectWithoutTokenInput[]
    createMany?: BetCreateManyTokenInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput> | LeaderboardEntryCreateWithoutTokenInput[] | LeaderboardEntryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutTokenInput | LeaderboardEntryCreateOrConnectWithoutTokenInput[]
    createMany?: LeaderboardEntryCreateManyTokenInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type UserBonusUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput> | UserBonusCreateWithoutTokenInput[] | UserBonusUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutTokenInput | UserBonusCreateOrConnectWithoutTokenInput[]
    createMany?: UserBonusCreateManyTokenInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput> | ReferralTransactionCreateWithoutTokenInput[] | ReferralTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutTokenInput | ReferralTransactionCreateOrConnectWithoutTokenInput[]
    createMany?: ReferralTransactionCreateManyTokenInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CrashBetUpdateManyWithoutTokenNestedInput = {
    create?: XOR<CrashBetCreateWithoutTokenInput, CrashBetUncheckedCreateWithoutTokenInput> | CrashBetCreateWithoutTokenInput[] | CrashBetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutTokenInput | CrashBetCreateOrConnectWithoutTokenInput[]
    upsert?: CrashBetUpsertWithWhereUniqueWithoutTokenInput | CrashBetUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: CrashBetCreateManyTokenInputEnvelope
    set?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    disconnect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    delete?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    update?: CrashBetUpdateWithWhereUniqueWithoutTokenInput | CrashBetUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: CrashBetUpdateManyWithWhereWithoutTokenInput | CrashBetUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: CrashBetScalarWhereInput | CrashBetScalarWhereInput[]
  }

  export type CrashTransactionUpdateManyWithoutTokenNestedInput = {
    create?: XOR<CrashTransactionCreateWithoutTokenInput, CrashTransactionUncheckedCreateWithoutTokenInput> | CrashTransactionCreateWithoutTokenInput[] | CrashTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutTokenInput | CrashTransactionCreateOrConnectWithoutTokenInput[]
    upsert?: CrashTransactionUpsertWithWhereUniqueWithoutTokenInput | CrashTransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: CrashTransactionCreateManyTokenInputEnvelope
    set?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    disconnect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    delete?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    update?: CrashTransactionUpdateWithWhereUniqueWithoutTokenInput | CrashTransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: CrashTransactionUpdateManyWithWhereWithoutTokenInput | CrashTransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: CrashTransactionScalarWhereInput | CrashTransactionScalarWhereInput[]
  }

  export type MinesweeperGameUpdateManyWithoutTokenNestedInput = {
    create?: XOR<MinesweeperGameCreateWithoutTokenInput, MinesweeperGameUncheckedCreateWithoutTokenInput> | MinesweeperGameCreateWithoutTokenInput[] | MinesweeperGameUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutTokenInput | MinesweeperGameCreateOrConnectWithoutTokenInput[]
    upsert?: MinesweeperGameUpsertWithWhereUniqueWithoutTokenInput | MinesweeperGameUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: MinesweeperGameCreateManyTokenInputEnvelope
    set?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    disconnect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    delete?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    update?: MinesweeperGameUpdateWithWhereUniqueWithoutTokenInput | MinesweeperGameUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: MinesweeperGameUpdateManyWithWhereWithoutTokenInput | MinesweeperGameUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: MinesweeperGameScalarWhereInput | MinesweeperGameScalarWhereInput[]
  }

  export type MinesweeperBetUpdateManyWithoutTokenNestedInput = {
    create?: XOR<MinesweeperBetCreateWithoutTokenInput, MinesweeperBetUncheckedCreateWithoutTokenInput> | MinesweeperBetCreateWithoutTokenInput[] | MinesweeperBetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MinesweeperBetCreateOrConnectWithoutTokenInput | MinesweeperBetCreateOrConnectWithoutTokenInput[]
    upsert?: MinesweeperBetUpsertWithWhereUniqueWithoutTokenInput | MinesweeperBetUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: MinesweeperBetCreateManyTokenInputEnvelope
    set?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    disconnect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    delete?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    connect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    update?: MinesweeperBetUpdateWithWhereUniqueWithoutTokenInput | MinesweeperBetUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: MinesweeperBetUpdateManyWithWhereWithoutTokenInput | MinesweeperBetUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: MinesweeperBetScalarWhereInput | MinesweeperBetScalarWhereInput[]
  }

  export type BalanceUpdateManyWithoutTokenNestedInput = {
    create?: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput> | BalanceCreateWithoutTokenInput[] | BalanceUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutTokenInput | BalanceCreateOrConnectWithoutTokenInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutTokenInput | BalanceUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: BalanceCreateManyTokenInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutTokenInput | BalanceUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutTokenInput | BalanceUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput> | TransactionCreateWithoutTokenInput[] | TransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTokenInput | TransactionCreateOrConnectWithoutTokenInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTokenInput | TransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TransactionCreateManyTokenInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTokenInput | TransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTokenInput | TransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BetUpdateManyWithoutTokenNestedInput = {
    create?: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput> | BetCreateWithoutTokenInput[] | BetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BetCreateOrConnectWithoutTokenInput | BetCreateOrConnectWithoutTokenInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutTokenInput | BetUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: BetCreateManyTokenInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutTokenInput | BetUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: BetUpdateManyWithWhereWithoutTokenInput | BetUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type LeaderboardEntryUpdateManyWithoutTokenNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput> | LeaderboardEntryCreateWithoutTokenInput[] | LeaderboardEntryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutTokenInput | LeaderboardEntryCreateOrConnectWithoutTokenInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput | LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: LeaderboardEntryCreateManyTokenInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput | LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutTokenInput | LeaderboardEntryUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type UserBonusUpdateManyWithoutTokenNestedInput = {
    create?: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput> | UserBonusCreateWithoutTokenInput[] | UserBonusUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutTokenInput | UserBonusCreateOrConnectWithoutTokenInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutTokenInput | UserBonusUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: UserBonusCreateManyTokenInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutTokenInput | UserBonusUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutTokenInput | UserBonusUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type ReferralTransactionUpdateManyWithoutTokenNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput> | ReferralTransactionCreateWithoutTokenInput[] | ReferralTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutTokenInput | ReferralTransactionCreateOrConnectWithoutTokenInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput | ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: ReferralTransactionCreateManyTokenInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput | ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutTokenInput | ReferralTransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type CrashBetUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<CrashBetCreateWithoutTokenInput, CrashBetUncheckedCreateWithoutTokenInput> | CrashBetCreateWithoutTokenInput[] | CrashBetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutTokenInput | CrashBetCreateOrConnectWithoutTokenInput[]
    upsert?: CrashBetUpsertWithWhereUniqueWithoutTokenInput | CrashBetUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: CrashBetCreateManyTokenInputEnvelope
    set?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    disconnect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    delete?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    update?: CrashBetUpdateWithWhereUniqueWithoutTokenInput | CrashBetUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: CrashBetUpdateManyWithWhereWithoutTokenInput | CrashBetUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: CrashBetScalarWhereInput | CrashBetScalarWhereInput[]
  }

  export type CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<CrashTransactionCreateWithoutTokenInput, CrashTransactionUncheckedCreateWithoutTokenInput> | CrashTransactionCreateWithoutTokenInput[] | CrashTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutTokenInput | CrashTransactionCreateOrConnectWithoutTokenInput[]
    upsert?: CrashTransactionUpsertWithWhereUniqueWithoutTokenInput | CrashTransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: CrashTransactionCreateManyTokenInputEnvelope
    set?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    disconnect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    delete?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    update?: CrashTransactionUpdateWithWhereUniqueWithoutTokenInput | CrashTransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: CrashTransactionUpdateManyWithWhereWithoutTokenInput | CrashTransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: CrashTransactionScalarWhereInput | CrashTransactionScalarWhereInput[]
  }

  export type MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<MinesweeperGameCreateWithoutTokenInput, MinesweeperGameUncheckedCreateWithoutTokenInput> | MinesweeperGameCreateWithoutTokenInput[] | MinesweeperGameUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutTokenInput | MinesweeperGameCreateOrConnectWithoutTokenInput[]
    upsert?: MinesweeperGameUpsertWithWhereUniqueWithoutTokenInput | MinesweeperGameUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: MinesweeperGameCreateManyTokenInputEnvelope
    set?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    disconnect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    delete?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    update?: MinesweeperGameUpdateWithWhereUniqueWithoutTokenInput | MinesweeperGameUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: MinesweeperGameUpdateManyWithWhereWithoutTokenInput | MinesweeperGameUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: MinesweeperGameScalarWhereInput | MinesweeperGameScalarWhereInput[]
  }

  export type MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<MinesweeperBetCreateWithoutTokenInput, MinesweeperBetUncheckedCreateWithoutTokenInput> | MinesweeperBetCreateWithoutTokenInput[] | MinesweeperBetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MinesweeperBetCreateOrConnectWithoutTokenInput | MinesweeperBetCreateOrConnectWithoutTokenInput[]
    upsert?: MinesweeperBetUpsertWithWhereUniqueWithoutTokenInput | MinesweeperBetUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: MinesweeperBetCreateManyTokenInputEnvelope
    set?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    disconnect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    delete?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    connect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    update?: MinesweeperBetUpdateWithWhereUniqueWithoutTokenInput | MinesweeperBetUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: MinesweeperBetUpdateManyWithWhereWithoutTokenInput | MinesweeperBetUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: MinesweeperBetScalarWhereInput | MinesweeperBetScalarWhereInput[]
  }

  export type BalanceUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput> | BalanceCreateWithoutTokenInput[] | BalanceUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutTokenInput | BalanceCreateOrConnectWithoutTokenInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutTokenInput | BalanceUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: BalanceCreateManyTokenInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutTokenInput | BalanceUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutTokenInput | BalanceUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput> | TransactionCreateWithoutTokenInput[] | TransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTokenInput | TransactionCreateOrConnectWithoutTokenInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTokenInput | TransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: TransactionCreateManyTokenInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTokenInput | TransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTokenInput | TransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BetUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput> | BetCreateWithoutTokenInput[] | BetUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: BetCreateOrConnectWithoutTokenInput | BetCreateOrConnectWithoutTokenInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutTokenInput | BetUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: BetCreateManyTokenInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutTokenInput | BetUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: BetUpdateManyWithWhereWithoutTokenInput | BetUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput> | LeaderboardEntryCreateWithoutTokenInput[] | LeaderboardEntryUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutTokenInput | LeaderboardEntryCreateOrConnectWithoutTokenInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput | LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: LeaderboardEntryCreateManyTokenInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput | LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutTokenInput | LeaderboardEntryUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type UserBonusUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput> | UserBonusCreateWithoutTokenInput[] | UserBonusUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutTokenInput | UserBonusCreateOrConnectWithoutTokenInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutTokenInput | UserBonusUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: UserBonusCreateManyTokenInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutTokenInput | UserBonusUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutTokenInput | UserBonusUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput> | ReferralTransactionCreateWithoutTokenInput[] | ReferralTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutTokenInput | ReferralTransactionCreateOrConnectWithoutTokenInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput | ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: ReferralTransactionCreateManyTokenInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput | ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutTokenInput | ReferralTransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReferrerInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CrashBetCreateNestedManyWithoutUserInput = {
    create?: XOR<CrashBetCreateWithoutUserInput, CrashBetUncheckedCreateWithoutUserInput> | CrashBetCreateWithoutUserInput[] | CrashBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutUserInput | CrashBetCreateOrConnectWithoutUserInput[]
    createMany?: CrashBetCreateManyUserInputEnvelope
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
  }

  export type CrashTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<CrashTransactionCreateWithoutUserInput, CrashTransactionUncheckedCreateWithoutUserInput> | CrashTransactionCreateWithoutUserInput[] | CrashTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutUserInput | CrashTransactionCreateOrConnectWithoutUserInput[]
    createMany?: CrashTransactionCreateManyUserInputEnvelope
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
  }

  export type MinesweeperGameCreateNestedManyWithoutUserInput = {
    create?: XOR<MinesweeperGameCreateWithoutUserInput, MinesweeperGameUncheckedCreateWithoutUserInput> | MinesweeperGameCreateWithoutUserInput[] | MinesweeperGameUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutUserInput | MinesweeperGameCreateOrConnectWithoutUserInput[]
    createMany?: MinesweeperGameCreateManyUserInputEnvelope
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
  }

  export type MinesweeperBetCreateNestedManyWithoutUserInput = {
    create?: XOR<MinesweeperBetCreateWithoutUserInput, MinesweeperBetUncheckedCreateWithoutUserInput> | MinesweeperBetCreateWithoutUserInput[] | MinesweeperBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinesweeperBetCreateOrConnectWithoutUserInput | MinesweeperBetCreateOrConnectWithoutUserInput[]
    createMany?: MinesweeperBetCreateManyUserInputEnvelope
    connect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
  }

  export type BalanceCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BetCreateNestedManyWithoutUserInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type LeaderboardEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type UserBonusCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type ReferralTransactionCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput> | ReferralTransactionCreateWithoutReferrerInput[] | ReferralTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutReferrerInput | ReferralTransactionCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralTransactionCreateManyReferrerInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type ReferralTransactionCreateNestedManyWithoutRefereeInput = {
    create?: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput> | ReferralTransactionCreateWithoutRefereeInput[] | ReferralTransactionUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutRefereeInput | ReferralTransactionCreateOrConnectWithoutRefereeInput[]
    createMany?: ReferralTransactionCreateManyRefereeInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type OneTimeTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput> | OneTimeTokenCreateWithoutUserInput[] | OneTimeTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneTimeTokenCreateOrConnectWithoutUserInput | OneTimeTokenCreateOrConnectWithoutUserInput[]
    createMany?: OneTimeTokenCreateManyUserInputEnvelope
    connect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CrashBetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CrashBetCreateWithoutUserInput, CrashBetUncheckedCreateWithoutUserInput> | CrashBetCreateWithoutUserInput[] | CrashBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutUserInput | CrashBetCreateOrConnectWithoutUserInput[]
    createMany?: CrashBetCreateManyUserInputEnvelope
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
  }

  export type CrashTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CrashTransactionCreateWithoutUserInput, CrashTransactionUncheckedCreateWithoutUserInput> | CrashTransactionCreateWithoutUserInput[] | CrashTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutUserInput | CrashTransactionCreateOrConnectWithoutUserInput[]
    createMany?: CrashTransactionCreateManyUserInputEnvelope
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
  }

  export type MinesweeperGameUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MinesweeperGameCreateWithoutUserInput, MinesweeperGameUncheckedCreateWithoutUserInput> | MinesweeperGameCreateWithoutUserInput[] | MinesweeperGameUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutUserInput | MinesweeperGameCreateOrConnectWithoutUserInput[]
    createMany?: MinesweeperGameCreateManyUserInputEnvelope
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
  }

  export type MinesweeperBetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MinesweeperBetCreateWithoutUserInput, MinesweeperBetUncheckedCreateWithoutUserInput> | MinesweeperBetCreateWithoutUserInput[] | MinesweeperBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinesweeperBetCreateOrConnectWithoutUserInput | MinesweeperBetCreateOrConnectWithoutUserInput[]
    createMany?: MinesweeperBetCreateManyUserInputEnvelope
    connect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
  }

  export type BalanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
  }

  export type LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
  }

  export type UserBonusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput> | ReferralTransactionCreateWithoutReferrerInput[] | ReferralTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutReferrerInput | ReferralTransactionCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralTransactionCreateManyReferrerInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput = {
    create?: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput> | ReferralTransactionCreateWithoutRefereeInput[] | ReferralTransactionUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutRefereeInput | ReferralTransactionCreateOrConnectWithoutRefereeInput[]
    createMany?: ReferralTransactionCreateManyRefereeInputEnvelope
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
  }

  export type OneTimeTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput> | OneTimeTokenCreateWithoutUserInput[] | OneTimeTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneTimeTokenCreateOrConnectWithoutUserInput | OneTimeTokenCreateOrConnectWithoutUserInput[]
    createMany?: OneTimeTokenCreateManyUserInputEnvelope
    connect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferrerInput | UserUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferrerInput | UserUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferrerInput | UserUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CrashBetUpdateManyWithoutUserNestedInput = {
    create?: XOR<CrashBetCreateWithoutUserInput, CrashBetUncheckedCreateWithoutUserInput> | CrashBetCreateWithoutUserInput[] | CrashBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutUserInput | CrashBetCreateOrConnectWithoutUserInput[]
    upsert?: CrashBetUpsertWithWhereUniqueWithoutUserInput | CrashBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CrashBetCreateManyUserInputEnvelope
    set?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    disconnect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    delete?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    update?: CrashBetUpdateWithWhereUniqueWithoutUserInput | CrashBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CrashBetUpdateManyWithWhereWithoutUserInput | CrashBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CrashBetScalarWhereInput | CrashBetScalarWhereInput[]
  }

  export type CrashTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CrashTransactionCreateWithoutUserInput, CrashTransactionUncheckedCreateWithoutUserInput> | CrashTransactionCreateWithoutUserInput[] | CrashTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutUserInput | CrashTransactionCreateOrConnectWithoutUserInput[]
    upsert?: CrashTransactionUpsertWithWhereUniqueWithoutUserInput | CrashTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CrashTransactionCreateManyUserInputEnvelope
    set?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    disconnect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    delete?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    update?: CrashTransactionUpdateWithWhereUniqueWithoutUserInput | CrashTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CrashTransactionUpdateManyWithWhereWithoutUserInput | CrashTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CrashTransactionScalarWhereInput | CrashTransactionScalarWhereInput[]
  }

  export type MinesweeperGameUpdateManyWithoutUserNestedInput = {
    create?: XOR<MinesweeperGameCreateWithoutUserInput, MinesweeperGameUncheckedCreateWithoutUserInput> | MinesweeperGameCreateWithoutUserInput[] | MinesweeperGameUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutUserInput | MinesweeperGameCreateOrConnectWithoutUserInput[]
    upsert?: MinesweeperGameUpsertWithWhereUniqueWithoutUserInput | MinesweeperGameUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MinesweeperGameCreateManyUserInputEnvelope
    set?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    disconnect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    delete?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    update?: MinesweeperGameUpdateWithWhereUniqueWithoutUserInput | MinesweeperGameUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MinesweeperGameUpdateManyWithWhereWithoutUserInput | MinesweeperGameUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MinesweeperGameScalarWhereInput | MinesweeperGameScalarWhereInput[]
  }

  export type MinesweeperBetUpdateManyWithoutUserNestedInput = {
    create?: XOR<MinesweeperBetCreateWithoutUserInput, MinesweeperBetUncheckedCreateWithoutUserInput> | MinesweeperBetCreateWithoutUserInput[] | MinesweeperBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinesweeperBetCreateOrConnectWithoutUserInput | MinesweeperBetCreateOrConnectWithoutUserInput[]
    upsert?: MinesweeperBetUpsertWithWhereUniqueWithoutUserInput | MinesweeperBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MinesweeperBetCreateManyUserInputEnvelope
    set?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    disconnect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    delete?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    connect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    update?: MinesweeperBetUpdateWithWhereUniqueWithoutUserInput | MinesweeperBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MinesweeperBetUpdateManyWithWhereWithoutUserInput | MinesweeperBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MinesweeperBetScalarWhereInput | MinesweeperBetScalarWhereInput[]
  }

  export type BalanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutUserInput | BalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutUserInput | BalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutUserInput | BalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BetUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutUserInput | BetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutUserInput | BetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetUpdateManyWithWhereWithoutUserInput | BetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type LeaderboardEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type UserBonusUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutUserInput | UserBonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutUserInput | UserBonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutUserInput | UserBonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type ReferralTransactionUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput> | ReferralTransactionCreateWithoutReferrerInput[] | ReferralTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutReferrerInput | ReferralTransactionCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput | ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralTransactionCreateManyReferrerInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput | ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutReferrerInput | ReferralTransactionUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type ReferralTransactionUpdateManyWithoutRefereeNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput> | ReferralTransactionCreateWithoutRefereeInput[] | ReferralTransactionUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutRefereeInput | ReferralTransactionCreateOrConnectWithoutRefereeInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput | ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput[]
    createMany?: ReferralTransactionCreateManyRefereeInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput | ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutRefereeInput | ReferralTransactionUpdateManyWithWhereWithoutRefereeInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type OneTimeTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput> | OneTimeTokenCreateWithoutUserInput[] | OneTimeTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneTimeTokenCreateOrConnectWithoutUserInput | OneTimeTokenCreateOrConnectWithoutUserInput[]
    upsert?: OneTimeTokenUpsertWithWhereUniqueWithoutUserInput | OneTimeTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OneTimeTokenCreateManyUserInputEnvelope
    set?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    disconnect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    delete?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    connect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    update?: OneTimeTokenUpdateWithWhereUniqueWithoutUserInput | OneTimeTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OneTimeTokenUpdateManyWithWhereWithoutUserInput | OneTimeTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OneTimeTokenScalarWhereInput | OneTimeTokenScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferrerInput | UserUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferrerInput | UserUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferrerInput | UserUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CrashBetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CrashBetCreateWithoutUserInput, CrashBetUncheckedCreateWithoutUserInput> | CrashBetCreateWithoutUserInput[] | CrashBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutUserInput | CrashBetCreateOrConnectWithoutUserInput[]
    upsert?: CrashBetUpsertWithWhereUniqueWithoutUserInput | CrashBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CrashBetCreateManyUserInputEnvelope
    set?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    disconnect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    delete?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    update?: CrashBetUpdateWithWhereUniqueWithoutUserInput | CrashBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CrashBetUpdateManyWithWhereWithoutUserInput | CrashBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CrashBetScalarWhereInput | CrashBetScalarWhereInput[]
  }

  export type CrashTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CrashTransactionCreateWithoutUserInput, CrashTransactionUncheckedCreateWithoutUserInput> | CrashTransactionCreateWithoutUserInput[] | CrashTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutUserInput | CrashTransactionCreateOrConnectWithoutUserInput[]
    upsert?: CrashTransactionUpsertWithWhereUniqueWithoutUserInput | CrashTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CrashTransactionCreateManyUserInputEnvelope
    set?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    disconnect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    delete?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    update?: CrashTransactionUpdateWithWhereUniqueWithoutUserInput | CrashTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CrashTransactionUpdateManyWithWhereWithoutUserInput | CrashTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CrashTransactionScalarWhereInput | CrashTransactionScalarWhereInput[]
  }

  export type MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MinesweeperGameCreateWithoutUserInput, MinesweeperGameUncheckedCreateWithoutUserInput> | MinesweeperGameCreateWithoutUserInput[] | MinesweeperGameUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutUserInput | MinesweeperGameCreateOrConnectWithoutUserInput[]
    upsert?: MinesweeperGameUpsertWithWhereUniqueWithoutUserInput | MinesweeperGameUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MinesweeperGameCreateManyUserInputEnvelope
    set?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    disconnect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    delete?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    update?: MinesweeperGameUpdateWithWhereUniqueWithoutUserInput | MinesweeperGameUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MinesweeperGameUpdateManyWithWhereWithoutUserInput | MinesweeperGameUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MinesweeperGameScalarWhereInput | MinesweeperGameScalarWhereInput[]
  }

  export type MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MinesweeperBetCreateWithoutUserInput, MinesweeperBetUncheckedCreateWithoutUserInput> | MinesweeperBetCreateWithoutUserInput[] | MinesweeperBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MinesweeperBetCreateOrConnectWithoutUserInput | MinesweeperBetCreateOrConnectWithoutUserInput[]
    upsert?: MinesweeperBetUpsertWithWhereUniqueWithoutUserInput | MinesweeperBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MinesweeperBetCreateManyUserInputEnvelope
    set?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    disconnect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    delete?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    connect?: MinesweeperBetWhereUniqueInput | MinesweeperBetWhereUniqueInput[]
    update?: MinesweeperBetUpdateWithWhereUniqueWithoutUserInput | MinesweeperBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MinesweeperBetUpdateManyWithWhereWithoutUserInput | MinesweeperBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MinesweeperBetScalarWhereInput | MinesweeperBetScalarWhereInput[]
  }

  export type BalanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput> | BalanceCreateWithoutUserInput[] | BalanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutUserInput | BalanceCreateOrConnectWithoutUserInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutUserInput | BalanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceCreateManyUserInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutUserInput | BalanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutUserInput | BalanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput> | BetCreateWithoutUserInput[] | BetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetCreateOrConnectWithoutUserInput | BetCreateOrConnectWithoutUserInput[]
    upsert?: BetUpsertWithWhereUniqueWithoutUserInput | BetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetCreateManyUserInputEnvelope
    set?: BetWhereUniqueInput | BetWhereUniqueInput[]
    disconnect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    delete?: BetWhereUniqueInput | BetWhereUniqueInput[]
    connect?: BetWhereUniqueInput | BetWhereUniqueInput[]
    update?: BetUpdateWithWhereUniqueWithoutUserInput | BetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetUpdateManyWithWhereWithoutUserInput | BetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetScalarWhereInput | BetScalarWhereInput[]
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput> | LeaderboardEntryCreateWithoutUserInput[] | LeaderboardEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardEntryCreateOrConnectWithoutUserInput | LeaderboardEntryCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput | LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardEntryCreateManyUserInputEnvelope
    set?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    disconnect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    delete?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    connect?: LeaderboardEntryWhereUniqueInput | LeaderboardEntryWhereUniqueInput[]
    update?: LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput | LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardEntryUpdateManyWithWhereWithoutUserInput | LeaderboardEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
  }

  export type UserBonusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput> | UserBonusCreateWithoutUserInput[] | UserBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutUserInput | UserBonusCreateOrConnectWithoutUserInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutUserInput | UserBonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBonusCreateManyUserInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutUserInput | UserBonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutUserInput | UserBonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput> | ReferralTransactionCreateWithoutReferrerInput[] | ReferralTransactionUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutReferrerInput | ReferralTransactionCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput | ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralTransactionCreateManyReferrerInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput | ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutReferrerInput | ReferralTransactionUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput = {
    create?: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput> | ReferralTransactionCreateWithoutRefereeInput[] | ReferralTransactionUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralTransactionCreateOrConnectWithoutRefereeInput | ReferralTransactionCreateOrConnectWithoutRefereeInput[]
    upsert?: ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput | ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput[]
    createMany?: ReferralTransactionCreateManyRefereeInputEnvelope
    set?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    disconnect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    delete?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    connect?: ReferralTransactionWhereUniqueInput | ReferralTransactionWhereUniqueInput[]
    update?: ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput | ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput[]
    updateMany?: ReferralTransactionUpdateManyWithWhereWithoutRefereeInput | ReferralTransactionUpdateManyWithWhereWithoutRefereeInput[]
    deleteMany?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
  }

  export type OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput> | OneTimeTokenCreateWithoutUserInput[] | OneTimeTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OneTimeTokenCreateOrConnectWithoutUserInput | OneTimeTokenCreateOrConnectWithoutUserInput[]
    upsert?: OneTimeTokenUpsertWithWhereUniqueWithoutUserInput | OneTimeTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OneTimeTokenCreateManyUserInputEnvelope
    set?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    disconnect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    delete?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    connect?: OneTimeTokenWhereUniqueInput | OneTimeTokenWhereUniqueInput[]
    update?: OneTimeTokenUpdateWithWhereUniqueWithoutUserInput | OneTimeTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OneTimeTokenUpdateManyWithWhereWithoutUserInput | OneTimeTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OneTimeTokenScalarWhereInput | OneTimeTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBalancesInput = {
    create?: XOR<UserCreateWithoutBalancesInput, UserUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalancesInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutBalancesInput = {
    create?: XOR<CryptoTokenCreateWithoutBalancesInput, CryptoTokenUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutBalancesInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type EnumBalanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.BalanceType
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<UserCreateWithoutBalancesInput, UserUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalancesInput
    upsert?: UserUpsertWithoutBalancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBalancesInput, UserUpdateWithoutBalancesInput>, UserUncheckedUpdateWithoutBalancesInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutBalancesInput, CryptoTokenUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutBalancesInput
    upsert?: CryptoTokenUpsertWithoutBalancesInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutBalancesInput, CryptoTokenUpdateWithoutBalancesInput>, CryptoTokenUncheckedUpdateWithoutBalancesInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CryptoTokenCreateWithoutTransactionsInput, CryptoTokenUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutTransactionsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutTransactionsInput, CryptoTokenUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutTransactionsInput
    upsert?: CryptoTokenUpsertWithoutTransactionsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutTransactionsInput, CryptoTokenUpdateWithoutTransactionsInput>, CryptoTokenUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutBetsInput = {
    create?: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBetsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutBetsInput = {
    create?: XOR<CryptoTokenCreateWithoutBetsInput, CryptoTokenUncheckedCreateWithoutBetsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutBetsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type EnumGameTypeFieldUpdateOperationsInput = {
    set?: $Enums.GameType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBetsNestedInput = {
    create?: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBetsInput
    upsert?: UserUpsertWithoutBetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBetsInput, UserUpdateWithoutBetsInput>, UserUncheckedUpdateWithoutBetsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutBetsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutBetsInput, CryptoTokenUncheckedCreateWithoutBetsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutBetsInput
    upsert?: CryptoTokenUpsertWithoutBetsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutBetsInput, CryptoTokenUpdateWithoutBetsInput>, CryptoTokenUncheckedUpdateWithoutBetsInput>
  }

  export type UserBonusCreateNestedManyWithoutBonusInput = {
    create?: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput> | UserBonusCreateWithoutBonusInput[] | UserBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutBonusInput | UserBonusCreateOrConnectWithoutBonusInput[]
    createMany?: UserBonusCreateManyBonusInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type UserBonusUncheckedCreateNestedManyWithoutBonusInput = {
    create?: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput> | UserBonusCreateWithoutBonusInput[] | UserBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutBonusInput | UserBonusCreateOrConnectWithoutBonusInput[]
    createMany?: UserBonusCreateManyBonusInputEnvelope
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
  }

  export type UserBonusUpdateManyWithoutBonusNestedInput = {
    create?: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput> | UserBonusCreateWithoutBonusInput[] | UserBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutBonusInput | UserBonusCreateOrConnectWithoutBonusInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutBonusInput | UserBonusUpsertWithWhereUniqueWithoutBonusInput[]
    createMany?: UserBonusCreateManyBonusInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutBonusInput | UserBonusUpdateWithWhereUniqueWithoutBonusInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutBonusInput | UserBonusUpdateManyWithWhereWithoutBonusInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type UserBonusUncheckedUpdateManyWithoutBonusNestedInput = {
    create?: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput> | UserBonusCreateWithoutBonusInput[] | UserBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: UserBonusCreateOrConnectWithoutBonusInput | UserBonusCreateOrConnectWithoutBonusInput[]
    upsert?: UserBonusUpsertWithWhereUniqueWithoutBonusInput | UserBonusUpsertWithWhereUniqueWithoutBonusInput[]
    createMany?: UserBonusCreateManyBonusInputEnvelope
    set?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    disconnect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    delete?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    connect?: UserBonusWhereUniqueInput | UserBonusWhereUniqueInput[]
    update?: UserBonusUpdateWithWhereUniqueWithoutBonusInput | UserBonusUpdateWithWhereUniqueWithoutBonusInput[]
    updateMany?: UserBonusUpdateManyWithWhereWithoutBonusInput | UserBonusUpdateManyWithWhereWithoutBonusInput[]
    deleteMany?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBonusesInput = {
    create?: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusesInput
    connect?: UserWhereUniqueInput
  }

  export type BonusCreateNestedOneWithoutUserBonusesInput = {
    create?: XOR<BonusCreateWithoutUserBonusesInput, BonusUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: BonusCreateOrConnectWithoutUserBonusesInput
    connect?: BonusWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutUserBonusesInput = {
    create?: XOR<CryptoTokenCreateWithoutUserBonusesInput, CryptoTokenUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutUserBonusesInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutBonusesNestedInput = {
    create?: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBonusesInput
    upsert?: UserUpsertWithoutBonusesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBonusesInput, UserUpdateWithoutBonusesInput>, UserUncheckedUpdateWithoutBonusesInput>
  }

  export type BonusUpdateOneRequiredWithoutUserBonusesNestedInput = {
    create?: XOR<BonusCreateWithoutUserBonusesInput, BonusUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: BonusCreateOrConnectWithoutUserBonusesInput
    upsert?: BonusUpsertWithoutUserBonusesInput
    connect?: BonusWhereUniqueInput
    update?: XOR<XOR<BonusUpdateToOneWithWhereWithoutUserBonusesInput, BonusUpdateWithoutUserBonusesInput>, BonusUncheckedUpdateWithoutUserBonusesInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutUserBonusesNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutUserBonusesInput, CryptoTokenUncheckedCreateWithoutUserBonusesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutUserBonusesInput
    upsert?: CryptoTokenUpsertWithoutUserBonusesInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutUserBonusesInput, CryptoTokenUpdateWithoutUserBonusesInput>, CryptoTokenUncheckedUpdateWithoutUserBonusesInput>
  }

  export type UserCreateNestedOneWithoutLeaderboardEntriesInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutLeaderboardInput = {
    create?: XOR<CryptoTokenCreateWithoutLeaderboardInput, CryptoTokenUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutLeaderboardInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    upsert?: UserUpsertWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput, UserUpdateWithoutLeaderboardEntriesInput>, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type CryptoTokenUpdateOneWithoutLeaderboardNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutLeaderboardInput, CryptoTokenUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutLeaderboardInput
    upsert?: CryptoTokenUpsertWithoutLeaderboardInput
    disconnect?: CryptoTokenWhereInput | boolean
    delete?: CryptoTokenWhereInput | boolean
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutLeaderboardInput, CryptoTokenUpdateWithoutLeaderboardInput>, CryptoTokenUncheckedUpdateWithoutLeaderboardInput>
  }

  export type UserCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommissionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralActionsInput = {
    create?: XOR<UserCreateWithoutReferralActionsInput, UserUncheckedCreateWithoutReferralActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralActionsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutReferralCommissionsInput = {
    create?: XOR<CryptoTokenCreateWithoutReferralCommissionsInput, CryptoTokenUncheckedCreateWithoutReferralCommissionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutReferralCommissionsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type EnumReferralEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReferralEventType
  }

  export type UserUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommissionsInput
    upsert?: UserUpsertWithoutCommissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommissionsInput, UserUpdateWithoutCommissionsInput>, UserUncheckedUpdateWithoutCommissionsInput>
  }

  export type UserUpdateOneRequiredWithoutReferralActionsNestedInput = {
    create?: XOR<UserCreateWithoutReferralActionsInput, UserUncheckedCreateWithoutReferralActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralActionsInput
    upsert?: UserUpsertWithoutReferralActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralActionsInput, UserUpdateWithoutReferralActionsInput>, UserUncheckedUpdateWithoutReferralActionsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutReferralCommissionsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutReferralCommissionsInput, CryptoTokenUncheckedCreateWithoutReferralCommissionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutReferralCommissionsInput
    upsert?: CryptoTokenUpsertWithoutReferralCommissionsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutReferralCommissionsInput, CryptoTokenUpdateWithoutReferralCommissionsInput>, CryptoTokenUncheckedUpdateWithoutReferralCommissionsInput>
  }

  export type UserCreateNestedOneWithoutAuthTokensInput = {
    create?: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthTokensNestedInput = {
    create?: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthTokensInput
    upsert?: UserUpsertWithoutAuthTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthTokensInput, UserUpdateWithoutAuthTokensInput>, UserUncheckedUpdateWithoutAuthTokensInput>
  }

  export type CrashBetCreateNestedManyWithoutRoundInput = {
    create?: XOR<CrashBetCreateWithoutRoundInput, CrashBetUncheckedCreateWithoutRoundInput> | CrashBetCreateWithoutRoundInput[] | CrashBetUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutRoundInput | CrashBetCreateOrConnectWithoutRoundInput[]
    createMany?: CrashBetCreateManyRoundInputEnvelope
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
  }

  export type CrashBetUncheckedCreateNestedManyWithoutRoundInput = {
    create?: XOR<CrashBetCreateWithoutRoundInput, CrashBetUncheckedCreateWithoutRoundInput> | CrashBetCreateWithoutRoundInput[] | CrashBetUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutRoundInput | CrashBetCreateOrConnectWithoutRoundInput[]
    createMany?: CrashBetCreateManyRoundInputEnvelope
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
  }

  export type CrashBetUpdateManyWithoutRoundNestedInput = {
    create?: XOR<CrashBetCreateWithoutRoundInput, CrashBetUncheckedCreateWithoutRoundInput> | CrashBetCreateWithoutRoundInput[] | CrashBetUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutRoundInput | CrashBetCreateOrConnectWithoutRoundInput[]
    upsert?: CrashBetUpsertWithWhereUniqueWithoutRoundInput | CrashBetUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: CrashBetCreateManyRoundInputEnvelope
    set?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    disconnect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    delete?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    update?: CrashBetUpdateWithWhereUniqueWithoutRoundInput | CrashBetUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: CrashBetUpdateManyWithWhereWithoutRoundInput | CrashBetUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: CrashBetScalarWhereInput | CrashBetScalarWhereInput[]
  }

  export type CrashBetUncheckedUpdateManyWithoutRoundNestedInput = {
    create?: XOR<CrashBetCreateWithoutRoundInput, CrashBetUncheckedCreateWithoutRoundInput> | CrashBetCreateWithoutRoundInput[] | CrashBetUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: CrashBetCreateOrConnectWithoutRoundInput | CrashBetCreateOrConnectWithoutRoundInput[]
    upsert?: CrashBetUpsertWithWhereUniqueWithoutRoundInput | CrashBetUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: CrashBetCreateManyRoundInputEnvelope
    set?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    disconnect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    delete?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    connect?: CrashBetWhereUniqueInput | CrashBetWhereUniqueInput[]
    update?: CrashBetUpdateWithWhereUniqueWithoutRoundInput | CrashBetUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: CrashBetUpdateManyWithWhereWithoutRoundInput | CrashBetUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: CrashBetScalarWhereInput | CrashBetScalarWhereInput[]
  }

  export type CrashRoundCreateNestedOneWithoutBetsInput = {
    create?: XOR<CrashRoundCreateWithoutBetsInput, CrashRoundUncheckedCreateWithoutBetsInput>
    connectOrCreate?: CrashRoundCreateOrConnectWithoutBetsInput
    connect?: CrashRoundWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCrashBetsInput = {
    create?: XOR<UserCreateWithoutCrashBetsInput, UserUncheckedCreateWithoutCrashBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrashBetsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutCrashBetsInput = {
    create?: XOR<CryptoTokenCreateWithoutCrashBetsInput, CryptoTokenUncheckedCreateWithoutCrashBetsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutCrashBetsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type CrashTransactionCreateNestedManyWithoutBetInput = {
    create?: XOR<CrashTransactionCreateWithoutBetInput, CrashTransactionUncheckedCreateWithoutBetInput> | CrashTransactionCreateWithoutBetInput[] | CrashTransactionUncheckedCreateWithoutBetInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutBetInput | CrashTransactionCreateOrConnectWithoutBetInput[]
    createMany?: CrashTransactionCreateManyBetInputEnvelope
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
  }

  export type CrashTransactionUncheckedCreateNestedManyWithoutBetInput = {
    create?: XOR<CrashTransactionCreateWithoutBetInput, CrashTransactionUncheckedCreateWithoutBetInput> | CrashTransactionCreateWithoutBetInput[] | CrashTransactionUncheckedCreateWithoutBetInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutBetInput | CrashTransactionCreateOrConnectWithoutBetInput[]
    createMany?: CrashTransactionCreateManyBetInputEnvelope
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CrashRoundUpdateOneRequiredWithoutBetsNestedInput = {
    create?: XOR<CrashRoundCreateWithoutBetsInput, CrashRoundUncheckedCreateWithoutBetsInput>
    connectOrCreate?: CrashRoundCreateOrConnectWithoutBetsInput
    upsert?: CrashRoundUpsertWithoutBetsInput
    connect?: CrashRoundWhereUniqueInput
    update?: XOR<XOR<CrashRoundUpdateToOneWithWhereWithoutBetsInput, CrashRoundUpdateWithoutBetsInput>, CrashRoundUncheckedUpdateWithoutBetsInput>
  }

  export type UserUpdateOneRequiredWithoutCrashBetsNestedInput = {
    create?: XOR<UserCreateWithoutCrashBetsInput, UserUncheckedCreateWithoutCrashBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrashBetsInput
    upsert?: UserUpsertWithoutCrashBetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCrashBetsInput, UserUpdateWithoutCrashBetsInput>, UserUncheckedUpdateWithoutCrashBetsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutCrashBetsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutCrashBetsInput, CryptoTokenUncheckedCreateWithoutCrashBetsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutCrashBetsInput
    upsert?: CryptoTokenUpsertWithoutCrashBetsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutCrashBetsInput, CryptoTokenUpdateWithoutCrashBetsInput>, CryptoTokenUncheckedUpdateWithoutCrashBetsInput>
  }

  export type CrashTransactionUpdateManyWithoutBetNestedInput = {
    create?: XOR<CrashTransactionCreateWithoutBetInput, CrashTransactionUncheckedCreateWithoutBetInput> | CrashTransactionCreateWithoutBetInput[] | CrashTransactionUncheckedCreateWithoutBetInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutBetInput | CrashTransactionCreateOrConnectWithoutBetInput[]
    upsert?: CrashTransactionUpsertWithWhereUniqueWithoutBetInput | CrashTransactionUpsertWithWhereUniqueWithoutBetInput[]
    createMany?: CrashTransactionCreateManyBetInputEnvelope
    set?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    disconnect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    delete?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    update?: CrashTransactionUpdateWithWhereUniqueWithoutBetInput | CrashTransactionUpdateWithWhereUniqueWithoutBetInput[]
    updateMany?: CrashTransactionUpdateManyWithWhereWithoutBetInput | CrashTransactionUpdateManyWithWhereWithoutBetInput[]
    deleteMany?: CrashTransactionScalarWhereInput | CrashTransactionScalarWhereInput[]
  }

  export type CrashTransactionUncheckedUpdateManyWithoutBetNestedInput = {
    create?: XOR<CrashTransactionCreateWithoutBetInput, CrashTransactionUncheckedCreateWithoutBetInput> | CrashTransactionCreateWithoutBetInput[] | CrashTransactionUncheckedCreateWithoutBetInput[]
    connectOrCreate?: CrashTransactionCreateOrConnectWithoutBetInput | CrashTransactionCreateOrConnectWithoutBetInput[]
    upsert?: CrashTransactionUpsertWithWhereUniqueWithoutBetInput | CrashTransactionUpsertWithWhereUniqueWithoutBetInput[]
    createMany?: CrashTransactionCreateManyBetInputEnvelope
    set?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    disconnect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    delete?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    connect?: CrashTransactionWhereUniqueInput | CrashTransactionWhereUniqueInput[]
    update?: CrashTransactionUpdateWithWhereUniqueWithoutBetInput | CrashTransactionUpdateWithWhereUniqueWithoutBetInput[]
    updateMany?: CrashTransactionUpdateManyWithWhereWithoutBetInput | CrashTransactionUpdateManyWithWhereWithoutBetInput[]
    deleteMany?: CrashTransactionScalarWhereInput | CrashTransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCrashTransactionsInput = {
    create?: XOR<UserCreateWithoutCrashTransactionsInput, UserUncheckedCreateWithoutCrashTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrashTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type CrashBetCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CrashBetCreateWithoutTransactionsInput, CrashBetUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CrashBetCreateOrConnectWithoutTransactionsInput
    connect?: CrashBetWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutCrashTransactionsInput = {
    create?: XOR<CryptoTokenCreateWithoutCrashTransactionsInput, CryptoTokenUncheckedCreateWithoutCrashTransactionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutCrashTransactionsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCrashTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCrashTransactionsInput, UserUncheckedCreateWithoutCrashTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCrashTransactionsInput
    upsert?: UserUpsertWithoutCrashTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCrashTransactionsInput, UserUpdateWithoutCrashTransactionsInput>, UserUncheckedUpdateWithoutCrashTransactionsInput>
  }

  export type CrashBetUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CrashBetCreateWithoutTransactionsInput, CrashBetUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CrashBetCreateOrConnectWithoutTransactionsInput
    upsert?: CrashBetUpsertWithoutTransactionsInput
    disconnect?: CrashBetWhereInput | boolean
    delete?: CrashBetWhereInput | boolean
    connect?: CrashBetWhereUniqueInput
    update?: XOR<XOR<CrashBetUpdateToOneWithWhereWithoutTransactionsInput, CrashBetUpdateWithoutTransactionsInput>, CrashBetUncheckedUpdateWithoutTransactionsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutCrashTransactionsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutCrashTransactionsInput, CryptoTokenUncheckedCreateWithoutCrashTransactionsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutCrashTransactionsInput
    upsert?: CryptoTokenUpsertWithoutCrashTransactionsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutCrashTransactionsInput, CryptoTokenUpdateWithoutCrashTransactionsInput>, CryptoTokenUncheckedUpdateWithoutCrashTransactionsInput>
  }

  export type MinesweeperGameCreateNestedManyWithoutDifficultyInput = {
    create?: XOR<MinesweeperGameCreateWithoutDifficultyInput, MinesweeperGameUncheckedCreateWithoutDifficultyInput> | MinesweeperGameCreateWithoutDifficultyInput[] | MinesweeperGameUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutDifficultyInput | MinesweeperGameCreateOrConnectWithoutDifficultyInput[]
    createMany?: MinesweeperGameCreateManyDifficultyInputEnvelope
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
  }

  export type MinesweeperGameUncheckedCreateNestedManyWithoutDifficultyInput = {
    create?: XOR<MinesweeperGameCreateWithoutDifficultyInput, MinesweeperGameUncheckedCreateWithoutDifficultyInput> | MinesweeperGameCreateWithoutDifficultyInput[] | MinesweeperGameUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutDifficultyInput | MinesweeperGameCreateOrConnectWithoutDifficultyInput[]
    createMany?: MinesweeperGameCreateManyDifficultyInputEnvelope
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
  }

  export type MinesweeperGameUpdateManyWithoutDifficultyNestedInput = {
    create?: XOR<MinesweeperGameCreateWithoutDifficultyInput, MinesweeperGameUncheckedCreateWithoutDifficultyInput> | MinesweeperGameCreateWithoutDifficultyInput[] | MinesweeperGameUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutDifficultyInput | MinesweeperGameCreateOrConnectWithoutDifficultyInput[]
    upsert?: MinesweeperGameUpsertWithWhereUniqueWithoutDifficultyInput | MinesweeperGameUpsertWithWhereUniqueWithoutDifficultyInput[]
    createMany?: MinesweeperGameCreateManyDifficultyInputEnvelope
    set?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    disconnect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    delete?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    update?: MinesweeperGameUpdateWithWhereUniqueWithoutDifficultyInput | MinesweeperGameUpdateWithWhereUniqueWithoutDifficultyInput[]
    updateMany?: MinesweeperGameUpdateManyWithWhereWithoutDifficultyInput | MinesweeperGameUpdateManyWithWhereWithoutDifficultyInput[]
    deleteMany?: MinesweeperGameScalarWhereInput | MinesweeperGameScalarWhereInput[]
  }

  export type MinesweeperGameUncheckedUpdateManyWithoutDifficultyNestedInput = {
    create?: XOR<MinesweeperGameCreateWithoutDifficultyInput, MinesweeperGameUncheckedCreateWithoutDifficultyInput> | MinesweeperGameCreateWithoutDifficultyInput[] | MinesweeperGameUncheckedCreateWithoutDifficultyInput[]
    connectOrCreate?: MinesweeperGameCreateOrConnectWithoutDifficultyInput | MinesweeperGameCreateOrConnectWithoutDifficultyInput[]
    upsert?: MinesweeperGameUpsertWithWhereUniqueWithoutDifficultyInput | MinesweeperGameUpsertWithWhereUniqueWithoutDifficultyInput[]
    createMany?: MinesweeperGameCreateManyDifficultyInputEnvelope
    set?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    disconnect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    delete?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    connect?: MinesweeperGameWhereUniqueInput | MinesweeperGameWhereUniqueInput[]
    update?: MinesweeperGameUpdateWithWhereUniqueWithoutDifficultyInput | MinesweeperGameUpdateWithWhereUniqueWithoutDifficultyInput[]
    updateMany?: MinesweeperGameUpdateManyWithWhereWithoutDifficultyInput | MinesweeperGameUpdateManyWithWhereWithoutDifficultyInput[]
    deleteMany?: MinesweeperGameScalarWhereInput | MinesweeperGameScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMinesweeperGamesInput = {
    create?: XOR<UserCreateWithoutMinesweeperGamesInput, UserUncheckedCreateWithoutMinesweeperGamesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMinesweeperGamesInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutMinesweeperGamesInput = {
    create?: XOR<CryptoTokenCreateWithoutMinesweeperGamesInput, CryptoTokenUncheckedCreateWithoutMinesweeperGamesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutMinesweeperGamesInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type MinesweeperDifficultyCreateNestedOneWithoutGamesInput = {
    create?: XOR<MinesweeperDifficultyCreateWithoutGamesInput, MinesweeperDifficultyUncheckedCreateWithoutGamesInput>
    connectOrCreate?: MinesweeperDifficultyCreateOrConnectWithoutGamesInput
    connect?: MinesweeperDifficultyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMinesweeperGamesNestedInput = {
    create?: XOR<UserCreateWithoutMinesweeperGamesInput, UserUncheckedCreateWithoutMinesweeperGamesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMinesweeperGamesInput
    upsert?: UserUpsertWithoutMinesweeperGamesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMinesweeperGamesInput, UserUpdateWithoutMinesweeperGamesInput>, UserUncheckedUpdateWithoutMinesweeperGamesInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutMinesweeperGamesNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutMinesweeperGamesInput, CryptoTokenUncheckedCreateWithoutMinesweeperGamesInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutMinesweeperGamesInput
    upsert?: CryptoTokenUpsertWithoutMinesweeperGamesInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutMinesweeperGamesInput, CryptoTokenUpdateWithoutMinesweeperGamesInput>, CryptoTokenUncheckedUpdateWithoutMinesweeperGamesInput>
  }

  export type MinesweeperDifficultyUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<MinesweeperDifficultyCreateWithoutGamesInput, MinesweeperDifficultyUncheckedCreateWithoutGamesInput>
    connectOrCreate?: MinesweeperDifficultyCreateOrConnectWithoutGamesInput
    upsert?: MinesweeperDifficultyUpsertWithoutGamesInput
    connect?: MinesweeperDifficultyWhereUniqueInput
    update?: XOR<XOR<MinesweeperDifficultyUpdateToOneWithWhereWithoutGamesInput, MinesweeperDifficultyUpdateWithoutGamesInput>, MinesweeperDifficultyUncheckedUpdateWithoutGamesInput>
  }

  export type UserCreateNestedOneWithoutMinesweeperBetsInput = {
    create?: XOR<UserCreateWithoutMinesweeperBetsInput, UserUncheckedCreateWithoutMinesweeperBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMinesweeperBetsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTokenCreateNestedOneWithoutMinesweeperBetsInput = {
    create?: XOR<CryptoTokenCreateWithoutMinesweeperBetsInput, CryptoTokenUncheckedCreateWithoutMinesweeperBetsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutMinesweeperBetsInput
    connect?: CryptoTokenWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMinesweeperBetsNestedInput = {
    create?: XOR<UserCreateWithoutMinesweeperBetsInput, UserUncheckedCreateWithoutMinesweeperBetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMinesweeperBetsInput
    upsert?: UserUpsertWithoutMinesweeperBetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMinesweeperBetsInput, UserUpdateWithoutMinesweeperBetsInput>, UserUncheckedUpdateWithoutMinesweeperBetsInput>
  }

  export type CryptoTokenUpdateOneRequiredWithoutMinesweeperBetsNestedInput = {
    create?: XOR<CryptoTokenCreateWithoutMinesweeperBetsInput, CryptoTokenUncheckedCreateWithoutMinesweeperBetsInput>
    connectOrCreate?: CryptoTokenCreateOrConnectWithoutMinesweeperBetsInput
    upsert?: CryptoTokenUpsertWithoutMinesweeperBetsInput
    connect?: CryptoTokenWhereUniqueInput
    update?: XOR<XOR<CryptoTokenUpdateToOneWithWhereWithoutMinesweeperBetsInput, CryptoTokenUpdateWithoutMinesweeperBetsInput>, CryptoTokenUncheckedUpdateWithoutMinesweeperBetsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBalanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeFilter<$PrismaModel> | $Enums.BalanceType
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.BalanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBalanceTypeFilter<$PrismaModel>
    _max?: NestedEnumBalanceTypeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumGameTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameTypeFilter<$PrismaModel> | $Enums.GameType
  }

  export type NestedEnumGameTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameType[] | ListEnumGameTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGameTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameTypeFilter<$PrismaModel>
    _max?: NestedEnumGameTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReferralEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralEventType | EnumReferralEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralEventTypeFilter<$PrismaModel> | $Enums.ReferralEventType
  }

  export type NestedEnumReferralEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralEventType | EnumReferralEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralEventType[] | ListEnumReferralEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReferralEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferralEventTypeFilter<$PrismaModel>
    _max?: NestedEnumReferralEventTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CrashBetCreateWithoutTokenInput = {
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    round: CrashRoundCreateNestedOneWithoutBetsInput
    user: UserCreateNestedOneWithoutCrashBetsInput
    transactions?: CrashTransactionCreateNestedManyWithoutBetInput
  }

  export type CrashBetUncheckedCreateWithoutTokenInput = {
    id?: number
    roundId: number
    userId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    transactions?: CrashTransactionUncheckedCreateNestedManyWithoutBetInput
  }

  export type CrashBetCreateOrConnectWithoutTokenInput = {
    where: CrashBetWhereUniqueInput
    create: XOR<CrashBetCreateWithoutTokenInput, CrashBetUncheckedCreateWithoutTokenInput>
  }

  export type CrashBetCreateManyTokenInputEnvelope = {
    data: CrashBetCreateManyTokenInput | CrashBetCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type CrashTransactionCreateWithoutTokenInput = {
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCrashTransactionsInput
    bet?: CrashBetCreateNestedOneWithoutTransactionsInput
  }

  export type CrashTransactionUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    betId?: number | null
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type CrashTransactionCreateOrConnectWithoutTokenInput = {
    where: CrashTransactionWhereUniqueInput
    create: XOR<CrashTransactionCreateWithoutTokenInput, CrashTransactionUncheckedCreateWithoutTokenInput>
  }

  export type CrashTransactionCreateManyTokenInputEnvelope = {
    data: CrashTransactionCreateManyTokenInput | CrashTransactionCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type MinesweeperGameCreateWithoutTokenInput = {
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMinesweeperGamesInput
    difficulty: MinesweeperDifficultyCreateNestedOneWithoutGamesInput
  }

  export type MinesweeperGameUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    difficultyId: number
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinesweeperGameCreateOrConnectWithoutTokenInput = {
    where: MinesweeperGameWhereUniqueInput
    create: XOR<MinesweeperGameCreateWithoutTokenInput, MinesweeperGameUncheckedCreateWithoutTokenInput>
  }

  export type MinesweeperGameCreateManyTokenInputEnvelope = {
    data: MinesweeperGameCreateManyTokenInput | MinesweeperGameCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type MinesweeperBetCreateWithoutTokenInput = {
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMinesweeperBetsInput
  }

  export type MinesweeperBetUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
  }

  export type MinesweeperBetCreateOrConnectWithoutTokenInput = {
    where: MinesweeperBetWhereUniqueInput
    create: XOR<MinesweeperBetCreateWithoutTokenInput, MinesweeperBetUncheckedCreateWithoutTokenInput>
  }

  export type MinesweeperBetCreateManyTokenInputEnvelope = {
    data: MinesweeperBetCreateManyTokenInput | MinesweeperBetCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type BalanceCreateWithoutTokenInput = {
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceCreateOrConnectWithoutTokenInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput>
  }

  export type BalanceCreateManyTokenInputEnvelope = {
    data: BalanceCreateManyTokenInput | BalanceCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutTokenInput = {
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutTokenInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput>
  }

  export type TransactionCreateManyTokenInputEnvelope = {
    data: TransactionCreateManyTokenInput | TransactionCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type BetCreateWithoutTokenInput = {
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBetsInput
  }

  export type BetUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BetCreateOrConnectWithoutTokenInput = {
    where: BetWhereUniqueInput
    create: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput>
  }

  export type BetCreateManyTokenInputEnvelope = {
    data: BetCreateManyTokenInput | BetCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardEntryCreateWithoutTokenInput = {
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type LeaderboardEntryUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryCreateOrConnectWithoutTokenInput = {
    where: LeaderboardEntryWhereUniqueInput
    create: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput>
  }

  export type LeaderboardEntryCreateManyTokenInputEnvelope = {
    data: LeaderboardEntryCreateManyTokenInput | LeaderboardEntryCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type UserBonusCreateWithoutTokenInput = {
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutBonusesInput
    bonus: BonusCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateWithoutTokenInput = {
    id?: number
    userId: number
    bonusId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusCreateOrConnectWithoutTokenInput = {
    where: UserBonusWhereUniqueInput
    create: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput>
  }

  export type UserBonusCreateManyTokenInputEnvelope = {
    data: UserBonusCreateManyTokenInput | UserBonusCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type ReferralTransactionCreateWithoutTokenInput = {
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutCommissionsInput
    referee: UserCreateNestedOneWithoutReferralActionsInput
  }

  export type ReferralTransactionUncheckedCreateWithoutTokenInput = {
    id?: number
    referrerId: number
    refereeId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionCreateOrConnectWithoutTokenInput = {
    where: ReferralTransactionWhereUniqueInput
    create: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput>
  }

  export type ReferralTransactionCreateManyTokenInputEnvelope = {
    data: ReferralTransactionCreateManyTokenInput | ReferralTransactionCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type CrashBetUpsertWithWhereUniqueWithoutTokenInput = {
    where: CrashBetWhereUniqueInput
    update: XOR<CrashBetUpdateWithoutTokenInput, CrashBetUncheckedUpdateWithoutTokenInput>
    create: XOR<CrashBetCreateWithoutTokenInput, CrashBetUncheckedCreateWithoutTokenInput>
  }

  export type CrashBetUpdateWithWhereUniqueWithoutTokenInput = {
    where: CrashBetWhereUniqueInput
    data: XOR<CrashBetUpdateWithoutTokenInput, CrashBetUncheckedUpdateWithoutTokenInput>
  }

  export type CrashBetUpdateManyWithWhereWithoutTokenInput = {
    where: CrashBetScalarWhereInput
    data: XOR<CrashBetUpdateManyMutationInput, CrashBetUncheckedUpdateManyWithoutTokenInput>
  }

  export type CrashBetScalarWhereInput = {
    AND?: CrashBetScalarWhereInput | CrashBetScalarWhereInput[]
    OR?: CrashBetScalarWhereInput[]
    NOT?: CrashBetScalarWhereInput | CrashBetScalarWhereInput[]
    id?: IntFilter<"CrashBet"> | number
    roundId?: IntFilter<"CrashBet"> | number
    userId?: IntFilter<"CrashBet"> | number
    tokenId?: IntFilter<"CrashBet"> | number
    betAmount?: DecimalFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string
    exitMultiplier?: DecimalNullableFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string | null
    winnings?: DecimalNullableFilter<"CrashBet"> | Decimal | DecimalJsLike | number | string | null
    result?: StringFilter<"CrashBet"> | string
    createdAt?: DateTimeFilter<"CrashBet"> | Date | string
  }

  export type CrashTransactionUpsertWithWhereUniqueWithoutTokenInput = {
    where: CrashTransactionWhereUniqueInput
    update: XOR<CrashTransactionUpdateWithoutTokenInput, CrashTransactionUncheckedUpdateWithoutTokenInput>
    create: XOR<CrashTransactionCreateWithoutTokenInput, CrashTransactionUncheckedCreateWithoutTokenInput>
  }

  export type CrashTransactionUpdateWithWhereUniqueWithoutTokenInput = {
    where: CrashTransactionWhereUniqueInput
    data: XOR<CrashTransactionUpdateWithoutTokenInput, CrashTransactionUncheckedUpdateWithoutTokenInput>
  }

  export type CrashTransactionUpdateManyWithWhereWithoutTokenInput = {
    where: CrashTransactionScalarWhereInput
    data: XOR<CrashTransactionUpdateManyMutationInput, CrashTransactionUncheckedUpdateManyWithoutTokenInput>
  }

  export type CrashTransactionScalarWhereInput = {
    AND?: CrashTransactionScalarWhereInput | CrashTransactionScalarWhereInput[]
    OR?: CrashTransactionScalarWhereInput[]
    NOT?: CrashTransactionScalarWhereInput | CrashTransactionScalarWhereInput[]
    id?: IntFilter<"CrashTransaction"> | number
    userId?: IntFilter<"CrashTransaction"> | number
    betId?: IntNullableFilter<"CrashTransaction"> | number | null
    tokenId?: IntFilter<"CrashTransaction"> | number
    amount?: DecimalFilter<"CrashTransaction"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"CrashTransaction"> | string
    createdAt?: DateTimeFilter<"CrashTransaction"> | Date | string
  }

  export type MinesweeperGameUpsertWithWhereUniqueWithoutTokenInput = {
    where: MinesweeperGameWhereUniqueInput
    update: XOR<MinesweeperGameUpdateWithoutTokenInput, MinesweeperGameUncheckedUpdateWithoutTokenInput>
    create: XOR<MinesweeperGameCreateWithoutTokenInput, MinesweeperGameUncheckedCreateWithoutTokenInput>
  }

  export type MinesweeperGameUpdateWithWhereUniqueWithoutTokenInput = {
    where: MinesweeperGameWhereUniqueInput
    data: XOR<MinesweeperGameUpdateWithoutTokenInput, MinesweeperGameUncheckedUpdateWithoutTokenInput>
  }

  export type MinesweeperGameUpdateManyWithWhereWithoutTokenInput = {
    where: MinesweeperGameScalarWhereInput
    data: XOR<MinesweeperGameUpdateManyMutationInput, MinesweeperGameUncheckedUpdateManyWithoutTokenInput>
  }

  export type MinesweeperGameScalarWhereInput = {
    AND?: MinesweeperGameScalarWhereInput | MinesweeperGameScalarWhereInput[]
    OR?: MinesweeperGameScalarWhereInput[]
    NOT?: MinesweeperGameScalarWhereInput | MinesweeperGameScalarWhereInput[]
    id?: IntFilter<"MinesweeperGame"> | number
    userId?: IntFilter<"MinesweeperGame"> | number
    tokenId?: IntFilter<"MinesweeperGame"> | number
    difficultyId?: IntFilter<"MinesweeperGame"> | number
    gameState?: JsonFilter<"MinesweeperGame">
    minesPositions?: JsonFilter<"MinesweeperGame">
    status?: StringFilter<"MinesweeperGame"> | string
    revealedCells?: IntFilter<"MinesweeperGame"> | number
    flaggedCells?: IntFilter<"MinesweeperGame"> | number
    betAmount?: DecimalFilter<"MinesweeperGame"> | Decimal | DecimalJsLike | number | string
    winAmount?: DecimalNullableFilter<"MinesweeperGame"> | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFilter<"MinesweeperGame"> | number
    createdAt?: DateTimeFilter<"MinesweeperGame"> | Date | string
    updatedAt?: DateTimeFilter<"MinesweeperGame"> | Date | string
  }

  export type MinesweeperBetUpsertWithWhereUniqueWithoutTokenInput = {
    where: MinesweeperBetWhereUniqueInput
    update: XOR<MinesweeperBetUpdateWithoutTokenInput, MinesweeperBetUncheckedUpdateWithoutTokenInput>
    create: XOR<MinesweeperBetCreateWithoutTokenInput, MinesweeperBetUncheckedCreateWithoutTokenInput>
  }

  export type MinesweeperBetUpdateWithWhereUniqueWithoutTokenInput = {
    where: MinesweeperBetWhereUniqueInput
    data: XOR<MinesweeperBetUpdateWithoutTokenInput, MinesweeperBetUncheckedUpdateWithoutTokenInput>
  }

  export type MinesweeperBetUpdateManyWithWhereWithoutTokenInput = {
    where: MinesweeperBetScalarWhereInput
    data: XOR<MinesweeperBetUpdateManyMutationInput, MinesweeperBetUncheckedUpdateManyWithoutTokenInput>
  }

  export type MinesweeperBetScalarWhereInput = {
    AND?: MinesweeperBetScalarWhereInput | MinesweeperBetScalarWhereInput[]
    OR?: MinesweeperBetScalarWhereInput[]
    NOT?: MinesweeperBetScalarWhereInput | MinesweeperBetScalarWhereInput[]
    id?: IntFilter<"MinesweeperBet"> | number
    userId?: IntFilter<"MinesweeperBet"> | number
    tokenId?: IntFilter<"MinesweeperBet"> | number
    gameId?: IntFilter<"MinesweeperBet"> | number
    betAmount?: DecimalFilter<"MinesweeperBet"> | Decimal | DecimalJsLike | number | string
    winAmount?: DecimalNullableFilter<"MinesweeperBet"> | Decimal | DecimalJsLike | number | string | null
    result?: StringFilter<"MinesweeperBet"> | string
    multiplier?: FloatFilter<"MinesweeperBet"> | number
    createdAt?: DateTimeFilter<"MinesweeperBet"> | Date | string
  }

  export type BalanceUpsertWithWhereUniqueWithoutTokenInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutTokenInput, BalanceUncheckedUpdateWithoutTokenInput>
    create: XOR<BalanceCreateWithoutTokenInput, BalanceUncheckedCreateWithoutTokenInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutTokenInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutTokenInput, BalanceUncheckedUpdateWithoutTokenInput>
  }

  export type BalanceUpdateManyWithWhereWithoutTokenInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutTokenInput>
  }

  export type BalanceScalarWhereInput = {
    AND?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    OR?: BalanceScalarWhereInput[]
    NOT?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    id?: IntFilter<"Balance"> | number
    userId?: IntFilter<"Balance"> | number
    tokenId?: IntFilter<"Balance"> | number
    type?: EnumBalanceTypeFilter<"Balance"> | $Enums.BalanceType
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Balance"> | Date | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutTokenInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTokenInput, TransactionUncheckedUpdateWithoutTokenInput>
    create: XOR<TransactionCreateWithoutTokenInput, TransactionUncheckedCreateWithoutTokenInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTokenInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTokenInput, TransactionUncheckedUpdateWithoutTokenInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTokenInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTokenInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    userId?: IntFilter<"Transaction"> | number
    tokenId?: IntFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"Transaction"> | string | null
    walletAddress?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type BetUpsertWithWhereUniqueWithoutTokenInput = {
    where: BetWhereUniqueInput
    update: XOR<BetUpdateWithoutTokenInput, BetUncheckedUpdateWithoutTokenInput>
    create: XOR<BetCreateWithoutTokenInput, BetUncheckedCreateWithoutTokenInput>
  }

  export type BetUpdateWithWhereUniqueWithoutTokenInput = {
    where: BetWhereUniqueInput
    data: XOR<BetUpdateWithoutTokenInput, BetUncheckedUpdateWithoutTokenInput>
  }

  export type BetUpdateManyWithWhereWithoutTokenInput = {
    where: BetScalarWhereInput
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyWithoutTokenInput>
  }

  export type BetScalarWhereInput = {
    AND?: BetScalarWhereInput | BetScalarWhereInput[]
    OR?: BetScalarWhereInput[]
    NOT?: BetScalarWhereInput | BetScalarWhereInput[]
    id?: IntFilter<"Bet"> | number
    userId?: IntFilter<"Bet"> | number
    tokenId?: IntFilter<"Bet"> | number
    gameType?: EnumGameTypeFilter<"Bet"> | $Enums.GameType
    betAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Bet"> | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFilter<"Bet"> | number
    roundId?: StringFilter<"Bet"> | string
    details?: JsonNullableFilter<"Bet">
    createdAt?: DateTimeFilter<"Bet"> | Date | string
  }

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutTokenInput = {
    where: LeaderboardEntryWhereUniqueInput
    update: XOR<LeaderboardEntryUpdateWithoutTokenInput, LeaderboardEntryUncheckedUpdateWithoutTokenInput>
    create: XOR<LeaderboardEntryCreateWithoutTokenInput, LeaderboardEntryUncheckedCreateWithoutTokenInput>
  }

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutTokenInput = {
    where: LeaderboardEntryWhereUniqueInput
    data: XOR<LeaderboardEntryUpdateWithoutTokenInput, LeaderboardEntryUncheckedUpdateWithoutTokenInput>
  }

  export type LeaderboardEntryUpdateManyWithWhereWithoutTokenInput = {
    where: LeaderboardEntryScalarWhereInput
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyWithoutTokenInput>
  }

  export type LeaderboardEntryScalarWhereInput = {
    AND?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    OR?: LeaderboardEntryScalarWhereInput[]
    NOT?: LeaderboardEntryScalarWhereInput | LeaderboardEntryScalarWhereInput[]
    id?: IntFilter<"LeaderboardEntry"> | number
    userId?: IntFilter<"LeaderboardEntry"> | number
    tokenId?: IntNullableFilter<"LeaderboardEntry"> | number | null
    metric?: StringFilter<"LeaderboardEntry"> | string
    score?: DecimalFilter<"LeaderboardEntry"> | Decimal | DecimalJsLike | number | string
    period?: StringFilter<"LeaderboardEntry"> | string
    updatedAt?: DateTimeFilter<"LeaderboardEntry"> | Date | string
  }

  export type UserBonusUpsertWithWhereUniqueWithoutTokenInput = {
    where: UserBonusWhereUniqueInput
    update: XOR<UserBonusUpdateWithoutTokenInput, UserBonusUncheckedUpdateWithoutTokenInput>
    create: XOR<UserBonusCreateWithoutTokenInput, UserBonusUncheckedCreateWithoutTokenInput>
  }

  export type UserBonusUpdateWithWhereUniqueWithoutTokenInput = {
    where: UserBonusWhereUniqueInput
    data: XOR<UserBonusUpdateWithoutTokenInput, UserBonusUncheckedUpdateWithoutTokenInput>
  }

  export type UserBonusUpdateManyWithWhereWithoutTokenInput = {
    where: UserBonusScalarWhereInput
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyWithoutTokenInput>
  }

  export type UserBonusScalarWhereInput = {
    AND?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
    OR?: UserBonusScalarWhereInput[]
    NOT?: UserBonusScalarWhereInput | UserBonusScalarWhereInput[]
    id?: IntFilter<"UserBonus"> | number
    userId?: IntFilter<"UserBonus"> | number
    bonusId?: IntFilter<"UserBonus"> | number
    tokenId?: IntFilter<"UserBonus"> | number
    grantedAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFilter<"UserBonus"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"UserBonus"> | boolean
    isCompleted?: BoolFilter<"UserBonus"> | boolean
    createdAt?: DateTimeFilter<"UserBonus"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserBonus"> | Date | string | null
  }

  export type ReferralTransactionUpsertWithWhereUniqueWithoutTokenInput = {
    where: ReferralTransactionWhereUniqueInput
    update: XOR<ReferralTransactionUpdateWithoutTokenInput, ReferralTransactionUncheckedUpdateWithoutTokenInput>
    create: XOR<ReferralTransactionCreateWithoutTokenInput, ReferralTransactionUncheckedCreateWithoutTokenInput>
  }

  export type ReferralTransactionUpdateWithWhereUniqueWithoutTokenInput = {
    where: ReferralTransactionWhereUniqueInput
    data: XOR<ReferralTransactionUpdateWithoutTokenInput, ReferralTransactionUncheckedUpdateWithoutTokenInput>
  }

  export type ReferralTransactionUpdateManyWithWhereWithoutTokenInput = {
    where: ReferralTransactionScalarWhereInput
    data: XOR<ReferralTransactionUpdateManyMutationInput, ReferralTransactionUncheckedUpdateManyWithoutTokenInput>
  }

  export type ReferralTransactionScalarWhereInput = {
    AND?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
    OR?: ReferralTransactionScalarWhereInput[]
    NOT?: ReferralTransactionScalarWhereInput | ReferralTransactionScalarWhereInput[]
    id?: IntFilter<"ReferralTransaction"> | number
    referrerId?: IntFilter<"ReferralTransaction"> | number
    refereeId?: IntFilter<"ReferralTransaction"> | number
    tokenId?: IntFilter<"ReferralTransaction"> | number
    eventType?: EnumReferralEventTypeFilter<"ReferralTransaction"> | $Enums.ReferralEventType
    amount?: DecimalFilter<"ReferralTransaction"> | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFilter<"ReferralTransaction"> | number
    sourceEntityType?: StringFilter<"ReferralTransaction"> | string
    createdAt?: DateTimeFilter<"ReferralTransaction"> | Date | string
  }

  export type UserCreateWithoutReferralsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferrerInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferrerInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferrerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput>
  }

  export type UserCreateManyReferrerInputEnvelope = {
    data: UserCreateManyReferrerInput | UserCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type CrashBetCreateWithoutUserInput = {
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    round: CrashRoundCreateNestedOneWithoutBetsInput
    token: CryptoTokenCreateNestedOneWithoutCrashBetsInput
    transactions?: CrashTransactionCreateNestedManyWithoutBetInput
  }

  export type CrashBetUncheckedCreateWithoutUserInput = {
    id?: number
    roundId: number
    tokenId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    transactions?: CrashTransactionUncheckedCreateNestedManyWithoutBetInput
  }

  export type CrashBetCreateOrConnectWithoutUserInput = {
    where: CrashBetWhereUniqueInput
    create: XOR<CrashBetCreateWithoutUserInput, CrashBetUncheckedCreateWithoutUserInput>
  }

  export type CrashBetCreateManyUserInputEnvelope = {
    data: CrashBetCreateManyUserInput | CrashBetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CrashTransactionCreateWithoutUserInput = {
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
    bet?: CrashBetCreateNestedOneWithoutTransactionsInput
    token: CryptoTokenCreateNestedOneWithoutCrashTransactionsInput
  }

  export type CrashTransactionUncheckedCreateWithoutUserInput = {
    id?: number
    betId?: number | null
    tokenId: number
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type CrashTransactionCreateOrConnectWithoutUserInput = {
    where: CrashTransactionWhereUniqueInput
    create: XOR<CrashTransactionCreateWithoutUserInput, CrashTransactionUncheckedCreateWithoutUserInput>
  }

  export type CrashTransactionCreateManyUserInputEnvelope = {
    data: CrashTransactionCreateManyUserInput | CrashTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MinesweeperGameCreateWithoutUserInput = {
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    token: CryptoTokenCreateNestedOneWithoutMinesweeperGamesInput
    difficulty: MinesweeperDifficultyCreateNestedOneWithoutGamesInput
  }

  export type MinesweeperGameUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId: number
    difficultyId: number
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinesweeperGameCreateOrConnectWithoutUserInput = {
    where: MinesweeperGameWhereUniqueInput
    create: XOR<MinesweeperGameCreateWithoutUserInput, MinesweeperGameUncheckedCreateWithoutUserInput>
  }

  export type MinesweeperGameCreateManyUserInputEnvelope = {
    data: MinesweeperGameCreateManyUserInput | MinesweeperGameCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MinesweeperBetCreateWithoutUserInput = {
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
    token: CryptoTokenCreateNestedOneWithoutMinesweeperBetsInput
  }

  export type MinesweeperBetUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId: number
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
  }

  export type MinesweeperBetCreateOrConnectWithoutUserInput = {
    where: MinesweeperBetWhereUniqueInput
    create: XOR<MinesweeperBetCreateWithoutUserInput, MinesweeperBetUncheckedCreateWithoutUserInput>
  }

  export type MinesweeperBetCreateManyUserInputEnvelope = {
    data: MinesweeperBetCreateManyUserInput | MinesweeperBetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BalanceCreateWithoutUserInput = {
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    token: CryptoTokenCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceCreateOrConnectWithoutUserInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput>
  }

  export type BalanceCreateManyUserInputEnvelope = {
    data: BalanceCreateManyUserInput | BalanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    token: CryptoTokenCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BetCreateWithoutUserInput = {
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    token: CryptoTokenCreateNestedOneWithoutBetsInput
  }

  export type BetUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BetCreateOrConnectWithoutUserInput = {
    where: BetWhereUniqueInput
    create: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput>
  }

  export type BetCreateManyUserInputEnvelope = {
    data: BetCreateManyUserInput | BetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardEntryCreateWithoutUserInput = {
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
    token?: CryptoTokenCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardEntryUncheckedCreateWithoutUserInput = {
    id?: number
    tokenId?: number | null
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type LeaderboardEntryCreateOrConnectWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryCreateManyUserInputEnvelope = {
    data: LeaderboardEntryCreateManyUserInput | LeaderboardEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBonusCreateWithoutUserInput = {
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    bonus: BonusCreateNestedOneWithoutUserBonusesInput
    token: CryptoTokenCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateWithoutUserInput = {
    id?: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusCreateOrConnectWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    create: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput>
  }

  export type UserBonusCreateManyUserInputEnvelope = {
    data: UserBonusCreateManyUserInput | UserBonusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralTransactionCreateWithoutReferrerInput = {
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
    referee: UserCreateNestedOneWithoutReferralActionsInput
    token: CryptoTokenCreateNestedOneWithoutReferralCommissionsInput
  }

  export type ReferralTransactionUncheckedCreateWithoutReferrerInput = {
    id?: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionCreateOrConnectWithoutReferrerInput = {
    where: ReferralTransactionWhereUniqueInput
    create: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralTransactionCreateManyReferrerInputEnvelope = {
    data: ReferralTransactionCreateManyReferrerInput | ReferralTransactionCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralTransactionCreateWithoutRefereeInput = {
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutCommissionsInput
    token: CryptoTokenCreateNestedOneWithoutReferralCommissionsInput
  }

  export type ReferralTransactionUncheckedCreateWithoutRefereeInput = {
    id?: number
    referrerId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionCreateOrConnectWithoutRefereeInput = {
    where: ReferralTransactionWhereUniqueInput
    create: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralTransactionCreateManyRefereeInputEnvelope = {
    data: ReferralTransactionCreateManyRefereeInput | ReferralTransactionCreateManyRefereeInput[]
    skipDuplicates?: boolean
  }

  export type OneTimeTokenCreateWithoutUserInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type OneTimeTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type OneTimeTokenCreateOrConnectWithoutUserInput = {
    where: OneTimeTokenWhereUniqueInput
    create: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput>
  }

  export type OneTimeTokenCreateManyUserInputEnvelope = {
    data: OneTimeTokenCreateManyUserInput | OneTimeTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReferrerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferrerInput, UserUncheckedUpdateWithoutReferrerInput>
    create: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferrerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferrerInput, UserUncheckedUpdateWithoutReferrerInput>
  }

  export type UserUpdateManyWithWhereWithoutReferrerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferrerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    telegramId?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    salt?: StringNullableFilter<"User"> | string | null
    isAdmin?: BoolFilter<"User"> | boolean
    isBlocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referralCode?: StringFilter<"User"> | string
    referredById?: IntNullableFilter<"User"> | number | null
  }

  export type CrashBetUpsertWithWhereUniqueWithoutUserInput = {
    where: CrashBetWhereUniqueInput
    update: XOR<CrashBetUpdateWithoutUserInput, CrashBetUncheckedUpdateWithoutUserInput>
    create: XOR<CrashBetCreateWithoutUserInput, CrashBetUncheckedCreateWithoutUserInput>
  }

  export type CrashBetUpdateWithWhereUniqueWithoutUserInput = {
    where: CrashBetWhereUniqueInput
    data: XOR<CrashBetUpdateWithoutUserInput, CrashBetUncheckedUpdateWithoutUserInput>
  }

  export type CrashBetUpdateManyWithWhereWithoutUserInput = {
    where: CrashBetScalarWhereInput
    data: XOR<CrashBetUpdateManyMutationInput, CrashBetUncheckedUpdateManyWithoutUserInput>
  }

  export type CrashTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: CrashTransactionWhereUniqueInput
    update: XOR<CrashTransactionUpdateWithoutUserInput, CrashTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<CrashTransactionCreateWithoutUserInput, CrashTransactionUncheckedCreateWithoutUserInput>
  }

  export type CrashTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: CrashTransactionWhereUniqueInput
    data: XOR<CrashTransactionUpdateWithoutUserInput, CrashTransactionUncheckedUpdateWithoutUserInput>
  }

  export type CrashTransactionUpdateManyWithWhereWithoutUserInput = {
    where: CrashTransactionScalarWhereInput
    data: XOR<CrashTransactionUpdateManyMutationInput, CrashTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type MinesweeperGameUpsertWithWhereUniqueWithoutUserInput = {
    where: MinesweeperGameWhereUniqueInput
    update: XOR<MinesweeperGameUpdateWithoutUserInput, MinesweeperGameUncheckedUpdateWithoutUserInput>
    create: XOR<MinesweeperGameCreateWithoutUserInput, MinesweeperGameUncheckedCreateWithoutUserInput>
  }

  export type MinesweeperGameUpdateWithWhereUniqueWithoutUserInput = {
    where: MinesweeperGameWhereUniqueInput
    data: XOR<MinesweeperGameUpdateWithoutUserInput, MinesweeperGameUncheckedUpdateWithoutUserInput>
  }

  export type MinesweeperGameUpdateManyWithWhereWithoutUserInput = {
    where: MinesweeperGameScalarWhereInput
    data: XOR<MinesweeperGameUpdateManyMutationInput, MinesweeperGameUncheckedUpdateManyWithoutUserInput>
  }

  export type MinesweeperBetUpsertWithWhereUniqueWithoutUserInput = {
    where: MinesweeperBetWhereUniqueInput
    update: XOR<MinesweeperBetUpdateWithoutUserInput, MinesweeperBetUncheckedUpdateWithoutUserInput>
    create: XOR<MinesweeperBetCreateWithoutUserInput, MinesweeperBetUncheckedCreateWithoutUserInput>
  }

  export type MinesweeperBetUpdateWithWhereUniqueWithoutUserInput = {
    where: MinesweeperBetWhereUniqueInput
    data: XOR<MinesweeperBetUpdateWithoutUserInput, MinesweeperBetUncheckedUpdateWithoutUserInput>
  }

  export type MinesweeperBetUpdateManyWithWhereWithoutUserInput = {
    where: MinesweeperBetScalarWhereInput
    data: XOR<MinesweeperBetUpdateManyMutationInput, MinesweeperBetUncheckedUpdateManyWithoutUserInput>
  }

  export type BalanceUpsertWithWhereUniqueWithoutUserInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutUserInput, BalanceUncheckedUpdateWithoutUserInput>
    create: XOR<BalanceCreateWithoutUserInput, BalanceUncheckedCreateWithoutUserInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutUserInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutUserInput, BalanceUncheckedUpdateWithoutUserInput>
  }

  export type BalanceUpdateManyWithWhereWithoutUserInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type BetUpsertWithWhereUniqueWithoutUserInput = {
    where: BetWhereUniqueInput
    update: XOR<BetUpdateWithoutUserInput, BetUncheckedUpdateWithoutUserInput>
    create: XOR<BetCreateWithoutUserInput, BetUncheckedCreateWithoutUserInput>
  }

  export type BetUpdateWithWhereUniqueWithoutUserInput = {
    where: BetWhereUniqueInput
    data: XOR<BetUpdateWithoutUserInput, BetUncheckedUpdateWithoutUserInput>
  }

  export type BetUpdateManyWithWhereWithoutUserInput = {
    where: BetScalarWhereInput
    data: XOR<BetUpdateManyMutationInput, BetUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaderboardEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    update: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardEntryCreateWithoutUserInput, LeaderboardEntryUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardEntryWhereUniqueInput
    data: XOR<LeaderboardEntryUpdateWithoutUserInput, LeaderboardEntryUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardEntryUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardEntryScalarWhereInput
    data: XOR<LeaderboardEntryUpdateManyMutationInput, LeaderboardEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBonusUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    update: XOR<UserBonusUpdateWithoutUserInput, UserBonusUncheckedUpdateWithoutUserInput>
    create: XOR<UserBonusCreateWithoutUserInput, UserBonusUncheckedCreateWithoutUserInput>
  }

  export type UserBonusUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBonusWhereUniqueInput
    data: XOR<UserBonusUpdateWithoutUserInput, UserBonusUncheckedUpdateWithoutUserInput>
  }

  export type UserBonusUpdateManyWithWhereWithoutUserInput = {
    where: UserBonusScalarWhereInput
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralTransactionUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralTransactionWhereUniqueInput
    update: XOR<ReferralTransactionUpdateWithoutReferrerInput, ReferralTransactionUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralTransactionCreateWithoutReferrerInput, ReferralTransactionUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralTransactionUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralTransactionWhereUniqueInput
    data: XOR<ReferralTransactionUpdateWithoutReferrerInput, ReferralTransactionUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralTransactionUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralTransactionScalarWhereInput
    data: XOR<ReferralTransactionUpdateManyMutationInput, ReferralTransactionUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralTransactionUpsertWithWhereUniqueWithoutRefereeInput = {
    where: ReferralTransactionWhereUniqueInput
    update: XOR<ReferralTransactionUpdateWithoutRefereeInput, ReferralTransactionUncheckedUpdateWithoutRefereeInput>
    create: XOR<ReferralTransactionCreateWithoutRefereeInput, ReferralTransactionUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralTransactionUpdateWithWhereUniqueWithoutRefereeInput = {
    where: ReferralTransactionWhereUniqueInput
    data: XOR<ReferralTransactionUpdateWithoutRefereeInput, ReferralTransactionUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralTransactionUpdateManyWithWhereWithoutRefereeInput = {
    where: ReferralTransactionScalarWhereInput
    data: XOR<ReferralTransactionUpdateManyMutationInput, ReferralTransactionUncheckedUpdateManyWithoutRefereeInput>
  }

  export type OneTimeTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: OneTimeTokenWhereUniqueInput
    update: XOR<OneTimeTokenUpdateWithoutUserInput, OneTimeTokenUncheckedUpdateWithoutUserInput>
    create: XOR<OneTimeTokenCreateWithoutUserInput, OneTimeTokenUncheckedCreateWithoutUserInput>
  }

  export type OneTimeTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: OneTimeTokenWhereUniqueInput
    data: XOR<OneTimeTokenUpdateWithoutUserInput, OneTimeTokenUncheckedUpdateWithoutUserInput>
  }

  export type OneTimeTokenUpdateManyWithWhereWithoutUserInput = {
    where: OneTimeTokenScalarWhereInput
    data: XOR<OneTimeTokenUpdateManyMutationInput, OneTimeTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type OneTimeTokenScalarWhereInput = {
    AND?: OneTimeTokenScalarWhereInput | OneTimeTokenScalarWhereInput[]
    OR?: OneTimeTokenScalarWhereInput[]
    NOT?: OneTimeTokenScalarWhereInput | OneTimeTokenScalarWhereInput[]
    id?: IntFilter<"OneTimeToken"> | number
    token?: StringFilter<"OneTimeToken"> | string
    userId?: IntFilter<"OneTimeToken"> | number
    createdAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    expiresAt?: DateTimeFilter<"OneTimeToken"> | Date | string
    used?: BoolFilter<"OneTimeToken"> | boolean
  }

  export type UserCreateWithoutBalancesInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBalancesInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBalancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBalancesInput, UserUncheckedCreateWithoutBalancesInput>
  }

  export type CryptoTokenCreateWithoutBalancesInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutBalancesInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutBalancesInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutBalancesInput, CryptoTokenUncheckedCreateWithoutBalancesInput>
  }

  export type UserUpsertWithoutBalancesInput = {
    update: XOR<UserUpdateWithoutBalancesInput, UserUncheckedUpdateWithoutBalancesInput>
    create: XOR<UserCreateWithoutBalancesInput, UserUncheckedCreateWithoutBalancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBalancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBalancesInput, UserUncheckedUpdateWithoutBalancesInput>
  }

  export type UserUpdateWithoutBalancesInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBalancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutBalancesInput = {
    update: XOR<CryptoTokenUpdateWithoutBalancesInput, CryptoTokenUncheckedUpdateWithoutBalancesInput>
    create: XOR<CryptoTokenCreateWithoutBalancesInput, CryptoTokenUncheckedCreateWithoutBalancesInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutBalancesInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutBalancesInput, CryptoTokenUncheckedUpdateWithoutBalancesInput>
  }

  export type CryptoTokenUpdateWithoutBalancesInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutBalancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutTransactionsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type CryptoTokenCreateWithoutTransactionsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutTransactionsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutTransactionsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutTransactionsInput, CryptoTokenUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutTransactionsInput = {
    update: XOR<CryptoTokenUpdateWithoutTransactionsInput, CryptoTokenUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CryptoTokenCreateWithoutTransactionsInput, CryptoTokenUncheckedCreateWithoutTransactionsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutTransactionsInput, CryptoTokenUncheckedUpdateWithoutTransactionsInput>
  }

  export type CryptoTokenUpdateWithoutTransactionsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutBetsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBetsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
  }

  export type CryptoTokenCreateWithoutBetsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutBetsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutBetsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutBetsInput, CryptoTokenUncheckedCreateWithoutBetsInput>
  }

  export type UserUpsertWithoutBetsInput = {
    update: XOR<UserUpdateWithoutBetsInput, UserUncheckedUpdateWithoutBetsInput>
    create: XOR<UserCreateWithoutBetsInput, UserUncheckedCreateWithoutBetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBetsInput, UserUncheckedUpdateWithoutBetsInput>
  }

  export type UserUpdateWithoutBetsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutBetsInput = {
    update: XOR<CryptoTokenUpdateWithoutBetsInput, CryptoTokenUncheckedUpdateWithoutBetsInput>
    create: XOR<CryptoTokenCreateWithoutBetsInput, CryptoTokenUncheckedCreateWithoutBetsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutBetsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutBetsInput, CryptoTokenUncheckedUpdateWithoutBetsInput>
  }

  export type CryptoTokenUpdateWithoutBetsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserBonusCreateWithoutBonusInput = {
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutBonusesInput
    token: CryptoTokenCreateNestedOneWithoutUserBonusesInput
  }

  export type UserBonusUncheckedCreateWithoutBonusInput = {
    id?: number
    userId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusCreateOrConnectWithoutBonusInput = {
    where: UserBonusWhereUniqueInput
    create: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput>
  }

  export type UserBonusCreateManyBonusInputEnvelope = {
    data: UserBonusCreateManyBonusInput | UserBonusCreateManyBonusInput[]
    skipDuplicates?: boolean
  }

  export type UserBonusUpsertWithWhereUniqueWithoutBonusInput = {
    where: UserBonusWhereUniqueInput
    update: XOR<UserBonusUpdateWithoutBonusInput, UserBonusUncheckedUpdateWithoutBonusInput>
    create: XOR<UserBonusCreateWithoutBonusInput, UserBonusUncheckedCreateWithoutBonusInput>
  }

  export type UserBonusUpdateWithWhereUniqueWithoutBonusInput = {
    where: UserBonusWhereUniqueInput
    data: XOR<UserBonusUpdateWithoutBonusInput, UserBonusUncheckedUpdateWithoutBonusInput>
  }

  export type UserBonusUpdateManyWithWhereWithoutBonusInput = {
    where: UserBonusScalarWhereInput
    data: XOR<UserBonusUpdateManyMutationInput, UserBonusUncheckedUpdateManyWithoutBonusInput>
  }

  export type UserCreateWithoutBonusesInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBonusesInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBonusesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
  }

  export type BonusCreateWithoutUserBonusesInput = {
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
  }

  export type BonusUncheckedCreateWithoutUserBonusesInput = {
    id?: number
    name: string
    description: string
    wageringMultiplier: number
    maxBonusAmount: Decimal | DecimalJsLike | number | string
  }

  export type BonusCreateOrConnectWithoutUserBonusesInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutUserBonusesInput, BonusUncheckedCreateWithoutUserBonusesInput>
  }

  export type CryptoTokenCreateWithoutUserBonusesInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutUserBonusesInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutUserBonusesInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutUserBonusesInput, CryptoTokenUncheckedCreateWithoutUserBonusesInput>
  }

  export type UserUpsertWithoutBonusesInput = {
    update: XOR<UserUpdateWithoutBonusesInput, UserUncheckedUpdateWithoutBonusesInput>
    create: XOR<UserCreateWithoutBonusesInput, UserUncheckedCreateWithoutBonusesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBonusesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBonusesInput, UserUncheckedUpdateWithoutBonusesInput>
  }

  export type UserUpdateWithoutBonusesInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BonusUpsertWithoutUserBonusesInput = {
    update: XOR<BonusUpdateWithoutUserBonusesInput, BonusUncheckedUpdateWithoutUserBonusesInput>
    create: XOR<BonusCreateWithoutUserBonusesInput, BonusUncheckedCreateWithoutUserBonusesInput>
    where?: BonusWhereInput
  }

  export type BonusUpdateToOneWithWhereWithoutUserBonusesInput = {
    where?: BonusWhereInput
    data: XOR<BonusUpdateWithoutUserBonusesInput, BonusUncheckedUpdateWithoutUserBonusesInput>
  }

  export type BonusUpdateWithoutUserBonusesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BonusUncheckedUpdateWithoutUserBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wageringMultiplier?: FloatFieldUpdateOperationsInput | number
    maxBonusAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CryptoTokenUpsertWithoutUserBonusesInput = {
    update: XOR<CryptoTokenUpdateWithoutUserBonusesInput, CryptoTokenUncheckedUpdateWithoutUserBonusesInput>
    create: XOR<CryptoTokenCreateWithoutUserBonusesInput, CryptoTokenUncheckedCreateWithoutUserBonusesInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutUserBonusesInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutUserBonusesInput, CryptoTokenUncheckedUpdateWithoutUserBonusesInput>
  }

  export type CryptoTokenUpdateWithoutUserBonusesInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutUserBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutLeaderboardEntriesInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaderboardEntriesInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaderboardEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
  }

  export type CryptoTokenCreateWithoutLeaderboardInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutLeaderboardInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutLeaderboardInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutLeaderboardInput, CryptoTokenUncheckedCreateWithoutLeaderboardInput>
  }

  export type UserUpsertWithoutLeaderboardEntriesInput = {
    update: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type UserUpdateWithoutLeaderboardEntriesInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutLeaderboardInput = {
    update: XOR<CryptoTokenUpdateWithoutLeaderboardInput, CryptoTokenUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<CryptoTokenCreateWithoutLeaderboardInput, CryptoTokenUncheckedCreateWithoutLeaderboardInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutLeaderboardInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutLeaderboardInput, CryptoTokenUncheckedUpdateWithoutLeaderboardInput>
  }

  export type CryptoTokenUpdateWithoutLeaderboardInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutLeaderboardInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutCommissionsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommissionsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
  }

  export type UserCreateWithoutReferralActionsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralActionsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralActionsInput, UserUncheckedCreateWithoutReferralActionsInput>
  }

  export type CryptoTokenCreateWithoutReferralCommissionsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutReferralCommissionsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutReferralCommissionsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutReferralCommissionsInput, CryptoTokenUncheckedCreateWithoutReferralCommissionsInput>
  }

  export type UserUpsertWithoutCommissionsInput = {
    update: XOR<UserUpdateWithoutCommissionsInput, UserUncheckedUpdateWithoutCommissionsInput>
    create: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommissionsInput, UserUncheckedUpdateWithoutCommissionsInput>
  }

  export type UserUpdateWithoutCommissionsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferralActionsInput = {
    update: XOR<UserUpdateWithoutReferralActionsInput, UserUncheckedUpdateWithoutReferralActionsInput>
    create: XOR<UserCreateWithoutReferralActionsInput, UserUncheckedCreateWithoutReferralActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralActionsInput, UserUncheckedUpdateWithoutReferralActionsInput>
  }

  export type UserUpdateWithoutReferralActionsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutReferralCommissionsInput = {
    update: XOR<CryptoTokenUpdateWithoutReferralCommissionsInput, CryptoTokenUncheckedUpdateWithoutReferralCommissionsInput>
    create: XOR<CryptoTokenCreateWithoutReferralCommissionsInput, CryptoTokenUncheckedCreateWithoutReferralCommissionsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutReferralCommissionsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutReferralCommissionsInput, CryptoTokenUncheckedUpdateWithoutReferralCommissionsInput>
  }

  export type CryptoTokenUpdateWithoutReferralCommissionsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutReferralCommissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutAuthTokensInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutAuthTokensInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutAuthTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
  }

  export type UserUpsertWithoutAuthTokensInput = {
    update: XOR<UserUpdateWithoutAuthTokensInput, UserUncheckedUpdateWithoutAuthTokensInput>
    create: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthTokensInput, UserUncheckedUpdateWithoutAuthTokensInput>
  }

  export type UserUpdateWithoutAuthTokensInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
  }

  export type CrashBetCreateWithoutRoundInput = {
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCrashBetsInput
    token: CryptoTokenCreateNestedOneWithoutCrashBetsInput
    transactions?: CrashTransactionCreateNestedManyWithoutBetInput
  }

  export type CrashBetUncheckedCreateWithoutRoundInput = {
    id?: number
    userId: number
    tokenId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    transactions?: CrashTransactionUncheckedCreateNestedManyWithoutBetInput
  }

  export type CrashBetCreateOrConnectWithoutRoundInput = {
    where: CrashBetWhereUniqueInput
    create: XOR<CrashBetCreateWithoutRoundInput, CrashBetUncheckedCreateWithoutRoundInput>
  }

  export type CrashBetCreateManyRoundInputEnvelope = {
    data: CrashBetCreateManyRoundInput | CrashBetCreateManyRoundInput[]
    skipDuplicates?: boolean
  }

  export type CrashBetUpsertWithWhereUniqueWithoutRoundInput = {
    where: CrashBetWhereUniqueInput
    update: XOR<CrashBetUpdateWithoutRoundInput, CrashBetUncheckedUpdateWithoutRoundInput>
    create: XOR<CrashBetCreateWithoutRoundInput, CrashBetUncheckedCreateWithoutRoundInput>
  }

  export type CrashBetUpdateWithWhereUniqueWithoutRoundInput = {
    where: CrashBetWhereUniqueInput
    data: XOR<CrashBetUpdateWithoutRoundInput, CrashBetUncheckedUpdateWithoutRoundInput>
  }

  export type CrashBetUpdateManyWithWhereWithoutRoundInput = {
    where: CrashBetScalarWhereInput
    data: XOR<CrashBetUpdateManyMutationInput, CrashBetUncheckedUpdateManyWithoutRoundInput>
  }

  export type CrashRoundCreateWithoutBetsInput = {
    gameId: string
    crashPoint: Decimal | DecimalJsLike | number | string
    totalPlayers?: number
    winnersCount?: number
    totalWagered?: Decimal | DecimalJsLike | number | string
    totalPayouts?: Decimal | DecimalJsLike | number | string
    serverSeedHash: string
    clientSeed: string
    nonce?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrashRoundUncheckedCreateWithoutBetsInput = {
    id?: number
    gameId: string
    crashPoint: Decimal | DecimalJsLike | number | string
    totalPlayers?: number
    winnersCount?: number
    totalWagered?: Decimal | DecimalJsLike | number | string
    totalPayouts?: Decimal | DecimalJsLike | number | string
    serverSeedHash: string
    clientSeed: string
    nonce?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrashRoundCreateOrConnectWithoutBetsInput = {
    where: CrashRoundWhereUniqueInput
    create: XOR<CrashRoundCreateWithoutBetsInput, CrashRoundUncheckedCreateWithoutBetsInput>
  }

  export type UserCreateWithoutCrashBetsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCrashBetsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCrashBetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrashBetsInput, UserUncheckedCreateWithoutCrashBetsInput>
  }

  export type CryptoTokenCreateWithoutCrashBetsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutCrashBetsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutCrashBetsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutCrashBetsInput, CryptoTokenUncheckedCreateWithoutCrashBetsInput>
  }

  export type CrashTransactionCreateWithoutBetInput = {
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCrashTransactionsInput
    token: CryptoTokenCreateNestedOneWithoutCrashTransactionsInput
  }

  export type CrashTransactionUncheckedCreateWithoutBetInput = {
    id?: number
    userId: number
    tokenId: number
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type CrashTransactionCreateOrConnectWithoutBetInput = {
    where: CrashTransactionWhereUniqueInput
    create: XOR<CrashTransactionCreateWithoutBetInput, CrashTransactionUncheckedCreateWithoutBetInput>
  }

  export type CrashTransactionCreateManyBetInputEnvelope = {
    data: CrashTransactionCreateManyBetInput | CrashTransactionCreateManyBetInput[]
    skipDuplicates?: boolean
  }

  export type CrashRoundUpsertWithoutBetsInput = {
    update: XOR<CrashRoundUpdateWithoutBetsInput, CrashRoundUncheckedUpdateWithoutBetsInput>
    create: XOR<CrashRoundCreateWithoutBetsInput, CrashRoundUncheckedCreateWithoutBetsInput>
    where?: CrashRoundWhereInput
  }

  export type CrashRoundUpdateToOneWithWhereWithoutBetsInput = {
    where?: CrashRoundWhereInput
    data: XOR<CrashRoundUpdateWithoutBetsInput, CrashRoundUncheckedUpdateWithoutBetsInput>
  }

  export type CrashRoundUpdateWithoutBetsInput = {
    gameId?: StringFieldUpdateOperationsInput | string
    crashPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntFieldUpdateOperationsInput | number
    winnersCount?: IntFieldUpdateOperationsInput | number
    totalWagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serverSeedHash?: StringFieldUpdateOperationsInput | string
    clientSeed?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashRoundUncheckedUpdateWithoutBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
    crashPoint?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlayers?: IntFieldUpdateOperationsInput | number
    winnersCount?: IntFieldUpdateOperationsInput | number
    totalWagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPayouts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serverSeedHash?: StringFieldUpdateOperationsInput | string
    clientSeed?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCrashBetsInput = {
    update: XOR<UserUpdateWithoutCrashBetsInput, UserUncheckedUpdateWithoutCrashBetsInput>
    create: XOR<UserCreateWithoutCrashBetsInput, UserUncheckedCreateWithoutCrashBetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCrashBetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCrashBetsInput, UserUncheckedUpdateWithoutCrashBetsInput>
  }

  export type UserUpdateWithoutCrashBetsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCrashBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutCrashBetsInput = {
    update: XOR<CryptoTokenUpdateWithoutCrashBetsInput, CryptoTokenUncheckedUpdateWithoutCrashBetsInput>
    create: XOR<CryptoTokenCreateWithoutCrashBetsInput, CryptoTokenUncheckedCreateWithoutCrashBetsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutCrashBetsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutCrashBetsInput, CryptoTokenUncheckedUpdateWithoutCrashBetsInput>
  }

  export type CryptoTokenUpdateWithoutCrashBetsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutCrashBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type CrashTransactionUpsertWithWhereUniqueWithoutBetInput = {
    where: CrashTransactionWhereUniqueInput
    update: XOR<CrashTransactionUpdateWithoutBetInput, CrashTransactionUncheckedUpdateWithoutBetInput>
    create: XOR<CrashTransactionCreateWithoutBetInput, CrashTransactionUncheckedCreateWithoutBetInput>
  }

  export type CrashTransactionUpdateWithWhereUniqueWithoutBetInput = {
    where: CrashTransactionWhereUniqueInput
    data: XOR<CrashTransactionUpdateWithoutBetInput, CrashTransactionUncheckedUpdateWithoutBetInput>
  }

  export type CrashTransactionUpdateManyWithWhereWithoutBetInput = {
    where: CrashTransactionScalarWhereInput
    data: XOR<CrashTransactionUpdateManyMutationInput, CrashTransactionUncheckedUpdateManyWithoutBetInput>
  }

  export type UserCreateWithoutCrashTransactionsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCrashTransactionsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCrashTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrashTransactionsInput, UserUncheckedCreateWithoutCrashTransactionsInput>
  }

  export type CrashBetCreateWithoutTransactionsInput = {
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
    round: CrashRoundCreateNestedOneWithoutBetsInput
    user: UserCreateNestedOneWithoutCrashBetsInput
    token: CryptoTokenCreateNestedOneWithoutCrashBetsInput
  }

  export type CrashBetUncheckedCreateWithoutTransactionsInput = {
    id?: number
    roundId: number
    userId: number
    tokenId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
  }

  export type CrashBetCreateOrConnectWithoutTransactionsInput = {
    where: CrashBetWhereUniqueInput
    create: XOR<CrashBetCreateWithoutTransactionsInput, CrashBetUncheckedCreateWithoutTransactionsInput>
  }

  export type CryptoTokenCreateWithoutCrashTransactionsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutCrashTransactionsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutCrashTransactionsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutCrashTransactionsInput, CryptoTokenUncheckedCreateWithoutCrashTransactionsInput>
  }

  export type UserUpsertWithoutCrashTransactionsInput = {
    update: XOR<UserUpdateWithoutCrashTransactionsInput, UserUncheckedUpdateWithoutCrashTransactionsInput>
    create: XOR<UserCreateWithoutCrashTransactionsInput, UserUncheckedCreateWithoutCrashTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCrashTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCrashTransactionsInput, UserUncheckedUpdateWithoutCrashTransactionsInput>
  }

  export type UserUpdateWithoutCrashTransactionsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCrashTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CrashBetUpsertWithoutTransactionsInput = {
    update: XOR<CrashBetUpdateWithoutTransactionsInput, CrashBetUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CrashBetCreateWithoutTransactionsInput, CrashBetUncheckedCreateWithoutTransactionsInput>
    where?: CrashBetWhereInput
  }

  export type CrashBetUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CrashBetWhereInput
    data: XOR<CrashBetUpdateWithoutTransactionsInput, CrashBetUncheckedUpdateWithoutTransactionsInput>
  }

  export type CrashBetUpdateWithoutTransactionsInput = {
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: CrashRoundUpdateOneRequiredWithoutBetsNestedInput
    user?: UserUpdateOneRequiredWithoutCrashBetsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutCrashBetsNestedInput
  }

  export type CrashBetUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTokenUpsertWithoutCrashTransactionsInput = {
    update: XOR<CryptoTokenUpdateWithoutCrashTransactionsInput, CryptoTokenUncheckedUpdateWithoutCrashTransactionsInput>
    create: XOR<CryptoTokenCreateWithoutCrashTransactionsInput, CryptoTokenUncheckedCreateWithoutCrashTransactionsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutCrashTransactionsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutCrashTransactionsInput, CryptoTokenUncheckedUpdateWithoutCrashTransactionsInput>
  }

  export type CryptoTokenUpdateWithoutCrashTransactionsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutCrashTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type MinesweeperGameCreateWithoutDifficultyInput = {
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMinesweeperGamesInput
    token: CryptoTokenCreateNestedOneWithoutMinesweeperGamesInput
  }

  export type MinesweeperGameUncheckedCreateWithoutDifficultyInput = {
    id?: number
    userId: number
    tokenId: number
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinesweeperGameCreateOrConnectWithoutDifficultyInput = {
    where: MinesweeperGameWhereUniqueInput
    create: XOR<MinesweeperGameCreateWithoutDifficultyInput, MinesweeperGameUncheckedCreateWithoutDifficultyInput>
  }

  export type MinesweeperGameCreateManyDifficultyInputEnvelope = {
    data: MinesweeperGameCreateManyDifficultyInput | MinesweeperGameCreateManyDifficultyInput[]
    skipDuplicates?: boolean
  }

  export type MinesweeperGameUpsertWithWhereUniqueWithoutDifficultyInput = {
    where: MinesweeperGameWhereUniqueInput
    update: XOR<MinesweeperGameUpdateWithoutDifficultyInput, MinesweeperGameUncheckedUpdateWithoutDifficultyInput>
    create: XOR<MinesweeperGameCreateWithoutDifficultyInput, MinesweeperGameUncheckedCreateWithoutDifficultyInput>
  }

  export type MinesweeperGameUpdateWithWhereUniqueWithoutDifficultyInput = {
    where: MinesweeperGameWhereUniqueInput
    data: XOR<MinesweeperGameUpdateWithoutDifficultyInput, MinesweeperGameUncheckedUpdateWithoutDifficultyInput>
  }

  export type MinesweeperGameUpdateManyWithWhereWithoutDifficultyInput = {
    where: MinesweeperGameScalarWhereInput
    data: XOR<MinesweeperGameUpdateManyMutationInput, MinesweeperGameUncheckedUpdateManyWithoutDifficultyInput>
  }

  export type UserCreateWithoutMinesweeperGamesInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMinesweeperGamesInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMinesweeperGamesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMinesweeperGamesInput, UserUncheckedCreateWithoutMinesweeperGamesInput>
  }

  export type CryptoTokenCreateWithoutMinesweeperGamesInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutMinesweeperGamesInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperBets?: MinesweeperBetUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutMinesweeperGamesInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutMinesweeperGamesInput, CryptoTokenUncheckedCreateWithoutMinesweeperGamesInput>
  }

  export type MinesweeperDifficultyCreateWithoutGamesInput = {
    name: string
    minesCount: number
    gridSize?: number
    multiplier: number
    createdAt?: Date | string
  }

  export type MinesweeperDifficultyUncheckedCreateWithoutGamesInput = {
    id?: number
    name: string
    minesCount: number
    gridSize?: number
    multiplier: number
    createdAt?: Date | string
  }

  export type MinesweeperDifficultyCreateOrConnectWithoutGamesInput = {
    where: MinesweeperDifficultyWhereUniqueInput
    create: XOR<MinesweeperDifficultyCreateWithoutGamesInput, MinesweeperDifficultyUncheckedCreateWithoutGamesInput>
  }

  export type UserUpsertWithoutMinesweeperGamesInput = {
    update: XOR<UserUpdateWithoutMinesweeperGamesInput, UserUncheckedUpdateWithoutMinesweeperGamesInput>
    create: XOR<UserCreateWithoutMinesweeperGamesInput, UserUncheckedCreateWithoutMinesweeperGamesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMinesweeperGamesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMinesweeperGamesInput, UserUncheckedUpdateWithoutMinesweeperGamesInput>
  }

  export type UserUpdateWithoutMinesweeperGamesInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMinesweeperGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutMinesweeperGamesInput = {
    update: XOR<CryptoTokenUpdateWithoutMinesweeperGamesInput, CryptoTokenUncheckedUpdateWithoutMinesweeperGamesInput>
    create: XOR<CryptoTokenCreateWithoutMinesweeperGamesInput, CryptoTokenUncheckedCreateWithoutMinesweeperGamesInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutMinesweeperGamesInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutMinesweeperGamesInput, CryptoTokenUncheckedUpdateWithoutMinesweeperGamesInput>
  }

  export type CryptoTokenUpdateWithoutMinesweeperGamesInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutMinesweeperGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type MinesweeperDifficultyUpsertWithoutGamesInput = {
    update: XOR<MinesweeperDifficultyUpdateWithoutGamesInput, MinesweeperDifficultyUncheckedUpdateWithoutGamesInput>
    create: XOR<MinesweeperDifficultyCreateWithoutGamesInput, MinesweeperDifficultyUncheckedCreateWithoutGamesInput>
    where?: MinesweeperDifficultyWhereInput
  }

  export type MinesweeperDifficultyUpdateToOneWithWhereWithoutGamesInput = {
    where?: MinesweeperDifficultyWhereInput
    data: XOR<MinesweeperDifficultyUpdateWithoutGamesInput, MinesweeperDifficultyUncheckedUpdateWithoutGamesInput>
  }

  export type MinesweeperDifficultyUpdateWithoutGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    minesCount?: IntFieldUpdateOperationsInput | number
    gridSize?: IntFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperDifficultyUncheckedUpdateWithoutGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    minesCount?: IntFieldUpdateOperationsInput | number
    gridSize?: IntFieldUpdateOperationsInput | number
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutMinesweeperBetsInput = {
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutUserInput
    balances?: BalanceCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    bets?: BetCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryCreateNestedManyWithoutUserInput
    bonuses?: UserBonusCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMinesweeperBetsInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
    referredById?: number | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutUserInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutUserInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutUserInput
    balances?: BalanceUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    bets?: BetUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardEntryUncheckedCreateNestedManyWithoutUserInput
    bonuses?: UserBonusUncheckedCreateNestedManyWithoutUserInput
    commissions?: ReferralTransactionUncheckedCreateNestedManyWithoutReferrerInput
    referralActions?: ReferralTransactionUncheckedCreateNestedManyWithoutRefereeInput
    authTokens?: OneTimeTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMinesweeperBetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMinesweeperBetsInput, UserUncheckedCreateWithoutMinesweeperBetsInput>
  }

  export type CryptoTokenCreateWithoutMinesweeperBetsInput = {
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameCreateNestedManyWithoutTokenInput
    balances?: BalanceCreateNestedManyWithoutTokenInput
    transactions?: TransactionCreateNestedManyWithoutTokenInput
    bets?: BetCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenUncheckedCreateWithoutMinesweeperBetsInput = {
    id?: number
    symbol: string
    name: string
    network?: string
    decimals: number
    createdAt?: Date | string
    crashBets?: CrashBetUncheckedCreateNestedManyWithoutTokenInput
    crashTransactions?: CrashTransactionUncheckedCreateNestedManyWithoutTokenInput
    minesweeperGames?: MinesweeperGameUncheckedCreateNestedManyWithoutTokenInput
    balances?: BalanceUncheckedCreateNestedManyWithoutTokenInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTokenInput
    bets?: BetUncheckedCreateNestedManyWithoutTokenInput
    leaderboard?: LeaderboardEntryUncheckedCreateNestedManyWithoutTokenInput
    userBonuses?: UserBonusUncheckedCreateNestedManyWithoutTokenInput
    referralCommissions?: ReferralTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type CryptoTokenCreateOrConnectWithoutMinesweeperBetsInput = {
    where: CryptoTokenWhereUniqueInput
    create: XOR<CryptoTokenCreateWithoutMinesweeperBetsInput, CryptoTokenUncheckedCreateWithoutMinesweeperBetsInput>
  }

  export type UserUpsertWithoutMinesweeperBetsInput = {
    update: XOR<UserUpdateWithoutMinesweeperBetsInput, UserUncheckedUpdateWithoutMinesweeperBetsInput>
    create: XOR<UserCreateWithoutMinesweeperBetsInput, UserUncheckedCreateWithoutMinesweeperBetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMinesweeperBetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMinesweeperBetsInput, UserUncheckedUpdateWithoutMinesweeperBetsInput>
  }

  export type UserUpdateWithoutMinesweeperBetsInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMinesweeperBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableIntFieldUpdateOperationsInput | number | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTokenUpsertWithoutMinesweeperBetsInput = {
    update: XOR<CryptoTokenUpdateWithoutMinesweeperBetsInput, CryptoTokenUncheckedUpdateWithoutMinesweeperBetsInput>
    create: XOR<CryptoTokenCreateWithoutMinesweeperBetsInput, CryptoTokenUncheckedCreateWithoutMinesweeperBetsInput>
    where?: CryptoTokenWhereInput
  }

  export type CryptoTokenUpdateToOneWithWhereWithoutMinesweeperBetsInput = {
    where?: CryptoTokenWhereInput
    data: XOR<CryptoTokenUpdateWithoutMinesweeperBetsInput, CryptoTokenUncheckedUpdateWithoutMinesweeperBetsInput>
  }

  export type CryptoTokenUpdateWithoutMinesweeperBetsInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutTokenNestedInput
    balances?: BalanceUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUpdateManyWithoutTokenNestedInput
    bets?: BetUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUpdateManyWithoutTokenNestedInput
  }

  export type CryptoTokenUncheckedUpdateWithoutMinesweeperBetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crashBets?: CrashBetUncheckedUpdateManyWithoutTokenNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutTokenNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutTokenNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTokenNestedInput
    bets?: BetUncheckedUpdateManyWithoutTokenNestedInput
    leaderboard?: LeaderboardEntryUncheckedUpdateManyWithoutTokenNestedInput
    userBonuses?: UserBonusUncheckedUpdateManyWithoutTokenNestedInput
    referralCommissions?: ReferralTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type CrashBetCreateManyTokenInput = {
    id?: number
    roundId: number
    userId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
  }

  export type CrashTransactionCreateManyTokenInput = {
    id?: number
    userId: number
    betId?: number | null
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type MinesweeperGameCreateManyTokenInput = {
    id?: number
    userId: number
    difficultyId: number
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinesweeperBetCreateManyTokenInput = {
    id?: number
    userId: number
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
  }

  export type BalanceCreateManyTokenInput = {
    id?: number
    userId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyTokenInput = {
    id?: number
    userId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetCreateManyTokenInput = {
    id?: number
    userId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeaderboardEntryCreateManyTokenInput = {
    id?: number
    userId: number
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type UserBonusCreateManyTokenInput = {
    id?: number
    userId: number
    bonusId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ReferralTransactionCreateManyTokenInput = {
    id?: number
    referrerId: number
    refereeId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type CrashBetUpdateWithoutTokenInput = {
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: CrashRoundUpdateOneRequiredWithoutBetsNestedInput
    user?: UserUpdateOneRequiredWithoutCrashBetsNestedInput
    transactions?: CrashTransactionUpdateManyWithoutBetNestedInput
  }

  export type CrashBetUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CrashTransactionUncheckedUpdateManyWithoutBetNestedInput
  }

  export type CrashBetUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionUpdateWithoutTokenInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCrashTransactionsNestedInput
    bet?: CrashBetUpdateOneWithoutTransactionsNestedInput
  }

  export type CrashTransactionUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    betId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    betId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameUpdateWithoutTokenInput = {
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMinesweeperGamesNestedInput
    difficulty?: MinesweeperDifficultyUpdateOneRequiredWithoutGamesNestedInput
  }

  export type MinesweeperGameUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    difficultyId?: IntFieldUpdateOperationsInput | number
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    difficultyId?: IntFieldUpdateOperationsInput | number
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperBetUpdateWithoutTokenInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMinesweeperBetsNestedInput
  }

  export type MinesweeperBetUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperBetUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUpdateWithoutTokenInput = {
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutTokenInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUpdateWithoutTokenInput = {
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBetsNestedInput
  }

  export type BetUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUpdateWithoutTokenInput = {
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusUpdateWithoutTokenInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    bonus?: BonusUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralTransactionUpdateWithoutTokenInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutCommissionsNestedInput
    referee?: UserUpdateOneRequiredWithoutReferralActionsNestedInput
  }

  export type ReferralTransactionUncheckedUpdateWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyReferrerInput = {
    id?: number
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    photoUrl?: string | null
    passwordHash?: string | null
    salt?: string | null
    isAdmin?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string
  }

  export type CrashBetCreateManyUserInput = {
    id?: number
    roundId: number
    tokenId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
  }

  export type CrashTransactionCreateManyUserInput = {
    id?: number
    betId?: number | null
    tokenId: number
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type MinesweeperGameCreateManyUserInput = {
    id?: number
    tokenId: number
    difficultyId: number
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinesweeperBetCreateManyUserInput = {
    id?: number
    tokenId: number
    gameId: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    result: string
    multiplier: number
    createdAt?: Date | string
  }

  export type BalanceCreateManyUserInput = {
    id?: number
    tokenId: number
    type?: $Enums.BalanceType
    amount?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    tokenId: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    walletAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetCreateManyUserInput = {
    id?: number
    tokenId: number
    gameType: $Enums.GameType
    betAmount: Decimal | DecimalJsLike | number | string
    payoutAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    payoutRatio: number
    roundId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LeaderboardEntryCreateManyUserInput = {
    id?: number
    tokenId?: number | null
    metric: string
    score: Decimal | DecimalJsLike | number | string
    period: string
    updatedAt?: Date | string
  }

  export type UserBonusCreateManyUserInput = {
    id?: number
    bonusId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ReferralTransactionCreateManyReferrerInput = {
    id?: number
    refereeId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type ReferralTransactionCreateManyRefereeInput = {
    id?: number
    referrerId: number
    tokenId: number
    eventType: $Enums.ReferralEventType
    amount: Decimal | DecimalJsLike | number | string
    sourceEntityId: number
    sourceEntityType: string
    createdAt?: Date | string
  }

  export type OneTimeTokenCreateManyUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    used?: boolean
  }

  export type UserUpdateWithoutReferrerInput = {
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUpdateManyWithoutUserNestedInput
    balances?: BalanceUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    bets?: BetUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    crashBets?: CrashBetUncheckedUpdateManyWithoutUserNestedInput
    crashTransactions?: CrashTransactionUncheckedUpdateManyWithoutUserNestedInput
    minesweeperGames?: MinesweeperGameUncheckedUpdateManyWithoutUserNestedInput
    minesweeperBets?: MinesweeperBetUncheckedUpdateManyWithoutUserNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    bets?: BetUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardEntryUncheckedUpdateManyWithoutUserNestedInput
    bonuses?: UserBonusUncheckedUpdateManyWithoutUserNestedInput
    commissions?: ReferralTransactionUncheckedUpdateManyWithoutReferrerNestedInput
    referralActions?: ReferralTransactionUncheckedUpdateManyWithoutRefereeNestedInput
    authTokens?: OneTimeTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    salt?: NullableStringFieldUpdateOperationsInput | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type CrashBetUpdateWithoutUserInput = {
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: CrashRoundUpdateOneRequiredWithoutBetsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutCrashBetsNestedInput
    transactions?: CrashTransactionUpdateManyWithoutBetNestedInput
  }

  export type CrashBetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CrashTransactionUncheckedUpdateManyWithoutBetNestedInput
  }

  export type CrashBetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionUpdateWithoutUserInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bet?: CrashBetUpdateOneWithoutTransactionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutCrashTransactionsNestedInput
  }

  export type CrashTransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    betId?: NullableIntFieldUpdateOperationsInput | number | null
    tokenId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    betId?: NullableIntFieldUpdateOperationsInput | number | null
    tokenId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameUpdateWithoutUserInput = {
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneRequiredWithoutMinesweeperGamesNestedInput
    difficulty?: MinesweeperDifficultyUpdateOneRequiredWithoutGamesNestedInput
  }

  export type MinesweeperGameUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    difficultyId?: IntFieldUpdateOperationsInput | number
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    difficultyId?: IntFieldUpdateOperationsInput | number
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperBetUpdateWithoutUserInput = {
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneRequiredWithoutMinesweeperBetsNestedInput
  }

  export type MinesweeperBetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperBetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUpdateWithoutUserInput = {
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUpdateWithoutUserInput = {
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneRequiredWithoutBetsNestedInput
  }

  export type BetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payoutRatio?: FloatFieldUpdateOperationsInput | number
    roundId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUpdateWithoutUserInput = {
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: CryptoTokenUpdateOneWithoutLeaderboardNestedInput
  }

  export type LeaderboardEntryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: NullableIntFieldUpdateOperationsInput | number | null
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardEntryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenId?: NullableIntFieldUpdateOperationsInput | number | null
    metric?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBonusUpdateWithoutUserInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bonus?: BonusUpdateOneRequiredWithoutUserBonusesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bonusId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferralTransactionUpdateWithoutReferrerInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referee?: UserUpdateOneRequiredWithoutReferralActionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutReferralCommissionsNestedInput
  }

  export type ReferralTransactionUncheckedUpdateWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    refereeId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUpdateWithoutRefereeInput = {
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutCommissionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutReferralCommissionsNestedInput
  }

  export type ReferralTransactionUncheckedUpdateWithoutRefereeInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralTransactionUncheckedUpdateManyWithoutRefereeInput = {
    id?: IntFieldUpdateOperationsInput | number
    referrerId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    eventType?: EnumReferralEventTypeFieldUpdateOperationsInput | $Enums.ReferralEventType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceEntityId?: IntFieldUpdateOperationsInput | number
    sourceEntityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneTimeTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OneTimeTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OneTimeTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserBonusCreateManyBonusInput = {
    id?: number
    userId: number
    tokenId: number
    grantedAmount: Decimal | DecimalJsLike | number | string
    requiredWager: Decimal | DecimalJsLike | number | string
    wageredAmount?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserBonusUpdateWithoutBonusInput = {
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBonusesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutUserBonusesNestedInput
  }

  export type UserBonusUncheckedUpdateWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBonusUncheckedUpdateManyWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    grantedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requiredWager?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wageredAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CrashBetCreateManyRoundInput = {
    id?: number
    userId: number
    tokenId: number
    betAmount: Decimal | DecimalJsLike | number | string
    exitMultiplier?: Decimal | DecimalJsLike | number | string | null
    winnings?: Decimal | DecimalJsLike | number | string | null
    result: string
    createdAt?: Date | string
  }

  export type CrashBetUpdateWithoutRoundInput = {
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCrashBetsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutCrashBetsNestedInput
    transactions?: CrashTransactionUpdateManyWithoutBetNestedInput
  }

  export type CrashBetUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CrashTransactionUncheckedUpdateManyWithoutBetNestedInput
  }

  export type CrashBetUncheckedUpdateManyWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exitMultiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winnings?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionCreateManyBetInput = {
    id?: number
    userId: number
    tokenId: number
    amount: Decimal | DecimalJsLike | number | string
    type: string
    createdAt?: Date | string
  }

  export type CrashTransactionUpdateWithoutBetInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCrashTransactionsNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutCrashTransactionsNestedInput
  }

  export type CrashTransactionUncheckedUpdateWithoutBetInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrashTransactionUncheckedUpdateManyWithoutBetInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameCreateManyDifficultyInput = {
    id?: number
    userId: number
    tokenId: number
    gameState: JsonNullValueInput | InputJsonValue
    minesPositions: JsonNullValueInput | InputJsonValue
    status?: string
    revealedCells?: number
    flaggedCells?: number
    betAmount: Decimal | DecimalJsLike | number | string
    winAmount?: Decimal | DecimalJsLike | number | string | null
    multiplier?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinesweeperGameUpdateWithoutDifficultyInput = {
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMinesweeperGamesNestedInput
    token?: CryptoTokenUpdateOneRequiredWithoutMinesweeperGamesNestedInput
  }

  export type MinesweeperGameUncheckedUpdateWithoutDifficultyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinesweeperGameUncheckedUpdateManyWithoutDifficultyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenId?: IntFieldUpdateOperationsInput | number
    gameState?: JsonNullValueInput | InputJsonValue
    minesPositions?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    revealedCells?: IntFieldUpdateOperationsInput | number
    flaggedCells?: IntFieldUpdateOperationsInput | number
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CryptoTokenCountOutputTypeDefaultArgs instead
     */
    export type CryptoTokenCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoTokenCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BonusCountOutputTypeDefaultArgs instead
     */
    export type BonusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BonusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrashRoundCountOutputTypeDefaultArgs instead
     */
    export type CrashRoundCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrashRoundCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrashBetCountOutputTypeDefaultArgs instead
     */
    export type CrashBetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrashBetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MinesweeperDifficultyCountOutputTypeDefaultArgs instead
     */
    export type MinesweeperDifficultyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MinesweeperDifficultyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoTokenDefaultArgs instead
     */
    export type CryptoTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BalanceDefaultArgs instead
     */
    export type BalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BalanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BetDefaultArgs instead
     */
    export type BetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BonusDefaultArgs instead
     */
    export type BonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BonusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBonusDefaultArgs instead
     */
    export type UserBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBonusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardEntryDefaultArgs instead
     */
    export type LeaderboardEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralTransactionDefaultArgs instead
     */
    export type ReferralTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OneTimeTokenDefaultArgs instead
     */
    export type OneTimeTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OneTimeTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrashRoundDefaultArgs instead
     */
    export type CrashRoundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrashRoundDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrashBetDefaultArgs instead
     */
    export type CrashBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrashBetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CrashTransactionDefaultArgs instead
     */
    export type CrashTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CrashTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MinesweeperDifficultyDefaultArgs instead
     */
    export type MinesweeperDifficultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MinesweeperDifficultyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MinesweeperGameDefaultArgs instead
     */
    export type MinesweeperGameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MinesweeperGameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MinesweeperBetDefaultArgs instead
     */
    export type MinesweeperBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MinesweeperBetDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}